---
title: "자료구조 정리"
date: 2019-02-27 15:10:30 -0400
categories: Data Structure
tags: Data Structure
---

# 자료구조 정리

### Stack
FILO (First-in-last-out) 자료구조
* 마지막에 들어간 데이터가 가장 처음 나온다

### Queue
FIFO (First-in-first-out) 자료구조
* 처음에 들어간 데이터가 가장 처음 나온다

### Circular Queue
Front와 Rear를 가진 Queue
* POP하면 Front가 +1 이 되고 PUSH를 하면 Rear가 +1 이 됨
* Rear는 마지막 데이터 바로 뒤에 위치하고, 만약 Rear == Front 라면 꽉찬 것

### Linked List
데이터의 앞 뒤가 서로 링크로 연결된 자료 구조
* 다음, 이전 데이터 접근 쉬움
* 임의의 데이터를 찾는데 O(N) 시간 걸림
* 데이터 삭제, 삽입이 빠름
  * 삭제, 삽입 시 해당 위치 좌우의 데이터의 링크만 잘 조정해주면됨

## Tree

### Binary Tree
루트 노드와, 그 루트 노드의 좌측, 우측 자식 노드로 구성된 트리
* Full Binary Tree : Binary Tree가 균형적이게 꽉찬 트리
* Complete Binary Tree : Full은 아니지만, Depth - 1까지는 Full이고, Depth는 좌측부터 시작해서 차례대로 차 있는 트리
* 배열이나, Link로 구현 가능

* Preorder Traversal (전위 순회)
  * 노드를 들리고 좌측 자식 -> 우측 자식 순으로 탐색
{% highlight c linenos=table %}
void preorder(treePointer ptr) {
  if(ptr) {
    printf("%d", ptr->data);
    preorder(ptr->leftChild);
    preorder(ptr->rightChild);
  }
}
{% endhighlight %}

* Inorder Traversal (중위 순회)
  * 좌측 자식이 없을 때까지 간 다음 들리고, 그 후 우측 자식 봄
{% highlight c linenos=table %}
void inorder(treePointer ptr) {
  if(ptr) {
    inorder(ptr->leftChild);
    printf("%d", ptr->data);
    inorder(ptr->rightChild);
  }
}
{% endhighlight %}

* Postorder Traversal (후위 순회)
  * 좌측 Subtree 그 다음 우측 Subtree 후 Root 방문
{% highlight c linenos=table %}
void postOrder(treePointer ptr) {
  if(ptr) {
    postOrder(ptr->leftChild);
    postOrder(ptr->rightChild);
    printf("%d", ptr->data);
  }
}
{% endhighlight %}

* Levelorder Traversal (레벨 순회)
  * Depth 순서대로 방문한다
{% highlight c linenos=table %}
Queue Q;
Q.push(1);
while(!Q.empty()) {
  visit(Q.front());
  Q.pop();
  Q.push(leftChild);
  Q.push(rightChild);
}
{% endhighlight %}

### Priority Queue (Max or Min Heap)
우선 순위가 높은 것 (값이 제일 크거나, 작거나 등) 부터 먼저 꺼내는 큐
{% highlight c++ linenos=table %}
void siftDown(vector<int>& arr, int idx) {
	int m = -1;
	if (arr.size() > idx * 2 + 1)
		m = arr[idx * 2] < arr[idx * 2 + 1] ? idx * 2 : idx * 2 + 1;
	else if (arr.size() > idx * 2)
		m = idx * 2;
	if (m != -1 && arr[idx] > arr[m]) {
		swap(arr[idx], arr[m]);
		siftDown(arr, m);
	}
}

void makeHeap(vector<int>& arr) {
	for (int i = arr.size() / 2; i >= 0; i--)
		siftDown(arr, i);
}

int pop(vector<int>& arr) {
	int top = arr[0];
	arr[0] = *(arr.end() - 1);
	arr.resize(arr.size() - 1);
	siftDown(arr, 0);
	return top;
}

vector<int> arr = { 2, 4, 5, 3, 1, 9, 6, 7, 10, 8 };
makeHeap(arr);
while (arr.size() > 0)
	printf("%d\n", pop(arr));
{% endhighlight %}

### Binary Search Tree
루트에서 작은 데이터는 좌측 큰 데이터는 우측으로 나눠서 데이터 관리
* 빠른 검색 가능

### Forest
트리를 여러개 가지는 자료구조

#### Disjoint Set
Union으로 두 집합을 묶을 수 있고, Find로 집합의 최상위 부모가 누구인지 찾는 자료 구조
* 집합의 결합이 매우 쉬움
{% highlight c++ linenos=table %}
int parent[100];

void Union(int a, int b) {
	parent[find(b)] = find(a);
}

int find(int idx) {
	if (parent[idx] == idx) return idx;
	return (parent[idx] = find(parent[idx]));
}

int main() {
	for (int i = 0; i < 100; i++)
		parent[i] = i;

	return 0;
}
{% endhighlight %}

## Graph
Vertex와 Vertex와 Vertex를 잇는 Edge로 구성된 자료 구조
* Directed Graph : Edge가 방향성을 가지는 자료 구조
* Complete Graph : 모든 Vertex가 연결되어 있을 경우
* Sub Graph : 어떤 Graph의 부분 집합
* in-degree : Vertex에 들어오는 Edge 수
* out-degree : Vertex에서 나가는 Edge 수
* Cyclic : 싸이클을 가지는 Graph
* Adjacency Matrix로 표현 가능

  |   | 1 | 2 | 3 | 4 |
  |---|---|---|---|---|
  | 1 | 0 | 1 | 1 | 1 |
  | 2 | 1 | 0 | 1 | 1 |
  | 3 | 1 | 1 | 0 | 1 |
  | 4 | 1 | 1 | 1 | 0 |

* Adjacency List로도 표현 가능

### Depth First Search
Stack을 이용해서 구현 가능
* 현재 Vertex에서 갈 수 있는 Vertex 중 하나를 Stack에 넣고 현재 Vertex 방문 표시
* Stack에서 Vertex를 꺼내서 위의 과정 반복 (방문 하지 않은 곳만 Stack에 넣음)
* 갈 수 있는 곳이 없으면 POP

### Breadth First Search
Queue를 이용해서 구현 가능
* 현재 Vertex에서 갈 수 있는 Vertex들 모두를 Queue에 넣음
* Queue에서 Vertex를 꺼내서 다시 갈 수 있는 Vertex들을 방문 하는 것을 반복

## Hashing
Dictionary 쌍을 O(1) 시간에 찾을 수 있도록 해주는 자료구조

### Static Hashing
* Hash table : Dictionary 들이 저장되어 있는 테이블
* Buckets b : Hash table은 N개의 Bucket으로 나뉘어져 있고, 하나의 Bucket은 s개의 Dictionary 쌍 들을 가질 수 있음
* Slots s : Bucket에서 s개의 Dictionary 쌍을 가질 수 있다는 것을 slot이 s개 있다고 표현함, 보통 Slot = 1
* Hash function H : Dictionary의 Key K와 Bucket B를 맵핑해주는 함수
	* H(K) = 0 ~ (b - 1) 까지 할당해주는 함수
* Hash : K의 Hash는 H(K) 임, Home address라고도 부름
* Key Density : (Dictionary 갯수 N) / (Key가 될 수 있는 모든 경우의 수 T)
* Loading Density : n / sb
* 보통 Key Density가 아주 작기 때문에 Hash Function이 하나의 Bucket안에 몇몇개의 Key가 있도록 한다 (Hash Table이 너무 커지지 않도록 하기 위해)
* Synonyms : H(k1) == H(k2) 일 경우 k1과 k2를 synonym이라 함
* Overflow : Bucket에 Slot이 남아 있지 않은데 데이터 넣으려 할 경우
* Collision : Bucket이 비어있지 않을 때 데이터 넣는 경우
* Insert, delete, find 는
	* Overflow가 일어나지 않을 경우 O(s)
	* Collision이 일어나지 않을 경우 O(1)

### Hash Functions
계산하기 쉽고, Collision의 수를 최소화하는 함수가 좋음
* Uniform Hash Function : H(k) = i 일 확률이 모든 Bucket i에 대해서 1/b일 경우
* 보통 Key를 정수로 변환한 다음 사칙 연산을 써서 함수를 만듬

#### Division
Hash Function H(k) = k % D
* 가장 쉽고 자주 쓰임

#### Mid-Square
Hash Function H(k) = select_mid(k * k)
* Key 값을 제곱한 다음 중간 몇 자리를 사용

#### Folding
* Shift Folding : 값을 일정 크기로 나눈 후 모두 더함
	* eg) 1234567890 => 123 + 456 + 789 + 0 = 1368
* Folding at the boundaries : 짝수 번째 파티션을 역으로 치환한 다음 더함
	* eg) 1234567890 => 123 + rev(456) + 789 + rev(0) = 123 + 654 + 789 + 0 = 1566

#### Digit Analysis
키 값을 모두 알 경우, 키 값을 구성하는 digit들의 분포를 이용함
* 키 값 중 분포가 일정한 숫자들을 뽑음
	* eg) 1, 3, 5 번째 숫자를 쓴다면
	
		| Key | H(Key) |
		| --- | ------ |
		| 134123 | 142 |
		| 534125 | 542 |
		| 23425  | 245 |

#### String Key를 양의 정수로 변환
{% highlight c++ linenos=table %}
unsigned int stringToInt(char *key) {
	unsigned int sum = 0;
	while (*key)
		sum += *key++;
	return sum;
}
{% endhighlight %}


### Overflow Handling
Hashing 시 Overflow 방지 방법

#### Open Addressing
이미 Hashtable에 H(k)가 있을 경우 다음 Bucket에 결과 삽입
* 아래의 경우 function이 if와 Hash가 같기 때문에 if의 다음 Bucket인 0에 삽입

	| Key | H(Key) |
	|:---:|:------:|
	| for | 2 |
	| do | 3 |
	| while | 4 |
	| if | 12 |
	| else | 9 |
	| function | 12 |

	| index | value |
	|:-:| --- |
	|0|function|
	|1||
	|2|for|
	|3|do|
	|4|while|
	|5||
	|6||
	|7||
	|8||
	|9|else|
	|10||
	|11||
	|12|if|

* Linear Probing 으로 테이블 검색
	1. H(K) 계산
	2. HT[H(K)], HT[(H(K) + 1) % b], ... , HT[(H(K) + j) % b]를 찾음
		1. HT[(H(K) + j) % b]가 K라면 찾음
		2. HT[(H(K) + j) % b]가 비었다면 못 찾음
		3. 다시 시작지점인 HT[H(K)]로 돌아온다면 못 찾은 것

#### Chaining
Collision이 일어났을 경우 해당 Bucket의 가장 뒤에 새로운 Key를 삽입
* Key끼리 링크로 이어짐

## Efficient Binary Search Trees
Optimal Binary Search Tree - 트리의 Depth가 log_2(N)인 트리

### AVL Tree
Vertex T에서 Balance Factor BF(T)가 1, 0, -1 중 하나인 Tree
* Balance Factor는 H_L - H_R (좌측 서브트리의 높이, 우측 서브트리의 높이)
* Binary Search Tree 이면서 Balanced되게 해줌
{% highlight c++ linenos=table %}
#include <iostream>
#include <vector>
#include <algorithm>
#include <string>

using namespace std;

typedef struct vertex {
	string key;
	int height = 1;
	struct vertex* left = NULL;
	struct vertex* right = NULL;
} vertex;

vertex* makeNode(string key) {
	vertex* node = new vertex;
	node->key = key;
	return node;
}

int height(vertex *ver) {
	return ver == NULL ? 0 : ver->height;
}

vertex* rotateRight(vertex* ver) {
	vertex* left = ver->left;
	vertex* right = left->right;
	left->right = ver;
	ver->left = right;

	ver->height = 1 + max(height(ver->left), height(ver->right));
	left->height = 1 + max(height(left->left), height(left->right));
	return left;
}

vertex* rotateLeft(vertex* ver) {
	vertex* right = ver->right;
	vertex* left = right->left;
	right->left = ver;
	ver->right = left;

	ver->height = 1 + max(height(ver->left), height(ver->right));
	right->height = 1 + max(height(right->left), height(right->right));
	return right;
}

vertex* insertVertex(vertex *ver, string key) {
	if (!ver) return makeNode(key);

	if (ver->key > key)
		ver->left = insertVertex(ver->left, key);
	else if (ver->key <= key)
		ver->right = insertVertex(ver->right, key);

	ver->height = 1 + max(height(ver->left), height(ver->right));
	
	int balance = height(ver->left) - height(ver->right);
	// Left Left
	if (balance >= 2 && ver->left->key > key)
		return rotateRight(ver);
	
	// Right Right
	if (balance <= -2 && ver->right->key < key)
		return rotateLeft(ver);

	// Left Right
	if (balance >= 2 && ver->left->key < key) {
		ver->left = rotateLeft(ver->left);
		return rotateRight(ver);
	}

	// Right Left
	if (balance <= -2 && ver->right->key > key) {
		ver->right = rotateRight(ver->right);
		return rotateLeft(ver);
	}

	return ver;
}

void inorder(vertex* ver) {
	if (ver) {
		inorder(ver->left);
		cout << ver->key << " ";
		inorder(ver->right);
	}
}

int main() {
	vector<string> month = {
		"MAR", "MAY", "NOV", "AUG", "APR", "JAN", "DEC", "JULY", "FEB", "JUNE", "OCT", "SEPT"
	};
	// AVL Tree
	vertex* root = NULL;

	for (string m : month)
		root = insertVertex(root, m);
	inorder(root);
	return 0;
}
{% endhighlight %}
