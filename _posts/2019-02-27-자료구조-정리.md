---
title: "자료구조 정리"
date: 2019-02-27 15:10:30 -0400
categories: Data Structure
tags: Data Structure
---

# 자료구조 정리

### Stack
FILO (First-in-last-out) 자료구조
* 마지막에 들어간 데이터가 가장 처음 나온다

### Queue
FIFO (First-in-first-out) 자료구조
* 처음에 들어간 데이터가 가장 처음 나온다

### Circular Queue
Front와 Rear를 가진 Queue
* POP하면 Front가 +1 이 되고 PUSH를 하면 Rear가 +1 이 됨
* Rear는 마지막 데이터 바로 뒤에 위치하고, 만약 Rear == Front 라면 꽉찬 것

### Linked List
데이터의 앞 뒤가 서로 링크로 연결된 자료 구조
* 다음, 이전 데이터 접근 쉬움
* 임의의 데이터를 찾는데 O(N) 시간 걸림
* 데이터 삭제, 삽입이 빠름
  * 삭제, 삽입 시 해당 위치 좌우의 데이터의 링크만 잘 조정해주면됨

## Tree

### Binary Tree
루트 노드와, 그 루트 노드의 좌측, 우측 자식 노드로 구성된 트리
* Full Binary Tree : Binary Tree가 균형적이게 꽉찬 트리
* Complete Binary Tree : Full은 아니지만, Depth - 1까지는 Full이고, Depth는 좌측부터 시작해서 차례대로 차 있는 트리
* 배열이나, Link로 구현 가능

* Preorder Traversal (전위 순회)
  * 노드를 들리고 좌측 자식 -> 우측 자식 순으로 탐색
{% highlight c linenos=table %}
void preorder(treePointer ptr) {
  if(ptr) {
    printf("%d", ptr->data);
    preorder(ptr->leftChild);
    preorder(ptr->rightChild);
  }
}
{% endhighlight %}

* Inorder Traversal (중위 순회)
  * 좌측 자식이 없을 때까지 간 다음 들리고, 그 후 우측 자식 봄
{% highlight c linenos=table %}
void inorder(treePointer ptr) {
  if(ptr) {
    inorder(ptr->leftChild);
    printf("%d", ptr->data);
    inorder(ptr->rightChild);
  }
}
{% endhighlight %}

* Postorder Traversal (후위 순회)
  * 좌측 Subtree 그 다음 우측 Subtree 후 Root 방문
{% highlight c linenos=table %}
void postOrder(treePointer ptr) {
  if(ptr) {
    postOrder(ptr->leftChild);
    postOrder(ptr->rightChild);
    printf("%d", ptr->data);
  }
}
{% endhighlight %}

* Levelorder Traversal (레벨 순회)
  * Depth 순서대로 방문한다
{% highlight c linenos=table %}
Queue Q;
Q.push(1);
while(!Q.empty()) {
  visit(Q.front());
  Q.pop();
  Q.push(leftChild);
  Q.push(rightChild);
}
{% endhighlight %}

### Priority Queue (Max or Min Heap)
우선 순위가 높은 것 (값이 제일 크거나, 작거나 등) 부터 먼저 꺼내는 큐
{% highlight c++ linenos=table %}
void siftDown(vector<int>& arr, int idx) {
	int m = -1;
	if (arr.size() > idx * 2 + 1)
		m = arr[idx * 2] < arr[idx * 2 + 1] ? idx * 2 : idx * 2 + 1;
	else if (arr.size() > idx * 2)
		m = idx * 2;
	if (m != -1 && arr[idx] > arr[m]) {
		swap(arr[idx], arr[m]);
		siftDown(arr, m);
	}
}

void makeHeap(vector<int>& arr) {
	for (int i = arr.size() / 2; i >= 0; i--)
		siftDown(arr, i);
}

int pop(vector<int>& arr) {
	int top = arr[0];
	arr[0] = *(arr.end() - 1);
	arr.resize(arr.size() - 1);
	siftDown(arr, 0);
	return top;
}

vector<int> arr = { 2, 4, 5, 3, 1, 9, 6, 7, 10, 8 };
makeHeap(arr);
while (arr.size() > 0)
	printf("%d\n", pop(arr));
{% endhighlight %}

### Binary Search Tree
루트에서 작은 데이터는 좌측 큰 데이터는 우측으로 나눠서 데이터 관리
* 빠른 검색 가능

### Forest
트리를 여러개 가지는 자료구조

#### Disjoint Set
Union으로 두 집합을 묶을 수 있고, Find로 집합의 최상위 부모가 누구인지 찾는 자료 구조
* 집합의 결합이 매우 쉬움
{% highlight c++ linenos=table %}
int parent[100];

void Union(int a, int b) {
	parent[find(b)] = find(a);
}

int find(int idx) {
	if (parent[idx] == idx) return idx;
	return (parent[idx] = find(parent[idx]));
}

int main() {
	for (int i = 0; i < 100; i++)
		parent[i] = i;

	return 0;
}
{% endhighlight %}

## Graph
Vertex와 Vertex와 Vertex를 잇는 Edge로 구성된 자료 구조
* Directed Graph : Edge가 방향성을 가지는 자료 구조
* Complete Graph : 모든 Vertex가 연결되어 있을 경우
* Sub Graph : 어떤 Graph의 부분 집합
* in-degree : Vertex에 들어오는 Edge 수
* out-degree : Vertex에서 나가는 Edge 수
* Cyclic : 싸이클을 가지는 Graph
* Adjacency Matrix로 표현 가능

  |   | 1 | 2 | 3 | 4 |
  |---|---|---|---|---|
  | 1 | 0 | 1 | 1 | 1 |
  | 2 | 1 | 0 | 1 | 1 |
  | 3 | 1 | 1 | 0 | 1 |
  | 4 | 1 | 1 | 1 | 0 |

* Adjacency List로도 표현 가능

### Depth First Search
Stack을 이용해서 구현 가능
* 현재 Vertex에서 갈 수 있는 Vertex 중 하나를 Stack에 넣고 현재 Vertex 방문 표시
* Stack에서 Vertex를 꺼내서 위의 과정 반복 (방문 하지 않은 곳만 Stack에 넣음)
* 갈 수 있는 곳이 없으면 POP

### Breadth First Search
Queue를 이용해서 구현 가능
* 현재 Vertex에서 갈 수 있는 Vertex들 모두를 Queue에 넣음
* Queue에서 Vertex를 꺼내서 다시 갈 수 있는 Vertex들을 방문 하는 것을 반복

## Hashing
