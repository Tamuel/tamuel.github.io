---
title: "네트워크 정리"
date: 2019-03-01 18:16:30 -0400
categories: Networw
tags: Network
---
# 네트워크 정리

**Behrouz A. Forouzan "*TCP/IP Protocol Suite*" 참고**

# Introduction

## Brief History
네트워크란 커뮤니케이션 기기들의 그룹이라 볼 수 있고 Internet은 서로 커뮤니케이션 가능한 Network 들이라 볼 수 있음
![img01](/assets/images/markdown-img-paste-20190301183702843.png)

## Protocols and Standards
* Protocol(프로토콜) = Rule(규칙)
* Standards(표준) = 룰을 따르는 것


# The OSI Model and the TCP/IP Protocol Suite

## Protocol Layers
프로토콜은 두 개의 객체가 커뮤니케이션하는데 필요함 (서로 규칙이 맞아야 말이 통함), 만약 커뮤니케이션 방법이 어렵다면 각자 프로토콜을 가진 여러 레이어로 나눌 수 있음

* 커뮤니케이션이 간단할 경우
  ![img02](/assets/images/markdown-img-paste-20190301184122973.png)

* 어려울 경우
  ![img03](/assets/images/markdown-img-paste-20190301184158381.png)

## OSI Model
OSI(Open Systems Interconnection)이란 ISO(International Standards Organization)이 1970년대에 만든 네트워크 커뮤니케이션 표준

* OSI model을 이용한 데이터 교환
  * In-Capsulation : 데이터에 헤더를 붙여 패킷으로 만든 후 하위 레이어로 보냄
  * De-Capsulation : 데이터에서 헤더를 때면서 상위 레이어로 보냄
    ![img04](/assets/images/markdown-img-paste-20190301184825208.png)

* 물리 레이어(Physical Layer)는 각각의 bit를 하나의 노드에서 다른 노드로 옮겨줘야함

### OSI Layers 요약

|#|이름|주소|데이터단위|하는 일|
|-------|-----------|--|--|--|
|7|**Application**|Application Specific||네트워크 자원 접근 가능하게|
|6|Presentation|||데이터 해석, 암호화, 압축|
|5|Session||Message|Session 열기, 관리, 닫기|
|4|**Transport**|PORT (TCP/UDP) 2byte|Segment(TCP), User Datagram(UDP)|신뢰성 있는 **Process-to-Process** 메시지 전송과 에러 복구|
|3|**Network**|IP (Logical) 4byte(v4)/16byte(v6)|Datagram(패킷)|인터넷 작동을 위해 **패킷**을 목적지로 보냄|
|2|**Data Link**|Mac (Physical) 6byte|Frame|Hop-to-Hop 전송을 위해 비트들을 **프레임**으로 관리|
|1|**Physical**||Bit|**비트**를 매체(Medium)를 통해 전송, 기계적, 전자적 능력 필요|

## TCP/IP Protocol Suite
OSI 모델 보다 먼저 만들어짐

|Layer|Name|
|-------|-----------|
|Layer 5|Application|
|Layer 4|Transport|
|Layer 3|Network|
|Layer 2|Data Link|
|Layer 1|Physical|

### Physical Address
6byte 16진수 주소를 가짐
* eg) 07:01:02:01:2C:4B
* 라우터를 지나면서(Hop-to-Hop) Mac 주소는 바뀌지만 Logical 주소와 Port 주소는 바뀌지 않음
  ![img05](/assets/images/markdown-img-paste-20190301191253987.png)


# Underlying Technology (Layer 1, 2)
레이어 1, 2는 Access가 목적이고 3, 4, 5는 네트워킹이 목적임

## LAN (wired Local Area Networks)
제한된 범위 (가정, 회사) 내에서 사용하는 네트워크, 독립된(Isolated) 네트워크 구성 가능, 최근 LAN은 WAN(Wide Area Network)나 인터넷에 연결됨, 주로 Ethernet(이더넷) 사용
* 이더넷을 주로 사용하나, Token ring, Token bus, FDDI, ATM LAN 등도 존재

![img06](/assets/images/markdown-img-paste-20190301192155477.png)
![](/assets/images/markdown-img-paste-2019030121160800.png)
![](/assets/images/markdown-img-paste-20190301211637562.png)

* 이더넷 주소는 6bytes 사용
  ![](/assets/images/markdown-img-paste-20190301211743623.png)

* 첫 byte 마지막 자리가 0이면 유니캐스트 (1:1 통신), 1이면 멀티캐스트 (1:N 통신)
  ![](/assets/images/markdown-img-paste-20190301211818904.png)

* 모든 비트가 1 이면 브로드캐스트(Broadcast, 1:ALL)
  * FF:FF:FF:FF:FF:FF


## Wireless Lans
IEEE 802.11 무선랜 (무선 이더넷), 블루투스
![](/assets/images/markdown-img-paste-20190301212635452.png)

## Point-to-Point Wans
Point-to-Point Wide Area Network. WAN은 떨어져 있는 두 기기를 공공 네트워크 선(모뎀 등)으로 이어줌
* DSL, Cable 모뎀, T-line, SONET 등 있음

## Switched Wans
인터넷의 백본 네트워크는 스위치 WAN임. 넓은 영역을 커버하고 몇 포인트에 유저가 접근하는걸 제공해줌. 포트가 여러 개라 여러 입력과 출력을 낼 수 있음

## Connecting Devices
LAN과 WAN들은 보통 떨어져있지 않고 같이 연결되거나 인터넷에 연결되어 사용됨.
* Repeaters (HUB) : 자신에게 온 모든 데이터를 전달하고 (필터링 기능 없음) 증폭기 역할도 함
* Bridges (Two-layer switches) : 테이블이 있어 필터링 가능, 프레임의 물리 주소를 바꾸지 않음
  * Multi Port Bridge = Switch
* Routers (Three-layer switches) : 세개의 레이어(Network, Data Link, Physical)를 가진 기기
  * 라우터는 패킷의 물리 주소(MAC)를 바꿈
* Repeater와 Bridge는 LAN의 세그먼트를 연결해주고, 라우터는 LAN이나 WAN을 서로 연결해줌 (Internetwork)
  ![](/assets/images/markdown-img-paste-20190301213427609.png)


# Introduction to Network Layer

## Introduction
인터넷을 블랙박스라 생각하고, 여기서는 컴퓨터 두 대가 서로의 어플리케이션 레이어끼리의 메시지를 준다고 생각
![](/assets/images/markdown-img-paste-20190301214233753.png)

* 인터넷은 LAN들과 WAN들의 연결이라 생각하면 됨
  ![](/assets/images/markdown-img-paste-20190301214513291.png)


## Switching
만약 메시지가 길을 따라 가다가 연결기기(Connecting device)를 만나면 그 기기가 어디 출력 포트로 보낼지 선택을 해야함. 연결기기가 스위치로서 작동한다고 보면됨

### Circuit Switching
전체 메시지가 패킷으로 나누어지지 않고 출발지(Source)에서 목적지(Destination) 까지 전송됨
* 초기 전화 시스템 생각하면됨

### Packet Switching
메시지가 먼저 관리가 용이한 패킷들로 나뉜 다음 목적지로 전송됨. 목적지에 도착하면 다시 합쳐짐


## Packet Switching
네트워크 레이어(레이어3)은 패킷 스위치 네트워크로 디자인됨. 패킷들을 나눈다고 했는데, 이 패킷들을 **"데이터그램(Datagram)"** 이라 부름. 데이터그램은 목적지에 도착하면 다시 재조립됨. 과거에는 보통 Packet-switched network layer의 경우 Connectionless 서비스로 개발되었지만 최근에는 Conneection-oriented 서비스인 경우가 종종 있음

### Connectionless packet-switched network
  * UDP의 경우
  * 순서가 보존되지 않음 (따로 관리 안함)
  * 속도가 빠름
    ![](/assets/images/markdown-img-paste-20190301215658466.png)

  * Forwarding process in a Connectionless Network
    * Forwarding (포워딩) : 다음 HOP으로 전송하는 것
    * Routing (라우팅) : Ent-to-End 전송
    * 라우터에서 테이블 룩업 후 도착지 주소(Destination address)에 해당하는 인터페이스(포트)를 통해 전송
      ![](/assets/images/markdown-img-paste-20190301215836908.png)

  * Delay in a connectionless network
    * Delay variation(Jitter)이 있어 버퍼링을 함 (편차 상쇄)
      ![](/assets/images/markdown-img-paste-2019030122010750.png)

### Connection-oriented packet-switched network
  * TCP의 경우
  * 순서가 보존됨 (따로 순서와 전송 등을 관리하기 때문)
  * 속도가 UDP 보단 느림
    ![](/assets/images/markdown-img-paste-20190301220257969.png)

  * 포워딩이 도착지 주소가 아닌 패킷의 "라벨"에 따라 이루어짐
    ![](/assets/images/markdown-img-paste-2019030122052996.png)

  * Sending request packet in a virtual-circuit network
    * 마치 전선(길)이 있는 것 처럼 데이터 전송
    * Signaling으로 미리 가상의 길을 만든 후 전
      ![](/assets/images/markdown-img-paste-20190301220646146.png)

  * Delay in a connection-oriented network
    * Setup과 Teardown시 시간이 걸리긴 하지만 전송중 딜레이는 더 적음 (테이블 그때마다 찾아보지 않아도되기 때문)
      ![](/assets/images/markdown-img-paste-20190301221518441.png)

## Network Layer Services

### Services provided at the source computer
  ![](/assets/images/markdown-img-paste-20190301221846187.png)

### Processing at each router
  ![](/assets/images/markdown-img-paste-20190301222047571.png)

### Processing at the destination computer
  ![](/assets/images/markdown-img-paste-20190301222151906.png)


# IPv4 Addresses
IP(Network) 레이어에서 인터넷에 연결된 각 기기를 구분하기 위해 부르는 주소를 **IP주소** 라 한다.
IPv4 주소의 경우 32bit (4byte) 주소를 사용. 인터넷의 Host나 Router를 고유하게 구분하기 위해 사용.
IP 주소는 인터페이스의 주소임

* 32bit 이므로 $2^{32}$개의 주소를 가질 수 있음
* 10진수 사용 eg) 255.124.0.125.

## Classful Addressing
처음 IPv4를 만들 때는 클래스라는 컨셉을 썻음. 1990년대 중반부터 Classless 사용.

![](/assets/images/markdown-img-paste-2019030122333730.png)

* NetID, HostID
  * Netid는 할당해주고 Hostid는 할당 받은 기관이 마음대로 사용
  * A, B 클래스는 너무 많이 낭비됨
  * C 클래스는 너무 적음
  * D 클래스는 통신 할 때만 사용
  * IPv4는 거의 다 할당 됨
    ![](/assets/images/markdown-img-paste-20190301223502121.png)

* 샘플 인터넷
  ![](/assets/images/markdown-img-paste-20190301223819433.png)

* Network address (NetID)는 네트워크의 구분자(Identifier)
  * 라우팅 테이블에 모든 주소가 있는 것이 아니라 NetID들이 있음
    ![](/assets/images/markdown-img-paste-2019030122394633.png)

* Subnetwork mask
  * NetID, SubnetID, HostID로도 구분 가능 (서브넷은 적절히 크기 정함)
    ![](/assets/images/markdown-img-paste-2019030214495810.png)

* Supernet mask도 존재

## Classless Addressing
서브넷, 슈퍼넷을 통해서도 주소 고갈문제를 해결 할 수는 없음. IPv6로 많은 주소 제공도 있지만, 그 전에 같은 주소 공간을 쓰지만 분포를 다르게 해서 각 기관이 공평하게 쓰는 방법이 있고 이를 IPv4를 이용한 **Classless addressing** 방법이라함

* Classless Addressing에서는 접두사(Prefix)는 네트워크를 정의하고, 집미사(Suffix)는 호스트를 정의
  * 접두사는 1에서 32비트까지 쓰임
    ![](/assets/images/markdown-img-paste-20190302145651802.png)

* Classless는 어디까지가 NetworkID인지 따로 알려줘야함
  * 아래에서 n이 접두사의 길이를 뜻함
    * byte.byte.byte.byte/n

* Subnet 잘못 지정시 다른 주소의 NetworkID와 겹침

## Special Addresses
* 0.0.0.0 : 주소를 모를 때 (DHCP에서 처음에 주소를 얻어올 때)
* 255.255.255.255 : Broadcast 주소 (모든 네트워크)
  * 라우터는 Broadcast가 목적지인 패킷을 막음 (해당 라우터 이내에서만 가도록)
* 127.x.y.z : 컴퓨터 내부 프로세스 간 통신 (밖으로 나가지 않음)
* 개인용 네트워크 (공유기)

  |Block|Number of addresses|
  |:----:|:----:|
  |10.0.0.0/8|16,777,216|
  |172.16.0.0./12|1,047,584|
  |192.168.0.0./16|65,536|
  |169.254.0.0./16|65,536|

* Directed Broadcast
  * 네트워크가 221.45.71.0/24 일 경우 라우터에서 221.45.71.255/24(HostID 비트가 모두 1)로 패킷을 보내면 해당 네트워크로 브로드캐스팅함

## NAT
NAT (Network Addres Translation), 공유기라고 생각하면됨 Public 주소 패킷을 받아 Translation Table을 보고 Private 주소로 변환해서 넘겨줌
![](/assets/images/markdown-img-paste-20190302161626536.png)
![](/assets/images/markdown-img-paste-2019030216171290.png)

# Delivery and Forwarding of IP Packets

## Delivery
네트워크 레이어는 패킷 전송을 담당해야함. 목적지까지 패킷을 전송하는 방법은 크게 **Direct** 와 **Indirect** 두 방법이 있음

### Direct Delivery
한 네트워크 안에서 패킷 전송 (네트워크 내의 기기끼리 혹은 네트워크 담당 라우터에서 기기까지)
![](/assets/images/markdown-img-paste-20190302162450901.png)

### Indirect Delivery
라우터를 거치면서 패킷 전송
![](/assets/images/markdown-img-paste-2019030216233979.png)


## Forwarding
라우터 내의 패킷을 패킷의 목적지로 보내는 것 (Deliver to the next Hop)
* Route를 모두 보거나 (Full route), 다음 Hop 만 봄, IP Router는 Next HOP 만 봄
  ![](/assets/images/markdown-img-paste-20190302162726729.png)

### Network-specific routing
  * 네트워크 단위로 보기 때문에 좀 더 간소함
    ![](/assets/images/markdown-img-paste-20190302162903672.png)

### Host-specific routing
  * DNS 같은 경우 예외로 Host specific 쓰기도 함
    ![](/assets/images/markdown-img-paste-20190302163027895.png)

### Default routing
  * 테이블에 따로 명시되지 않은 Route는 Default로 감
  * 보통 PC는 Default 만 가지기도 함
    ![](/assets/images/markdown-img-paste-20190302163307324.png)

### Classful Addressing에서 Routing
* Net
  ![](/assets/images/markdown-img-paste-2019030216344187.png)
* Subnet
  ![](/assets/images/markdown-img-paste-20190302163525278.png)
* 위에서 Interface Number는 라우터 슬롯의 맥주소임
* Classful Addressing에서는 3열로 테이블 표현 가능하지만 Classless일 경우 Prefix까지 합쳐 4열로 표현
  ![](/assets/images/markdown-img-paste-20190302163753157.png)

### Longest mask matching
테이블에서 중복되는 주소가 있을 시 가장 길게 매칭되는 쪽으로 감
  ![](/assets/images/markdown-img-paste-20190302164531537.png)

* Hierarchical routing with ISPs
  * 계층적 구조를 가지고 라우팅 가능
* 목적지 주소로 라우팅
* 라벨을 기반으로 라우팅

## Structure of A Router (라우터 구조)
* Router Components
  ![](/assets/images/markdown-img-paste-20190302164944261.png)
* Input Port
  ![](/assets/images/markdown-img-paste-20190302165020261.png)
* Output Port
  ![](/assets/images/markdown-img-paste-20190302165043913.png)
* Banyan switch
  ![](/assets/images/markdown-img-paste-20190302165202806.png)
* Batcher-banyan switch
  ![](/assets/images/markdown-img-paste-20190302165225207.png)



# IPv4 (Internet Protocol Version 4)

## Introduction
Internet Protocol은 네트워크 레이어에서 TCP/IP 프로토콜이 사용하는 전송 매커니즘
![](/assets/images/markdown-img-paste-20190302165646358.png)

## Datagrams
네트워크 레이어의 패킷을 **Datagram** 이라고 함. "**헤더**"와 "**데이터**"로 이루어져 있음
* 헤더 : 20 ~ 60 byte로 라우팅과 전송에 필요한 필수 정보를 가짐

### IP Datagram 헤더 구조
![](/assets/images/markdown-img-paste-2019030217005508.png)

|이름|역할|
|----|----|
|VER|버전, IPv4일 경우 0100|
|HLEN|헤더 길이, 단위는 word(4byte), 최소 5이상 (20byte)이상 이어야 정상, 아니면 무시|
|Service type|Real Time, Reliable 등의 패킷 타입 명시 (요즘은 사용 안함), 앞의 6비트만 사용, XXXXX0는 인터넷, XXXX11은 로컬, XXXX01은 임시 혹은 실험용|
|Total length|헤더+데이터 총 길이, 단위는 byte|
|Identification|패킷 ID, Fragmentation 후에도 같은 패킷인지 인식 위해|
Fragmentation offset|byte/8, 시작 지점으로 부터 얼마나 떨어져 있는지, 175의 경우 시작이 1400byte라는 말|
|Flags|3bit는 [0DM]으로 볼 수 있음, D는 Fragment하면 안됨, M은 Fragment가 더 있음을 의미, 001의 경우 뒤에 패킷이 더 있다는 의미|
|Time to live (TTL)|Hop Count라고도 하며 몇 HOP갈 것인지, 보통 255,128,64|
|Protocol|TCP(6), UDP(17) 기타 등등|
|Header checksum|헤더의 Corruption체크 (정보 손상이 있는지)|
|Source IP address|송신지 주소 (4byte)|
|Destination IP address|수신지 주소 (4byte)|
|Options+Padding|기타|

### Encapsulation of a small datagram in an Ethernet frame
![](/assets/images/markdown-img-paste-20190302171300892.png)

### Multiplexing
* ICMP (1) : Internet Control Message Protocol
* IGMP (2) : Internet Group Management Protocol (Multicast)
* TCP (6) : Transmission Control Protocol
* UDP (17) : User Datagram Protocol
* OSPF (89) : Open Shortest Path First Routing Protocol
![](/assets/images/markdown-img-paste-20190302171359627.png)

## Fragmentation
패킷을 나눔

### MTU (Maximum Transfer Unit)
망에서 지원하는 최대 패킷 사이즈
* Datagram이 왔을 경우 MTU로 사이즈로 나눠서(Fragmentation) 전송
* 오직 data만 나눔 (헤더를 나눌수는 없음)

### Fragmentation 예제
![](/assets/images/markdown-img-paste-20190302173136294.png)

## Options
헤더 20byte는 앞의 기본 헤더이고 + 40byte까지 옵션을 설정 가능. 네트워크 테스팅과 디버깅시 사용. 헤더에 꼭 필요하진 않음
* TLV 포맷
![](/assets/images/markdown-img-paste-20190302174804445.png)
![](/assets/images/markdown-img-paste-20190302174847884.png)

|Operation|설명|
|---|---|
|No operation|Padding 용 (4의 배수 byte로 끝나게)|
|End of option|옵션 끝 알림|
|Record route|루트 기억 (총 9개)|
|Strict source route|수신자가 루트를 정해주고, 갈 수 없다면 버림|
|Loose source route|수신자가 루트를 정해주고 웬만하면 따라가게함|
|Timestamp|보낸 시간|

## Checksum
TCP/IP 프로토콜에서 에러 검출 방법을 Checksum이라함. 전송 중 패킷 손상을 방지함. 수신자가 헤더에 대해서 계산을 해서 결과가 만족되면 패킷을 받아들임
* Checksum은 헤더만을 관리하고, Data는 하지 않음 (TCP가 관리)
![](/assets/images/markdown-img-paste-20190302175547556.png)
* 1의 보수 방법
![](/assets/images/markdown-img-paste-2019030217560283.png)

## IP Components
![](/assets/images/markdown-img-paste-20190302175900108.png)


# ARP (Address Resolution Protocol)
주소를 알아오는 프로토콜

## Address Mapping
논리적(Logical), 물리적(Physical) 주소들 끼리 맵핑이 필요함. 정적(Static) 맵핑과 동적(Dynamic) 맵핑 존재. IP 데이터그램에는 목적지의 논리적 주소만 존재함. 하지만 데이터그램은 물리적 네트워크를 통과하기 위해 Encapsulation을 통해 프레임으로 변환되어야 함. 그 말인즉 송신자가 수신자의 물리 주소를 알아야한다는 말. **ARP** 는 IP 프로토콜로 부터 논리 주소를 받고 해당 주소를 물리 주소와 맵핑한 다음 데이터 링크 레이어로 보냄
![](/assets/images/markdown-img-paste-20190302180504154.png)

### ARP Operation
Subnet안에서 브로드캐스트로 ARP Request를 보내면 해당하는 기기에서 물리주소를 채워넣은 다음 다시 보낸 기기로 유니캐스트로 돌려보냄
![](/assets/images/markdown-img-paste-20190302180600914.png)
![](/assets/images/markdown-img-paste-20190302180608362.png)

### ARP Packet
![](/assets/images/markdown-img-paste-20190302180753324.png)

### ARP Packet Encapsulation
![](/assets/images/markdown-img-paste-20190302180852195.png)

### 4가지 케이스
1. 같은 네트워크 상에서 한 호스트가 다른 호스트로 패킷 보낼 경우
  * 타겟 주소는 IP 데이터그램의 목적지 주소
2. 호스트가 다른 네트워크의 호스트로 패킷을 보낼 경우
  * 타겟 주소는 라우터의 IP 주소
3. 라우터가 다른 네트워크의 호스트로 패킷을 보낼 경우
  * 타겟 주소는 다른 라우터의 IP 주소
4. 라우터가 같은 네트워크의 호스트에게 패킷을 보낼 경우
  * 타겟 주소는 IP 데이터그램의 목적지 주소


## ARP Package
![](/assets/images/markdown-img-paste-2019030218153037.png)


# ICMPv4 (Internet Control Message Protocol version 4)
IP의 컨트롤을 보완. IP 프로토콜은 기본적으로 에러 보고나, 에러를 보정하는 매커니즘이 없음.
![](/assets/images/markdown-img-paste-20190302182107708.png)

### ICMP Encapsulation
![](/assets/images/markdown-img-paste-20190302182153337.png)

## Messages
크게 **에러 보고 메시지 (Error-reporting messages)** 와 **쿼리 메시지 (Query messages)** 로 나눌 수 있음. 에러는 목적지를 가기전 라우터나 목적지 호스트가 IP 패킷을 처리하는데 문제가 발생했을 경우 전송. 쿼리 메시지는 호스트나 네트워크 관리자가 다른 라우터나 호스트의 정보를 얻기 위해 사용
* ICMP는 항상 송신자(Original source)에게 에러 메시지를 보고함

### ICMP Messages

|Category|Type|Message|
|---|:--:|:--|
|에러 보고 메시지|3|Destination unreachable, 목적지 도달 불가|
|^|4|Source quench, 송신자에게 그만 전송하라고 연락 (목적지 호스트가 너무 혼잡할 때), 데이터그램 하나마다 메시지 하나씩 전송|
|^|11|Time exceeded, 시간 초과, 라우터가 TTL 값을 0으로 줄이면 소스에 메시지 전송, 수신자가 시간 안에 Fragment들을 다 받지 못하면 메시지 전송|
|^|12|Parameter problem, 헤더 문제 (원인도 함께 보내줌)|
|^|5|Redirection, 호스트와 같은 네트워크 내의 라우터가 다른 라우터로 보낸다고 연락, 호스트 라우팅 테이블 업데이트 시 사용 가능|
|쿼리 메시지|8 or 0|Echo request or reply, Ping 보냄, Echo Request 받은 호스트나 라우터는 Echo Reply 메시지를 다시 보냄|
|^|13 or 14|Timestamp request or reply, 걸린 시간 측정, 두 기기 사이의 시간 동기화 시 사용 가능|

### ICMP Message Format
![](/assets/images/markdown-img-paste-20190302184631328.png)

## Debugging Tools
* PING : Echo request and reply
* Traceroute : HOP 순서 알아볼 수 있음

## ICMP Package
![](/assets/images/markdown-img-paste-2019030219014035.png)


# Mobile IP

## Addressing

### Stationary Host (고정된 호스트)
IP 주소는 기본적으로 고정된 호스트를 가정하고 디자인됨. 주소의 일부는 어디 네트워크에 어떤 호스트가 붙은지 나타내기 때문

### Home address and Care-of address
모바일 IP는 영구적인 Home address와 호스트에 따라 바뀔 수 있는 Care-of address 둘 다 가짐

## Agents
모바일 호스트와 Foreign 에이전트가 같다면 Care-of 주소를 Colocated care-of 주소로 불림
![](/assets/images/markdown-img-paste-20190302190531657.png)

## Three Phases
원격 호스트와 커뮤니케이션을 위해 모바일 호스트는 : **에이전트 발견 (Agent discovery)**, **등록 (Registration)**, **데이터 전송 (Data transfer)** 세 단계를 거친다.
* 모바일 호스트가 이동더라도 나머지 인터넷에 무관함 (Transparent)

### Agent Discovery
에이전트가 어디 있는지 파악
* ICMP 쿼리 메시지의 Router advertisement, Router solicitation 메시지 사용
* Agent solicitation : 에이전트가 어디있는지?
* Agent advertisement : 에이전트 응답

### Registration
Care-of 주소를 Home 에이전트에게 알려줌
* UDP well-known 434포트를 이용해 전송
* Registration request : Home 에이전트에 등록 요청
* Registration reply : Home 에이전트에 등록

### Data Transfer
데이터 전송

![](/assets/images/markdown-img-paste-20190302191036922.png)
![](/assets/images/markdown-img-paste-20190302191757124.png)

## Inefficiency in Mobile IP
더블 크로싱 (Double crossing) 이라는 심각한 문제와, 삼각 라우팅 (Triangle routing) 이라는 덜 문제가 있음

### Double Crossing
같은 네트워크 안인데 먼길을 거쳐와야 함
![](/assets/images/markdown-img-paste-20190302192120368.png)

### Triangle Routing
꼭 홈 에이전트를 거쳐와야 함
![](/assets/images/markdown-img-paste-20190302192201729.png)


# Unicast Routing Protocols

## Inter and Intra Domain Routing
인터넷이 너무 크기 때문에 라우팅 프로토콜이 모든 라우터의 테이블을 관리하기는 힘들어 **AS**(Autonomous system)들로 인터넷이 나누어짐. AS는 하나의 기관이 운영하는 네트워크나 라우터의 그룹. AS 안의 라우팅을 **Intra-domain** 라우팅이라 하고, AS끼리의 라우팅을 **Inter-domain** 라우팅이라 함 (AS를 Domain이라 볼 수 있음)
![](/assets/images/markdown-img-paste-20190302192754890.png)

## 라우팅 프로토콜들
가장 짧은 길을 알기 위한 프로토콜들
![](/assets/images/markdown-img-paste-20190302192856184.png)

### RIP (Routing Information Protocol)
[베르만포드 알고리즘](https://tamuel.github.io/algorithm/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%A0%95%EB%A6%AC/#) 사용, 인접한 곳만 알면 됨
* Intra-domain 용
* Distance vector routing = 베르만포드 사용
* UDP well-known 520 포트 사용
* 3개의 타이머 사용

|Timer|하는일|
|--|--|
|Periodic|주고 받는 간격|
|Expiration|유효 기간|
|Garbage collectipn|에러|

### OSPF (Open Shortest Path First)
[다익스트라](https://tamuel.github.io/algorithm/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%A0%95%EB%A6%AC/#) 사용, 망을 다 알 경우
* Intra-domain 용
* Link state routing = 다익스트라 사용
* OSPF 패킷은 IP 데이터그램에 Encapsulation됨 (Multicast)
* Link 종류
  붉은색은 라우터, 푸른색은 이더넷
  * Point-to-Point
    ![](/assets/images/markdown-img-paste-20190302194833622.png)
  * Transient
    ![](/assets/images/markdown-img-paste-20190302194852822.png)
  * Stub
    ![](/assets/images/markdown-img-paste-20190302194907486.png)
  * Virtual

### Path Vector Routing
Distance vector 라우팅은 Hop이 많으면 불안정하고 Link state 라우팅은 Hop이 많으면 자원소모가 너무 심함. Reachability를 고려하기 위해 라우팅 테이블을 합쳐줌
![](/assets/images/markdown-img-paste-20190302195812345.png)
![](/assets/images/markdown-img-paste-20190302195940367.png)

### BGP (Border Gateway Protocol)
Path Vector Routing을 이용하여 AS 사이에 라우팅을 담당한다
* TCP 179 포트 사용 (신뢰성 보장)
* E-BGP : AS와 AS간 BGP 라우팅
* I-BGP : AS내에서 BGP 정보 교환

### CIDR (Classless Inter-Domain Routing)

# Multicasting and Multicast Routing Protocols

## Unicasting
1:1 통신, 하나의 호스트에서 다른 하나의 호스트로 패킷 전송
* 라우터는 받은 데이터그램을 하나의 인터페이스로만 전송

## Multicasting
1:N 통신, 가입 필요, Class D
* 라우터는 받은 데이터그램을 여러개의 인터페이스로 전송

## Multicasting vs. Multiple unicasting
멀티캐스팅은 동시에 패킷을 전송하지만, 유니캐스트는 패킷을 복제한 후 뿌려줌
* 멀티캐스트 - 딜레이가 비슷함 (실시간 방송 등)
* 유니캐스트 - 딜레이가 다름
![](/assets/images/markdown-img-paste-20190302201734671.png)

## Multicast Addresses
멀티캐스트 주소란, 멀티캐스트 그룹에 포함된 호스트들의 주소를 뜻한다

|CIDR|Range|Assignment|
|--|--|--|
|224.0.0.0/24|224.0.0.0 ~ 224.0.0.255|Local Network Control Block|
|224.0.1.0/24|224.0.1.0 ~ 224.0.1.255|Internetwork Control Block|
||224.0.2.0 ~ 224.0.255.255|AD HOC Block|
|224.1.0.0/16|224.1.0.0 ~ 224.1.255.255| ST(Stream) Multicast Group Block|
|224.2.0.0/16|224.2.0.0 ~ 224.2.255.255|SDP/SAP Block|
||224.3.0.0 ~ 231.255.255.255|Reserved|
|232.0.0.0/8|232.0.0.0 ~ 232.255.255.255|Source Specific Multicast(SSM)|
|233.0.0.0/8|233.0.0.0 ~ 233.255.255.255|GLOP Block|
||234.0.0.0 ~ 238.255.255.255|Reserved|
|239.0.0.0/8|239.0.0.0 ~ 239.255.255.255|Administratively Scoped Block|

### Local Network Control Block

|Address|Assignment|
|--|--|
|224.0.0.0|Base address (reserved)|
|224.0.0.1|All systems (호스트나 라우터들) on this network|
|224.0.0.2|All routers on this network|
|224.0.0.4|DMVRP routers|
|224.0.0.5|OSPF routers|
|224.0.0.7|ST (Stream) routers|
|224.0.0.8|ST hosts|
|224.0.0.9|RIP2 routers|
|224.0.0.10|IGRP routers|
|224.0.0.11|Mobile Agents|
|224.0.0.12|DHCP servers|
|224.0.0.13|PIM routers|
|224.0.0.14|RSVP encapsulation|
|224.0.0.15|CBT routers|
|224.0.0.22|IGMPv3|

### Mapping Class D to Physical address
이더넷 멀티캐스트 물리 주소는 01:00:5E:00:00:00 ~ 01:00:5E:7F:FF:FF 까지임
* 01:00:5E는 기관명 (정해져 있음)
* 7F인 이유는 23비트 사용하기 때문
![](/assets/images/markdown-img-paste-20190302203415885.png)

### Tunneling
멀티캐스트 전송중 멀티캐스트 지원이 안되면 앞에 헤더를 붙여 유니캐스트로 변환해서 전송
![](/assets/images/markdown-img-paste-2019030220361592.png)


## IGMP (Internet Group Management Protocol)
멀티캐스트 통신은 멀티캐스트 그룹에 포함된 호스트에 패킷을 전송하는 것이므로 멀티캐스트 라우터는 로얄(Loyal) 멤버가 어디 인터페이스에 연결되어 있는지 알아야함. 이를 위해 지역적(Locally)으로는 **IGMP 프로토콜** 을 사용하고, 전역적(Globally)이게는 **Multicast Routing Protocol** 사용
* IGMP는 멀티캐스트 라우터가 각 인터페이스에 연관된 로얄 멤버에 대해서 리스트를 만들고 업데이트하는 것을 도와줌
![](/assets/images/markdown-img-paste-20190302203915893.png)

### IGMP Messages
라우터와 호스트간 메시지
* 소캣 레코드 중 하나라도 바뀐다면 인터페이스 상태(State)도 바뀜
![](/assets/images/markdown-img-paste-20190302204259261.png)
* Membership query : 라우터에서 호스트로
![](/assets/images/markdown-img-paste-20190302204530686.png)
* Membership report : 호스트에서 라우터로 (있다고만 보고), 리포트가 먼저 갈 수도 있음
![](/assets/images/markdown-img-paste-20190302204714614.png)

### Socket State
![](/assets/images/markdown-img-paste-20190302205906508.png)

### Sending change state report
![](/assets/images/markdown-img-paste-20190302210943189.png)

### Interface State
226.14.5.2에서 Exclude = {a, b, c}, {b, c, g}, Include = {a, b, d, e} 이므로, Exclude - Include = {c}. 228.24.21.4에서 Include = {b, c, f}, {d, e, f} 이므로  Include = {b, c, d, e, f}
* 226.14.5.2 마지막이 Exclude 이므로 Exclude 필터
* 228.24.21.4 마지막이 Include 이므로 Include 필터
![](/assets/images/markdown-img-paste-20190302205154302.png)

### Router State
![](/assets/images/markdown-img-paste-20190302205348606.png)

## Multicast Routing
Optimal Routing: Shortest Path Trees
* 멀티캐스트 라우팅에서 라우터는 각 그룹에 대한 최단 거리 트리를 만들어야함
![](/assets/images/markdown-img-paste-20190302211332846.png)

### Source-based Tree Approach
각 라우터가 각 그룹에 대해 하나씩 최단 거리 트리를 가져야함
  * Membership이 바뀌거나 Session이 끝날 때마다 계속 바뀜

![](/assets/images/markdown-img-paste-20190302211644357.png)

### Group-shared Tree Approach
각 그룹의 최단 거리 트리를 가진 코어 라우터가 멀티캐스팅에 참여
  * 소스 상관없이 일단 Core로 다 모음

![](/assets/images/markdown-img-paste-20190302211919870.png)

## Routing Protocols
Tree 구성이 목적인 프로토콜
* MOSPF : Multicast Extesion to [OSPF](#ospf-open-shortest-path-first)
* DVMRP : Distance Vector Muiticast Routing Protocol [RIP](#rip-routing-information-protocol)와 유사
* PIM : Protocol Independent Multicast
  * DM : Dense Mode
  * SM : Sparse Mode
* CBT : Core Base Tree

![](/assets/images/markdown-img-paste-20190302222836616.png)

### RPF, RPB, RPM
* RPF : Reverse Path Forwading, Flooding process에서 루프를 없앰
  * 하지만 목적지에서 동일한 패킷 여러개를 받을 수도 있음
* RPB : Reverse Path Broadcasting, 소스에서 각 목적지까지 Shortest path broadcast tree 만듬
  * 목적지마다 하나의 패킷만 받게 해줌
* RPM : Reverse Path Multicasting, RPB에 가지치기(Pruning)과 접붙이기(Grafting) 추가
  * Dynamic membership change를 제공해줌
* 간단한 순서
  1. 우선 소스에서 브로드캐스팅
  2. 아랫단에서 판단 (RPF)
  3. Pruning
![](/assets/images/markdown-img-paste-20190302224218312.png)

### Group-shared tree with rendezvous router
소스 상관없이 Tree 공유 (랑데뷰 혹은 코어 라우터라고 함)
![](/assets/images/markdown-img-paste-2019030222514539.png)

#### CBT의 경우
소스가 멀티캐스트 패킷(유니캐스트 패킷으로 터널링된)을 코어 라우터로 보내면 코어 라우터가 패킷을 Decapsulate한 다음 알맞은 인터페이스로 뿌려줌

#### PIM-DM
RPF + [Pruning, Grafting] 사용, LAN 같은 Dense 멀티캐스트 환경에서 사용
* 유니캐스트 프로토콜에서 독립적

#### PIM-SM
WAN 같은 Sparse 멀티캐스트 환경에서 사용
* CBT와 유사하지만 더 간단함

## MBONE
멀티캐스트 라우터를 쓰지 않고, 유니캐스트 라우터 사이에 논리적 터널을 만듬


# Introduction to Transport Layer
* **UDP** : User Datagram Protocol
* **TCP** : Transmission Control Protocol
* **SCTP** : TCP 개선 (TCP 장점 + UDP 장점)
* **DCCP** : Datagram Congestion Control Protocol (UDP + Congestion control)
![](/assets/images/markdown-img-paste-20190302230035604.png)

## Process-to-Process Communications
* Network 레이어 : Host-to-Host (IP)
* Transport 레이어 : Process-to-Process (IP + Port)
* 소캣 주소 = IP 주소 + Port
* IP 주소 : Host 선택
* Port 번호 : Process 선택

## Port
16비트로 이루어짐 0 ~ 65535
* Well-known : 0 ~ 1023
* Registered : 1024 ~ 49151
* Dynamic or Private : 49152 ~ 65536


# UDP(User Datagram Protocol)
Application 프로그램과 Network 레이어 사이에서 데이터 전송

## User Datagram
UDP 패킷을 User Datagram이라 함. 헤더는 8 byte
![](/assets/images/markdown-img-paste-20190302231152547.png)

## UDP Service

### UDP에서 Well-known

|Port|Protocol|Description|
|:--:|--|--|
|7|Echo|Echoes a received datagram back to the sender|
|9|Discard|Discards any datagram that is received|
|11|Users|Active users|
|13|Daytime|Returns the date and the time|
|17|Quote|Returns a quote of the day|
|19|Chargen|Returns a string of characters|
|53|Nameserver|Domain Name Servcie|
|67|Bootps|Server port to download bootstrap information|
|68|Bootpc|Client port to download bootstrap information|
|69|TFTP|Trivial File Transfer Protocol|
|111|RPC|Remote Procedure Call|
|123|NTP|Network Time Protocol|
|161|SNMP|Simple Network Management Protocol|
|162|SNMP|Simple Network Management Protocol(Trap)|

### Simple Checksum 계산
![](/assets/images/markdown-img-paste-20190302231626230.png)

### Encapsulation / Decapsulation
![](/assets/images/markdown-img-paste-20190302231727733.png)

### Queues in UDP
각 포트마다 큐를 가짐
![](/assets/images/markdown-img-paste-20190302231757172.png)

### Multiplexing / Demultiplexing
![](/assets/images/markdown-img-paste-20190302231848981.png)

## UDP Application
* DNS : 클라이언트가 짧은 요청을 보내고 빨리 응답을 받아야 하기 때문
* SMTP 같이 큰 데이터가 있는 패킷을 UDP로 보낼 수는 없음, 받을 때 순서가 고려되지 않고 중간에 손실 가능하기 때문

## UDP Package
![](/assets/images/markdown-img-paste-20190302232325349.png)

### Control Block Table

|State|Process ID|Port Number|Queue Number|
|--|:--:|:--:|:--:|
|IN-USE|2345|52010|34|
|IN-USE|3422|52011||
|FREE||||
|IN-USE|4652|52012|38|
|FREE||||


# TCP (Transmission Control Protocol)

## TCP Services
### Well-known Port TCP

|Port|Protocol|Description|
|:--:|--|--|
|7|Echo|Echoes a received datagram back to the sender|
|9|Discard|Discards any datagram that is received|
|11|Users|Active users|
|13|Daytime|Returns the date and the time|
|17|Quote|Returns a quote of the day|
|19|Chargen|Returns a string of characters|
|20 and 21|FTP|File Transfer Protocol (Data and Control)|
|23|TELNET|Terminal Network|
|25|SMTP|Simple Mail Transfer Protocol|
|53|DNS|Domain Name Server|
|67|BOOTP|Bootstrap Protocol|
|79|Finger|Finger|
|80|HTTP|Hypertext Transfer Protocol|

### Stream delivery
byte의 흐름이라 생각하면됨
![](/assets/images/markdown-img-paste-20190302232949463.png)

### Sending and Receiving Buffers
Circular Linked List Queue로 버퍼 생성
* 송신자는 수신자가 제대로 받았는지 확인하고 보내기위해 버퍼 사용
* 수신자는 스트림을 계속해서 순서대로 받기 위해 버퍼 사용

![](/assets/images/markdown-img-paste-20190302233028210.png)

### TCP Segment
보통 1024byte로 나눔 (Segmentation)
![](/assets/images/markdown-img-paste-20190302233201617.png)


## TCP Features

### Numbering System
각 연결에서 보내려는 데이터의 byte는 TCP에 의해 번호가 매겨짐, 시퀀스 넘버 (Sequence number)는 현재 세그먼트에 들어있는 첫 byte의 숫자라 생각하면됨
* 각 넘버링은 임의의 수로 시작됨, 패킷 Down 됐을 경우 이전것인지 최근 것인지 헷갈릴 수 있기 때문
* 5000byte 파일을 전송하고 시작 번호가 10001이고 Segment가 각각 1000byte일 경우 시퀀스 넘버는 10001, 11001, 12001, 13001, 14001 임
* Acknowledgment number필드의 값은 수신자가 받기를 원하는 다음 byte (Ack num이 10001이라면 10000까지는 받았다는 말), Acknowledgment number는 누적됨

## Segment
TCP의 패킷을 세그먼트라고 함

![](/assets/images/markdown-img-paste-2019030223403345.png)

|Field|사이즈|의미|
|--|:-:|--|
|Source port address|16bits|송신자 포트 번호|
|Destination port address|16bits|수신자 포트 번호|
|Sequence number|32bits|Segment의 첫 byte 번호 (시작 번호 만큼 Offset 가짐)|
|Acknowledgment number|32bits|송신자가 보낸 것 중 Ack - 1byte까지는 받았다고 수신자가 보냄|
|HLEN|4bits|헤더 길이 word(4byte)단위|
|Reserved|6bits||
|URG|1bit|Urgent, 바로 Application단에 올려야함, Urgent pointer가 있음|
|ACK|1bit|Ack 확인 필요|
|PSH|1bit|Push, 더 받을 패킷이 없으니 Application 단으로 패킷을 올려라|
|RST|1bit|Reset, 접속 Reset|
|SYN|1bit|Sync, Sync 패킷 (가장 처음 패킷), Sequence number 동기화|
|FIN|1bit|Finish, 마지막 패킷, 접속 종료|
|Window size|16bits|수신자가 이용 가능한 버퍼 사이즈, ~65535까지 가짐|
|**Checksum**|16bits|오류 났을 시 복구를 위해, UDP와 마찬가지로 IP헤더까지 같이 Checksum, **TCP에서는 필수**|
|Urgent pointer|16bits|데이터 중 몇 번째 위치가 Argent 인지|
|Options and padding|~40bytes|옵션|

### Control Field (혹은 Flags)
URG, ACK, PSH, RST, SYN, FIN

### Pseudoheader
![](/assets/images/markdown-img-paste-20190302235153563.png)

## TCP Connection
TCP는 **연결 지향 (Connection-oriented)** 특징을 가짐. TCP는 송수신자 사이에 가상의 길(Path)를 만듬. 그 후 세그먼트 들이 가상의 길을 통해서 전송됨. IP가 비연결(Conetionless)이므로 TCP는 자기 스스로 연결을 제어함. 예를 들어 세그먼트가 없어지거나 잘못되는 경우 다시 전송함

### Connection Establishment (접속)
Three-way handshake를 통해 연결을 함
* rwnd는 Receiver Window Size
* SYN 세그먼트는 데이터가 없으면 Sequence number 하나 소모
* SYN + ACK도 마찬가지
* ACK 세그먼트는 데이터가 없으면 Sequence number 소모하지 않음

![](/assets/images/markdown-img-paste-20190303022327455.png)

### Data Transfer (데이터 전송)
![](/assets/images/markdown-img-paste-2019030302300842.png)

### Connection Termination (접속 해제)
Three-way handshake를 통해 연결 해제
* FIN 세그먼트는 데이터가 없으면 Sequence number 하나 소모
* FIN + ACK도 마찬가지
* 클라이언트에서 서버로 보내는 마지막 ACK는 Kernel 단에서 보내는 것, Connection closed에서 이미 Application 단의 연결은 끊김
![](/assets/images/markdown-img-paste-20190303025406424.png)

### Half-close (Four-way Handshaking)
나머지 패킷을 다 보내고 (소용은 없지만) 그 후 커널 단에서 접속 해제
* 만약 Reset 패킷을 받으면 바로 끝냄

![](/assets/images/markdown-img-paste-20190303025456457.png)

### State Transition Diagram
마지막 TIME_WAIT는 ACK가 없어질까봐 기다리는 것
![](/assets/images/markdown-img-paste-20190303024438384.png)

### Simultaneous Open (동시 열기)
![](/assets/images/markdown-img-paste-20190303025720535.png)

### Simultaneous Close (동시 닫기)
![](/assets/images/markdown-img-paste-20190303025737584.png)

### Denying a Connection (연결 거부)
바로 Reset 패킷을 보내면 연결 거부
![](/assets/images/markdown-img-paste-20190303025829304.png)

### Aborting a Connection (연결 중단)
![](/assets/images/markdown-img-paste-20190303030035162.png)


## Windows in TCP
TCP는 송수신자가 각각 버퍼를 가지고 있고 이를 윈도우라 함. 만약 Bidirectional 커뮤니케이션을 하고 싶다면 윈도우가 4개 필요 (송수신 각각 두 개 씩)

### Send Window
* ACK를 받아야 윈도우를 슬라이딩함 (좌측 벽은 Close, 우측 벽은 Open)
* Send Window Size는 좌측벽과 우측벽 사이 전체 사이즈
* Send Window Size를 조절해서 Flow, Congestion Control 가능

![](/assets/images/markdown-img-paste-20190303030558139.png)
![](/assets/images/markdown-img-paste-20190303030620603.png)

### Receive Window
* Byte를 받으면 ACK 보냄과 동시에 윈도우를 닫음 (Close)
* 받은 Byte는 Process가 사용하길 기다리다가, 사용이 끝나면 윈도우를 염 (Open)
* Receive Window Size는 현재 받을 수 있는 윈도우 크기

![](/assets/images/markdown-img-paste-20190303031026448.png)


## Flow Control
송신자가 데이터를 전송하는 속도와 수신자가 데이터를 받는 속도를 서로를 고려해 적절히 조절해주는 것

### TCP/IP Protocol Suite
* Application 레이어는 Process, Transport 레이어는 Kernel이라 볼 수 있음
* 커널과 프로세스 사이, 커널과 커널 사이에 Flow Control Feedback 가능
* Sending Window Size < min(Receiver Buffer Size, Congestion Buffer Size)

![](/assets/images/markdown-img-paste-20190303031752549.png)

### Flow Control 예시
![](/assets/images/markdown-img-paste-20190303032255463.png)


## Error Control
TCP가 신뢰성(Reliable) 있다는 말은 한 프로그램에서 다른 프로그램으로 데이터를 보낼 때 에러가 없고, 잃거나 복제된 자료가 없이 제대로 가야 한다는 것을 뜻함. TCP의 에러는 **Checksum, Acknowledgment, Time-out** 세 가지를 사용해서 컨트롤 함

* ACK 세그먼트는 Sequence number를 소모하지 않고 Acknowledge하지 않는다 (ACK에 ACK를 보내지 않는다는 말)
* 데이터가 순서대로 오지 않아도 TCP는 순서를 정렬해서 Process에 전송해줌
* TCP는 Selective Repeat Protocol로서 가장 잘 모델링될 수 있음

### Sender FSM
![](/assets/images/markdown-img-paste-20190303040650370.png)

### Receiver FSM
![](/assets/images/markdown-img-paste-20190303041614602.png)

### Acknowledgment Generation Rule
1. 데이터를 보낼 때 ACK 포함
2. 데이터가 없어도 ACK Timer가 다 되면 ACK 보냄
3. TImer 종료 전 두 번 연속으로 ACK 받으면 ACK 보냄 (속도 향상을 위해)
4. 중간 ACK가 빠지면 받아야할 번호 ACK 보냄
5. 빠진 패킷이 제대로 오면 ACK
6. ACK가 누락되어 세 번 같은 패킷을 받으면 버리고 다시 ACK 보냄

![](/assets/images/markdown-img-paste-20190303042023827.png)
![](/assets/images/markdown-img-paste-20190303042043121.png)
![](/assets/images/markdown-img-paste-20190303042401633.png)

### Fast Retransmission
ACK 세 번 중첩해서 오면 큐 가장 앞의 세그먼트 다시 전송 후 타이머 재시작
![](/assets/images/markdown-img-paste-20190303042511250.png)

### Lost Acknowledgment
ACK 누락되면 그냥 그 다음 필요한 ACK를 보냄
* 잘 처리해주지 않으면 Deadlock에 빠질 수도

![](/assets/images/markdown-img-paste-20190303042616512.png)


## Congestion Control
Congestion(네트워크 혼잡)을 알아채고, 컨트롤 해야함

### Slow Start, Exponential Increase
Threshold를 만나기 전까지 Congestion Window Size가 Exponential하게 증가함
![](/assets/images/markdown-img-paste-2019030304315027.png)


### Congestion Avoidance, Additive Increase
한단계씩 증가
![](/assets/images/markdown-img-paste-20190303043328556.png)

### TCP Congestion Policy
* Retransmission 패킷이 발생하면 Congestion 일어난 걸로 봄
* Time-out이 ACK 세 번 온 것보다 더욱 심각함
* Threshold는 계속 줄어듬

![](/assets/images/markdown-img-paste-20190303043514845.png)

### Congestion 예시
![](/assets/images/markdown-img-paste-20190303043856796.png)


## TCP Timers
최소 4개 사용

### Persistence Timer
수신자의 윈도우 사이즈가 0임을 알리는 ACK가 왔을 때 송신자에서 Timer 시작하고 송신을 보류. 왜냐하면 만약 수신자 윈도우 사이즈가 다시 리사이징 돼었을 때 ACK가 손실된다면 수신자 측에서는 마냥 기다리기 때문에 Deadlock에 빠질 수 있음.
* 수신자 윈도우 사이즈가 0임을 알리는 ACK가 송신자에게 왔을 시 타이머 시작
* 타이머가 다되면 Probe라는 특수한 세그먼트를 송신자가 수신자에게 보내서 ACK를 요청함

### Keepalive Timer
Idle 상태로 연결이 오래 지속되는 것을 방지하기 위해 있는 타이머, 서버에서 타이머가 시작되고, 만약 클라이언트로 부터 세그먼트를 받는 다면 타이머 초기화, Time-out은 보통 2시간인데, 2시간이 지나도록 아무 응답이 없다면 서버가 클라이언트에게 Probe 패킷을 전송하고, 서버가 ACK를 받지 못할 경우 클라이언트와의 연결을 끊음

### TIME-WAIT Timer
접속 해제 시 필요 (1 ~ 2분, 2MSL(Maximum Segment Lifetime)) 마지막 ACK가 누락될 것을 대비

### Retransmission Timer
누락된 세그먼트를 재전송하기 위해 ACK를 기다리는 타이머. 만약 타이머가 끝나기 전까지 ACK가 오지 않았다면 세그먼트 손실로 간주하고 재전송. 이 Time-out을 RTO(Retransmission Time-Out) 이라함

### RTO 계산
RTO를 계산하기 위해서는 RTTm, RTTs, RTTd가 필요하다
* **RTTm (measurement RTT)** : 세그먼트 전송 후 실제 ACK가 돌아올 때 까지 걸리는 시간
* **RTTs (smoothed RTT)** : RTTs = (1 - a)RTTs + a * RTTm (a = 1/8), 스무딩을 위해
* **RTTd (deviation RTT)** : RTTd = (1 - d)RTTd + b * |RTTm - RTTs| (b = 1/4), 편차를 활용
* **RTO** = RTTs + 4RTTd
* **만약 재전송이 일어나면 RTO = RTO * 2**

## Options
TCP 헤더는 최대 40byte까지 옵션 가능

### Options

<table>
  <tr>
    <td rowspan=7><b>Options</b></td>
    <td rowspan=2><b>Single-byte</b></td>
    <td>End of option list</td>
    <td>옵션의 끝 알림, 한 번만 사용 가능</td>
  </tr>
  <tr>
    <td>No operation</td>
    <td>4byte단위로 (Word단위) 헤더 사이즈 맞추기 위해 혹은 옵션의 시작 지점 정렬위해, 여러 번 사용 가능</td>
  </tr>
  <tr>
    <td rowspan=5><b>Multiple-byte</b></td>
    <td>Maximum segment size</td>
    <td>Connection setup 시 설정, 바뀌지 않음, 보통 1024byte</td>
  </tr>
  <tr>
    <td>Window scale factor</td>
    <td>Connection setup 시 설정, 바뀌지 않음, 16bit, 윈도우 사이즈가 2의 몇 승인지</td>
  </tr>
  <tr>
    <td>Timestamp</td>
    <td>RTT(Round Trip Time) 계산 시 사용</td>
  </tr>
  <tr>
    <td>SACK-permitted</td>
    <td></td>
  </tr>
  <tr>
    <td>SACK</td>
    <td>Selective ACK, 전송 중간에 빠진 패킷 용 (보통 ACK는 Cumulative ACK)</td>
  </tr>
</table>

### End-of-option
![](/assets/images/markdown-img-paste-20190303161637541.png)

### No-operation
![](/assets/images/markdown-img-paste-20190303161655372.png)

### Maximum-segment-size
![](/assets/images/markdown-img-paste-20190303161729746.png)

### Window-scale-factor
![](/assets/images/markdown-img-paste-20190303161744240.png)

### Timestamp
![](/assets/images/markdown-img-paste-20190303161815821.png)
![](/assets/images/markdown-img-paste-20190303161919930.png)

### SACK
![](/assets/images/markdown-img-paste-20190303161942935.png)
![](/assets/images/markdown-img-paste-20190303162111808.png)

## TCP Package
![](/assets/images/markdown-img-paste-20190303162238565.png)

### TCBs
TCP 컨트롤에 필요한 DB를 TCBs라 함
![](/assets/images/markdown-img-paste-20190303162403847.png)

# SCTP(Stram Control Transmission Protocol)
2000년대 초반 TCP(1970's)를 개선해서 나옴. TCP 장점 + UDP 장점 + $\alpha$
* DCCP는 Datagram + Congestion control 기능

## Introduction
SCTP는 신뢰성 있고 (Reliable), 메시지 기반 (Message-oriented) 프로토콜 (TCP는 Byte-oriented라고도 할 수 있음)
* **UDP**(Message-oriented)와 **TCP**(Control)의 좋은 특징들을 결합해서 만듬

## SCTP Services
Telephony의 경우 Voice Over IP를 위해 사용

|Protocol|Port Number|Description|
|--|:--:|--|
|IUA|9990|ISDN over IP|
|M2UA|2904|SS7 telephony signaling|
|M3UA|2905|SS7 telephony signaling|
|H.248|2945|Media gateway control|
|H.323|1718,1719,1720,11720|IP telephony|
|SIP|5060|IP telephony|

### Multiple-stream Concept
유저가 여러명일 경우 유저 별로 스트림 구분 가능 (TCP의 경우 통째로)
* 왜 SCTP?
  * 만약 여러명이 TCP로 데이터를 묶어 보내면 한 명만 누락되도 막히기 때문 (Head of line blocking)
* TCP는 Connecton이라 하지만 SCTP는 **Association** 이라함, 한 Association이 여러 스트림을 가질 수 있음

![](/assets/images/markdown-img-paste-20190303165753948.png)

### Multihoming Concept
Multihoming이란 한 기기가 여러 IP를 가질 수 있다는 것을 뜻함 (라우터 여러 개일 경우)
* 각 Gateway가 Home이라고 할 수 있음
* 평상시에는 하나(Primary path)만 쓰다가 Failure가 일어나면 Backup path 사용
* VOIP는 실시간 서비스가 가능해야함 = Reliable + Real-time (**Mission Critical**)

![](/assets/images/markdown-img-paste-2019030317011762.png)

## SCTP Features

### TSN (Transmission Sequence Number)
SCTP에서 데이터 Chunk는 TSN으로 넘버링됨, Association 안의 모든 Stream의 Chunk에 대해 넘버링
* Association 별로 따로 존재
* 패킷 안에 Chunk 여러 개
* Control, Data Chunk 따로 존재

### SI (Stream Identifier)
서로 다른 Stream 끼리 구분을 위해 SI 사용

### SSN (Stream Sequence Number)
같은 Stream 안의 데이터 Chunk 구분을 위해 SSN 사용

![](/assets/images/markdown-img-paste-20190303172716413.png)

### TCP Segment와 SCTP Packet 비교
SCTP 패킷의 경우 기본 헤더는 12byte,
* Verification tag는 보안 향상을 위해
* Checksum은 CRC 사용
* SCTP는 Control 정보와 Data 정보가 서로 다른 Chunk에 들어가 있음
* SCTP 패킷에서 Control chunk는 Data chunk 전에 나옴

![](/assets/images/markdown-img-paste-20190303172842997.png)

### Packets, Data Chunks, Streams
Data chunk는 TSN, SI, SSN 세 가지를 통해 구분됨
![](/assets/images/markdown-img-paste-20190303173211572.png)

### Acknowledgment Number
SCTP에서 ACK number는 Data chunk에 대해 ACK하기 위해서만 사용. Control chunk는 다른 Control chunk에 의해 ACK

## Packet Format
SCTP의 패킷은 필수인 헤더와 Chunk라 불리면 몇몇 블락들로 구성됨. Chunk는 크게 Control, Data chunk로 나뉨
* 패딩에 대한 byte들의 갯수는 Length field에 포함되지 않음

### Header Layout
![](/assets/images/markdown-img-paste-20190303174249801.png)

### Chunk Layout
4byte 단위로 끊겨야함
![](/assets/images/markdown-img-paste-20190303174326579.png)

### Chunk 종류

|Type|Chunk|Description|
|:--:|:--|:--|
|0|DATA|사용자 데이터|
|1|INIT|Association 셋업|
|2|INIT ACK|INIT chunk에 대한 ACK|
|3|SACK|Selective ACK.|
|4|HEARTBEAT|Peer가 살아있는지 (Backup path)|
|5|HEARBEAT ACK|HEARTBEAT chunk에 대한 ACK|
|6|ABORT|Association 중단 (TCP의 Reset), Critical|
|7|SHUTDOWN|Association 종료|
|8|SHUTDOWN ACK|SHUTDOWN chunk에 대한 ACK|
|9|ERROR|Shutdown하지 않고 에러 리포트|
|10|COOKIE ECHO|Association eatablishment의 세 번째 패킷|
|11|COOKIE ACK|COOKIE ECHO chunk에 대한 ACK|
|14|SHUTDOWN COMPLETE|Association termination에 세 번째 패킷|
|192|FORWARD TSN|누적된 TSN 조정 위해|

#### DATA Chunk
한 메시지 이상의 데이터를 Chunk에 넣을 수는 없음. 하지만 한 메시지가 여러 개의 Chunk로 나뉘는건 가능. data 필드에 최소 1바이트 이상의 데이터 보내야함 (최소 Length = 17byte (16헤더 + 1데이터))
![](/assets/images/markdown-img-paste-20190303175211243.png)

#### INIT Chunk
INIT chunk를 가지는 패킷에 다른 Chunk를 넣으면 안됨
![](/assets/images/markdown-img-paste-20190303175352754.png)

#### INIT ACK Chunk
INIT ACK chunk를 가지는 패킷에 다른 Chunk를 넣으면 안됨
![](/assets/images/markdown-img-paste-20190303175452916.png)

#### COOKIE ECHO Chunk
![](/assets/images/markdown-img-paste-2019030317553848.png)

#### COOKIE ACK Chunk
![](/assets/images/markdown-img-paste-20190303175618464.png)

#### SACK Chunk
![](/assets/images/markdown-img-paste-20190303180012977.png)

#### HEARTBEAT / HEARBEAT ACK Chunk
![](/assets/images/markdown-img-paste-20190303180118533.png)

#### SHUTDOWN Chunks
![](/assets/images/markdown-img-paste-20190303180139161.png)

#### ERROR Chunk
![](/assets/images/markdown-img-paste-20190303180202352.png)

|Errors||
|--|--|
|Code|Description|
|1|SI 이상|
|2|필수 파라미터 없음|
|3|State cookie 에러|
|4|Out of resource|
|5|가져올 수 없는 주소|
|6|Chunk type 이상|
|7|필수 파라미터 이상|
|8|인식 불가능한 파라미터|
|9|User data 없음|
|10|종료 도중 쿠키 도착|

#### ABORT Chunk
![](/assets/images/markdown-img-paste-20190303180219480.png)

## SCTP Association
SCTP도 TCP와 마찬가지로 연결지향 프로토콜. 하지만 SCTP에서는 Connection을 Multihoming을 잘 나타내기 위해 **Association** 이라함
* SCTP에서는 Data chunk만 TSN을 소모하고, Data chunk만 ACK를 받을 수 있음

### Four-way Handshaking
제대로된 Cookie인지 확인 (인증 절차)
* TCP에서 Sync attack (DDOS) 완화 (Sync를 한 번에 여러개 보내면 Sync마다 리소스 할당하기 때문)

![](/assets/images/markdown-img-paste-20190303181034547.png)

### Data Transfer
SCTP의 ACK는 누적된 TSN에 대한 ACK. 순서대로 받은 마지막 TSN을 뜻함
![](/assets/images/markdown-img-paste-20190303181502951.png)

### Association Termination
![](/assets/images/markdown-img-paste-20190303181742793.png)

### Association Abortion
![](/assets/images/markdown-img-paste-20190303181815640.png)


## State Transition Diagram
![](/assets/images/markdown-img-paste-20190303181910780.png)

### Common Scenario
![](/assets/images/markdown-img-paste-20190303182234824.png)

### Simultaneous Open
![](/assets/images/markdown-img-paste-2019030318234377.png)

### Simultaneous Close
![](/assets/images/markdown-img-paste-20190303182414237.png)


## Flow Control
SCTP의 Flow control은 TCP와 유사. 하지만 SCTP에서는 **Byte와 Chunk** 두 개에 대해 컨트롤 필요. rwnd(Receiver Window)와 cwnd(Sender Window)는 Byte control에 사용하고, TSN과 ACK는 Chunk control에 사용

### Receiver Site
![](/assets/images/markdown-img-paste-20190303182740492.png)

### Sender Site
![](/assets/images/markdown-img-paste-20190303182803593.png)

### Flow Control Scenario
![](/assets/images/markdown-img-paste-20190303182959890.png)

## Error Control
SCTP도 TCP와 같이 신뢰성 있는 프로토콜. SCTP는 SACK를 통해 수신자의 버퍼 상태를 송신자에게 보냄

### Receiver Site
![](/assets/images/markdown-img-paste-20190303183323678.png)

### Sender Site
* SACK 받기 전
![](/assets/images/markdown-img-paste-20190303183342177.png)
* SACK 받은 후
![](/assets/images/markdown-img-paste-20190303183519393.png)


## Congestion Control
TCP와 같은 전략 사용, Slow-start, Congestion avoidance, Congestion detection. TCP와 마찬가지로 Fast retransmission과 Fast recovery 사용


# Introduction to the Application Layer

## Client-Server Paradigm
네트워크의 목적은 사용자에게 서비스를 제공하는 것. 이를 간단하게 나누면 서비스를 제공해주는 서버, 서비스를 받는 클라이언트로 정의 가능

### Server Types
* Iterative : 우선적으로 오는 패킷들에 대해 순차적 반복적으로 응답 줌 (하나의 큐)
* Concurrent : 동시에 여러 개의 패킷들을 처리 (여러 개의 큐, 보통 클라이언트 하나 당 하나)

![](/assets/images/markdown-img-paste-20190303184745782.png)

### Interface
인터페이스는 두 객체 (Entity) 간의 상호작용을 위해 디자인된 Instruction 들

### OS, Process
Socket interface와 Application 레이어는 Process 단, OS는 Kernel 단
![](/assets/images/markdown-img-paste-20190303185057153.png)

### Concepts of Sockets
![](/assets/images/markdown-img-paste-20190303185147584.png)

### Socket Data Structure
![](/assets/images/markdown-img-paste-20190303185223312.png)

### Socket Types
![](/assets/images/markdown-img-paste-2019030318524632.png)

### IPv4 Socket Address
![](/assets/images/markdown-img-paste-20190303185546697.png)

### UDP Connectionless Iterative
![](/assets/images/markdown-img-paste-20190303185629875.png)

### Connection-oriented Concurrent
![](/assets/images/markdown-img-paste-20190303185757995.png)

## Peer-to-Peer Paradigm
P2P (토렌트 등). 여러 대의 PC가 서로 서비스를 제공


# DHCP (Dynamic Host Configuration Protocol)
TCP/IP Protocol suite를 사용하는 모든 기기는 서로의 IP 주소, Subnet mask, Default 라우터 주소, DNS서버 주소를 알아야함. DHCP는 IP주소를 동적으로 할당해줌

## DHCP Operation
DHCP 서버와 클라이언트는 서로 같거나 다른 네트워크에 존재 가능

### Same Network
주소 비트가 모두 0 면 주소 모른다는 말이고, 주소 비트가 모두 1이면 브로드캐스트
![](/assets/images/markdown-img-paste-20190303190526809.png)

### Different Network
에이전트가 서버로 Request를 포워딩해줌
![](/assets/images/markdown-img-paste-20190303190624375.png)

### UDP Port 사용
DHCP는 Well-known 포트인 68, 67 번 UDP 포트 사용
* 68은 클라이언트 쪽, 67은 서버 쪽

### DHCP Packet Format
DHCP에 필요한 정보 대부분은 Option에 있음
* Flags 첫 비트만 사용, 0면 유니캐스트, 1이면 브로드캐스트

![](/assets/images/markdown-img-paste-20190303190905808.png)

#### DHCP Options
![](/assets/images/markdown-img-paste-20190303191213183.png)
![](/assets/images/markdown-img-paste-20190303191200626.png)

## Configuration
정적(Static), 동적(Dynamic) 주소 할당(Allocation) 지원
* 클라이언트는 DHCP 서버에게 주소를 잠시 빌린 것이므로 Realse Time-out 발생 시 다시 요청 필요

![](/assets/images/markdown-img-paste-20190303191530258.png)
![](/assets/images/markdown-img-paste-20190303191631353.png)
![](/assets/images/markdown-img-paste-20190303191654360.png)

# DNS (Domain Name System)

## Need For DNS
IP주소로 기기를 인식하지만 사람은 숫자로된 IP 주소보단 글로 구성된 주소를 선호하므로, 이름과 주소를 맵핑해주는 시스템을 DNS라 함 (111.111.111.111 => www.111.com)
![](/assets/images/markdown-img-paste-20190303192229619.png)

## Name Space
이름도 IP 주소와 같이 유일해야 함. Flat, Hierarchical(계층적)으로 관리

### Domain Name Space
![](/assets/images/markdown-img-paste-20190303192633609.png)

### Domain Names and Labels
![](/assets/images/markdown-img-paste-20190303192712250.png)

### FQDN, PQDN
* FQDN (Full Qulified Domain Name)
* PQDN (Partial Qulified Domain Name) : 같은 도메인일 경우

![](/assets/images/markdown-img-paste-20190303192850914.png)

### Domains
![](/assets/images/markdown-img-paste-20190303192917279.png)

### Hierarchy of Name Servers
Root Server는 전세계 10개 정도
* 세계, 미국의 경우 .com
* 우리나라는 .kr 등

![](/assets/images/markdown-img-paste-20190303193012734.png)

### Zones and Domains
* Primary 서버가 모든 정보를 디스크로 부터 읽고, Secondary 서버는 Primary 서버의 모든 정보를 로드함
* Zone transfer : Secondary 서버가 모든 Primary 서버의 정보를 다운 받는 것

![](/assets/images/markdown-img-paste-20190303193128583.png)

## DNS in the Internet
Internet에서는 Generic, Counry, Inverse 세개의 도메인으로 나눠짐
* Inverse 도메인 : IP를 도메인 이름으로
* Generic 도메인 : .com, .edu, .org, .gov, .net 등
* Country 도메인 : .us, .kr, .uk 등

![](/assets/images/markdown-img-paste-20190303193401249.png)

## Resolution
이름을 주소에, 주소를 이름에 맵핑하는 것을 Name-address resolution 이라 함

### Recursive Resolution
![](/assets/images/markdown-img-paste-2019030319363254.png)

### Iterative Resolution
![](/assets/images/markdown-img-paste-20190303193708881.png)

## DNS Messages
Query, Response 두 메시지 있음. 둘 다 포멧은 같음
* 단위는 Record

### Message Format
![](/assets/images/markdown-img-paste-20190303193810517.png)

### Header Format
![](/assets/images/markdown-img-paste-20190303193843726.png)

## Types of Records

### Question Record Format
![](/assets/images/markdown-img-paste-20190303194006773.png)

#### Query Name Format
![](/assets/images/markdown-img-paste-20190303194040728.png)

#### Query Types
![](/assets/images/markdown-img-paste-20190303194101874.png)

#### Query Class
![](/assets/images/markdown-img-paste-2019030319414370.png)

### Resource Record Format
Answer, Authoritative, Additional Section의 포멧
![](/assets/images/markdown-img-paste-20190303194215605.png)

## Compression
Domain 이름이 반복된다면 Offset Pointer로 대체해서 DNS 표현 간소화 가능
![](/assets/images/markdown-img-paste-20190303194539328.png)

## Encapsulation
DNS는 UDP나 TCP 둘 다 사용 가능
* 53번 포트 사용
* 512byte 이하면 UDP 초과면 TCP 사용

## Registraras
ICANN에 속한 Registrar (등록 해주는 시스템)에 의해 등록

## DDNS
Dynamic DNS, DNS는 보통 등록에 3 ~ 4일이 걸리지만 DDNS는 바로 등록 가능

## Security of DNS
IETF가 DNSSEC(DNS Security) 기술 만듬. 디지털 서명을 통해 메시지 인증 및 무결성 검증

# TELNET and SSH(Remote Login)

## TELNET
TErminal NETwork. ISO에서 제안한 가상 터미널 서비스. 원격 터미널 접속 가능

## Secure Shell
SSH (Secure Shell) TELNET과 유사. TCP를 이용한 Transport 프로토콜. TELNET 보다 안전하고 많은 서비스 지원
* Secure Connection

# FTP, TFTP (File Transfer)

## FTP
TCP/IP 프로토콜에서 파일을 호스트에서 다른 호스트로 복사하는 방법 제공
* 두 시스템이 서로 다른 파일 이름 형식 사용 중일 수 있음
* 두 시스템이 서로 텍스트나 데이터를 표현하는 형식이 다를 수 있음
* 두 시스템이 서로 다른 폴더 구조를 가질 수도 있음
* FTP는 위의 문제를 간단한 방법으로 해결

### TCP Connection
FTP는 TCP 연결 사용. Well-known 포트인 21번 포트를 컨트롤 용으로, 20번 포트를 데이터 전송용으로 사용 (두 개의 소켓이 열림)
![](/assets/images/markdown-img-paste-20190303200004394.png)

### Control Connection
![](/assets/images/markdown-img-paste-20190303200048532.png)

### Data Connection
![](/assets/images/markdown-img-paste-20190303200147118.png)

### Using Control COnnection
표준 아스키코드를 이용하여 컨트롤
![](/assets/images/markdown-img-paste-2019030320024273.png)

### Using Data Connection
![](/assets/images/markdown-img-paste-2019030320032230.png)

### Command
서버가 클라이언트에게 커맨드 보낼 수는 없음 (FTP 서버는 수동적)
![](/assets/images/markdown-img-paste-20190303200408737.png)

#### Access Commands

|Command|Argument|Description|
|--|--|--|
|USER|User id|사용자 정보|
|PASS|User password|비밀번호|
|ACCT|Account to be charged|계정 정보|
|REIN||재시작|
|QUIT||시스템에서 로그아웃|
|QBOR||이전 커맨드 무시|

#### File Management Commands
![](/assets/images/markdown-img-paste-20190303200652880.png)

#### Data Formatting Commands
![](/assets/images/markdown-img-paste-20190303200727983.png)

#### Port Defining Commands
![](/assets/images/markdown-img-paste-20190303200755425.png)

#### File Transfer Commands
![](/assets/images/markdown-img-paste-2019030320081605.png)

#### Micellaneous Commands
![](/assets/images/markdown-img-paste-20190303200840276.png)

### Response
100, 300 임시, 200 Passive
![](/assets/images/markdown-img-paste-2019030320090394.png)
오류
![](/assets/images/markdown-img-paste-20190303200942103.png)

### File Transfer
![](/assets/images/markdown-img-paste-2019030320101484.png)

### Example
![](/assets/images/markdown-img-paste-2019030320104663.png)

## TFTP
간단하게 파일 복사 시 이용. 예를 들어 디스크가 없는 워크스테이션이나 라우터 부팅 시 Bootstrap을 다운 받아야 하는데 이때 다른 기능 없이 단순히 파일 복사 기능만 필요할 경우 TFTP 사용
* UDP 포트 69번 사용
### Message Types
* RRQ : Read Request
  ![](/assets/images/markdown-img-paste-20190303201526266.png)
* WRQ : Write Request
  ![](/assets/images/markdown-img-paste-20190303201536531.png)
* DATA : 데이터 전송
  ![](/assets/images/markdown-img-paste-20190303201556366.png)
* ACK
  ![](/assets/images/markdown-img-paste-20190303201616370.png)
* Error
  ![](/assets/images/markdown-img-paste-20190303201731822.png)
![](/assets/images/markdown-img-paste-20190303201400337.png)

### DHCP 관리
DHCP 관리를 위해 TFTP 사용하기도 함

![](/assets/images/markdown-img-paste-20190303201957262.png)


# WWW (World Wide Web) and HTTP (Hypertext Transfer Protocol)

## Architecture
최근의 WWW는 분산된 클라이언트-서버 서비스를 제공해줌. 클라이언트는 브라우저를 통해 서버의 서비스를 제공 받을 수 있음. 하지만 너무 많은 사이트가 분산 되어 있음.

### Transaction
* 각각의 페이지는 독립적이지만, 페이지 내의 링크를 통해 다른 페이지를 접근 가능
* 각각의 다른 페이지도 바로 접근 가능
* Request, Response 한 페어를 **Transaction** 이라 함

![](/assets/images/markdown-img-paste-20190303224635168.png)

### Browser
![](/assets/images/markdown-img-paste-20190303224451837.png)

### URL
URL (Uniform Resource Locator), URI는 Uniform Resource Identifier임
![](/assets/images/markdown-img-paste-20190303224757874.png)

## Web Documents
WWW의 문서들은 크게 **Static, Dynamic, Active** 세가지로 볼 수 있음. 각각의 종류는 문서의 컨텐츠가 정해지는 시간이라 볼 수 있다
* **정적(Static)** : 있는 내용 그대로 받아옴
* **동적(Dynamic)** : 서버에서 프로그램을 이용해 내용을 바꾼 다음 전송
* **능동적(Active)** : 서버에서 작은 프로그램을 클라이언트에 전송해주면 클라이언트가 처리

### Static Document
웹페이지 내용이 그대로 옴 (바뀌지 않음)
![](/assets/images/markdown-img-paste-20190303225018927.png)

### CGI를 이용한 Dynamic Document
요청 시 프로그램에 의해 내용이 동적으로 정해짐 (내용이 수시로 바뀜)
* CGI (Common Gateway Interface)

![](/assets/images/markdown-img-paste-20190303225115640.png)

### Server-site Script를 이용한 Dynmic Document
HTML 문서 안의 스크립트를 돌려서 보냄 (ASP, JSP 등)
![](/assets/images/markdown-img-paste-20190303225331393.png)

### Document 종류들

|Type|Discription|
|--|--|
|HTML||
|XML||
|XSL||
|XHTML||

### Active Documnet using Java applet, JavaScript
서버가 작은 프로그램을 던져주면 클라이언트가 프로그램을 돌려서 처리
![](/assets/images/markdown-img-paste-20190303225600985.png)

## HTTP
HTTP(Hypertext Transfer Protocol)은 WWW에서 데이터에 접근하기 위한 주된 프로토콜. FTP와 SMTP를 합친 것 처럼 작동함. FTP 처럼 파일을 전송하고, TCP 서비스를 이용. 하지만 FTP 보다 간단하게 하나의 TCP 연결만 사용. 오직 클라이언트와 서버 사이의 데이터 송수신만을 고려 (컨트롤 소켓 따로 열지 않음)
* TCP 80번 포트 사용

### HTTP Transaction
사람이 읽을 수 있는 텍스트로 내용이 채워져 있음
![](/assets/images/markdown-img-paste-20190303231249346.png)

### Request Message Format
![](/assets/images/markdown-img-paste-20190303231454829.png)

#### Methods

|Method|Action|
|--|--|
|GET|클라이언트가 서버에 문서 요청|
|HEAD|문서에 대한 정보 요청 (문서 자체는 아님)|
|POST|클라이언트가 서버에 문서 업로드|
|PUT|클라이언트가 서버의 문서 수정 (대부분)|
|PATCH|클라이언트가 서버의 문서 수정 (일부분)|
|TRACE|현재 오는 요청 에코|
|CONNECT|(예약)|
|DELETE|웹 문서의 문서 삭제|
|OPTIONs|서버가 지정한 문서에 대해 어떤 기능과 옵션을 제공하는지 조회|


#### Request Header Names

![](/assets/images/markdown-img-paste-20190303232422811.png)

### Response Message Format

![](/assets/images/markdown-img-paste-20190303232546639.png)

#### Status Codes and Status Phrase

![](/assets/images/markdown-img-paste-20190303232655172.png)

#### Response Header Names

![](/assets/images/markdown-img-paste-20190303232732262.png)

### Example

![](/assets/images/markdown-img-paste-20190303232924992.png)

#### Nonpersistent Connection
* TCP를 이용해 전송
* 같은 사이트지만 계속 연결해야함

![](/assets/images/markdown-img-paste-20190303233036399.png)

#### Persistent Connection
HTTP version 1.1의 경우 일정시간 안에 Transaction이 있으면 영구적으로 접속되게 해줌

![](/assets/images/markdown-img-paste-20190303233334574.png)

### 쿠키 사용 시 이점
![](/assets/images/markdown-img-paste-2019030323350432.png)


# Electronic Mail : SMTP, POP, IMAP, MIME

## Architecture

### First Scenario
만약 송수신자가 같은 메일 서버를 이용한다면 두 개의 사용자 에이전트만 있으면 됨
![](/assets/images/markdown-img-paste-20190303233733313.png)

### Second Scenario
만약 송수신자가 다른 메일 서버를 이용한다면 두 개의 사용자 에이전트와 한 쌍의 MTA (Message Transfer Agent)가 필요
* 1990년대

![](/assets/images/markdown-img-paste-20190303233820425.png)

### Third Scenario
송신자가 LAN이나 WAN으로 메일 서버에 연결되어있다면, 두 개의 사용자 에이전트와 두 쌍의 MTA가 필요
* 2000년대

![](/assets/images/markdown-img-paste-20190303233953536.png)

### Fourth Scenario
송수신자 모두가 메일 서버에 LAN이나 WAN으로 연결되어 있으면, 두 개의 사용자 에이전트, 두 쌍의 MTA, 한 쌍의 MAA (Mesage Access Agent)가 필요
* 요즘

![](/assets/images/markdown-img-paste-20190303234201578.png)

### Push / Pull
![](/assets/images/markdown-img-paste-20190303234444645.png)
![](/assets/images/markdown-img-paste-20190303234456852.png)

## User Agent
UA. 사용자가 메시지를 보내고 받는 과정을 쉽게 만들어줌
* Command-driven UA : mail, pine, elm
* GUI-based UA : Outlook, Eudora, Netscape

### Email Format
![](/assets/images/markdown-img-paste-20190303234756857.png)

### Email Address
![](/assets/images/markdown-img-paste-20190303234819616.png)


## Message Transfer Agent
실제로 메일 전송은 MTA를 통해서 일어남. 메일을 보내기 위해서 시스템은 클라이언트 MTA를 가지고 있어야하고, 메일을 받기 위해서는 서버 MTA를 가지고 있어야함. MTA를 위한 일반적인 프로토콜을 SMTP (Simple Mail Transfer Protocol) 이라함.

### SMTP Range
![](/assets/images/markdown-img-paste-20190303235110732.png)

### Commands and Responses
![](/assets/images/markdown-img-paste-20190303235140159.png)

#### Commands
![](/assets/images/markdown-img-paste-20190303235202781.png)

#### Responses
![](/assets/images/markdown-img-paste-20190303235252932.png)

### Connection Establishment
![](/assets/images/markdown-img-paste-20190303235355420.png)

### Messsage Transfer
![](/assets/images/markdown-img-paste-20190303235451230.png)

### Connection Termination
![](/assets/images/markdown-img-paste-20190303235520966.png)

## Message Access Agent
SMTP는 Push용 프로토콜이라 MAA에서 쓰이지 않음 (MAA는 Pull하기 때문). Pull 프로토콜인 POP3와 IMAP4 사용

### POP3 and IMAP4
![](/assets/images/markdown-img-paste-20190303235711191.png)

#### POP3
![](/assets/images/markdown-img-paste-20190303235734157.png)

## MIME
원래 E-mail은 구조가 간단해서 NVT 7-bit ASCII 포맷만 전송가능해서 한계점이 있음. 하지만 MIME (Multipurpose Internet Mail Extensions)는 ASCII 데이터가 아닌 데이터도 E-mail로 전송 가능하게함. MIME는 송신자 측에서 데이터를 NVT ASCII 데이터로 변환 후 MTA를 이용해 전송. MAA로 데이터를 받으면 다시 원래 데이터로 변환

### MIME
![](/assets/images/markdown-img-paste-20190304000037967.png)

### MIME Header
![](/assets/images/markdown-img-paste-20190304000057934.png)

#### Data Types and Subtypes
![](/assets/images/markdown-img-paste-20190304000138912.png)

#### Content Transfer Encoding
![](/assets/images/markdown-img-paste-20190304000215600.png)

#### Base64
![](/assets/images/markdown-img-paste-20190304000317630.png)

#### Quoted Printable
![](/assets/images/markdown-img-paste-20190304000426445.png)

## Web-based Mail
웹을 이용해 이메일 서비스 제공 (HTTP). Google, Yahoo, Hotmail 등

### Case 1
![](/assets/images/markdown-img-paste-20190304000623652.png)

### Case 2
![](/assets/images/markdown-img-paste-2019030400065484.png)

## E-mail Security
PGP (Pretty Good Privacy), SMIME (Secure MIME) 프로토콜 있음


# SNMP (Simple Network Management Protocol)

## Concept
Manager, Agent를 컨셉으로 잡음. 매니져(Host)가 에이전트(Routers, Servers)를 컨트롤하고 모니터링

![](/assets/images/markdown-img-paste-20190304000958360.png)

## Management Components
관리(Management)를 위해 두 가지 프로토콜 사용. SMI (Structure of Management Information), MIB (Management Information Base)
* 인터넷의 관리는 **SNMP, SMI, MIB** 를 이용함
* SMI(구조)와 MIB(정보)가 망관리 서포트
* **SNMP** 는 매니저와 에이전트 사이의 패킷 포맷을 정의하고, SNMP 패킷의 객체들의 상태를 읽고 바꿈
* **SMI** 는 객체 네이밍, 객체 타이핑, 객체와 값들의 인코딩에 대한 형식 정의
* **MIB** 는 이름이 붙은 객체들과, 그들의 타입, 그리고 객체 상호간의 관계에 대해 만듬

![](/assets/images/markdown-img-paste-20190304001224767.png)

![](/assets/images/markdown-img-paste-20190304001930564.png)

### Management Overview

![](/assets/images/markdown-img-paste-20190304002132261.png)

## SMI
* Name : 객체들의 네이밍
* Data Type : 객체들에 저장 가능한 데이터 타입 정의
* Encoding Method : 네트워크로 전송하기 위해 데이터 인코딩 방법 보여줌

## MIB
각 에이전트가 MIB를 가지고 있음. MIB 안에는 매니저가 관리할 수 있는 오브젝트들이 모여있음.
* MIB 객체들의 카테고리 : System, Interface, Address trnslation, IP, ICMP, TCP, UDP, EGP, Transmission, SNMP

## SNMP
SMI와 MIB를 가지고 네트워크 관리르를 하는 Application 프로그램
* 에이전트에 정의된 객체의 값을 가져옴
* 에이전트에 정의된 객체에 값을 저장
* 에이전트는 에러 상황일 때 알람 메시지를 매니저에게 보냄
* 클라이언트(매니저)는 UDP 포트 162번, 서버(에이전트)는 161번 사용

### SNMP PDUs
Trap은 에이전트가 알아서 보내는 것

![](/assets/images/markdown-img-paste-20190304002921467.png)

### SNMP PDU Format

![](/assets/images/markdown-img-paste-20190304003001299.png)

#### PDU Types

![](/assets/images/markdown-img-paste-2019030400302820.png)

#### Error Types

![](/assets/images/markdown-img-paste-20190304003048285.png)

#### SNMP Message

![](/assets/images/markdown-img-paste-20190304003118893.png)


# Multimedia

## Introduction
Internet Audio/Video
* Streaming stored audio/video = VOD (저장)
* Streaming live audio/video = TV (버퍼링)
* Interactive audio/video = 화상통화 (실시간)

## Digitizing Audio/Video
오디오, 비디오 시그널을 디지털화(Digitized)해야 이너넷으로 전송 가능
* 비디오 전송을 위해서는 압축이 필수

## Audio and Video Compression
### JPEG Compression
![](/assets/images/markdown-img-paste-20190304004208998.png)

## Streaming Stored Audio/Video
### Web Server

![](/assets/images/markdown-img-paste-20190304004325413.png)

### Web Server + Metafile

![](/assets/images/markdown-img-paste-20190304004348198.png)

### Media Server

![](/assets/images/markdown-img-paste-20190304004359917.png)

### Media Server + RTSP (Real Time Streaming Protocol)

![](/assets/images/markdown-img-paste-20190304004439262.png)

## Streaming Live Audio/Video
Multicast + Live

## Real-Time Interactive Audio/Video
인터넷폰, VOIP (Voice Over IP)

### Jitter
패킷 전송 딜레이가 각각 다름. Playback 버퍼링 사용

### Real-Time 필요 요소
* 멀티캐스팅 필요
* TCP는 느리고 Retransmission 허용 해줄 수 없기 때문에 UDP 사용
* RTP 사용

## RTP
RTP (Real-time Transport Protocol). UDP와 함께 사용 (전달 매커니즘(멀티캐스팅, 포트 번호 등)이 없기 때문)
* 짝수 UDP 포트 사용

## RTCP
RTCP (Real-time Transport Control Protocol) 흐름 제어와, 품질 보증
* Sencder/Receiver Report로 수시로 확인
* 홀수 UDP 포트 사용

## VOIP
SIP, H.323 사용


# IPv6 Addressing

## Introduction
128bit (16byte) 크기를 가짐
* Colon, Hexadecimal notation 사용

  `FDEC:BA98:7654:3210:ADBF:BBFF:2922:FFFF`

### Zero Compression
0을 압축 가능 (하나만)
`FDEC:0:0:0:0:BBFF:0:FFFF` => `FDED::BBFF:0:FFFF`

### CIDR Address
`FDEC::BBFF:0:FFFF/60`

## Address Space Allocation
* 정의 되지 않은 주소는 ::/128 (모두 0, IPv4와 비슷)
* Loopback 주소는 ::1/128 (IPv4 127.0.0.1)
* IPv4 Tenneling ::X:Y:Z:W

![](/assets/images/markdown-img-paste-20190304005831111.png)

### Compatiable Address
v4, v6 호환

![](/assets/images/markdown-img-paste-20190304013057422.png)

### Mapped Address
v4, v6 transmission 시 (바꿔줘야 할 때)

![](/assets/images/markdown-img-paste-20190304013009225.png)

### Unique Local Unicast Address
한 Domain에서 Unique한 주소
* Interface ID (MAC ID 48bit + 16bit)

![](/assets/images/markdown-img-paste-20190304010733621.png)

### Link Local Address
서브넷 상의 로컬 주소

![](/assets/images/markdown-img-paste-20190304015148719.png)

### Multicast Address

![](/assets/images/markdown-img-paste-20190304013724558.png)

## Global Unicast Addresses
인터넷 상에 있는 두 호스트간 유니캐스트 커뮤니케이션용 주소
* 2000::/3 (001)
* Three Levels of Hierarchy (Aggregation 쉬워짐)
* IPv6의 경우 지역별로 나눠줘서 IPv4 보다 구분이 쉬움

## Global Unicast Address
* Global routing prefix (48bit) : 기관
* Subnet identifier (16bit) : 서브넷
* Interface identifier (64bit) : 랜카드 (MAC)으로 자동으로 정해짐

![](/assets/images/markdown-img-paste-2019030401435756.png)

### EUI-64
EUI 인터페이스라면 한비트만 바꿔 Interface identifier로 사용

![](/assets/images/markdown-img-paste-20190304014611577.png)

### Ethernet MAC
이더넷이라면 아래와 같이 바꿔 Interface identifier로 사용

![](/assets/images/markdown-img-paste-20190304014742814.png)


## Autoconfiguration
컴퓨터 스스로 주소를 만듬. IPv4 처럼 DHCP를 이용해 받아올 수도 있지만 호스트 자체가 생성도 가능
* eg) 이더넷 주소가 $(F5-A9-23-11-9B-E2)_ {16}$이라면 Interface identifier는 F7A9:23FF:FE11:9BE2 임

## Renumbering
사이트가 서비스 제공자를 바꾸는 것을 허용하기위해 주소의 Prefix를 바꾸는 것을 IPv6에서는 허용함


# IPv6 Protocol

## Packet Format
필수적인 헤더 그리고 Payload로 구성됨. Payload에는 추가적인 Extension 헤더와(없어도됨), 위 레이어에서 온 Data가 포함. 필수 헤더는 40byte, Extension 헤더와 Data는 65535바이트까지 가질 수 있음

### IPv6 Datagram

![](/assets/images/markdown-img-paste-20190304020039736.png)

### Base Header Format

![](/assets/images/markdown-img-paste-20190304020105274.png)

|이름|설명|
|--|--|
|VER|버전|
|Traffic Class|IPv4의 Service Type과 동일(Reliable등), 잘안씀|
|Flow label|20bit, 소켓의 Flow (송수신 IP Port + Protocol)|
|Payload length|Total length와 유사|
|Next header|Extension 헤더나 Data도 가능|
|Hop limit|Hop count (TTL)|
|Source address|16byte|
|Destination address|16byte|

#### Next Header Codes

![](/assets/images/markdown-img-paste-20190304020507110.png)

### Extension Header Format
* 헤더 타입별로 포멧은 다름

![](/assets/images/markdown-img-paste-20190304020700523.png)

### Extension Header Types

![](/assets/images/markdown-img-paste-20190304020742569.png)

## Transition from IPv4 to IPv6
인터넷이 너무 크기 때문에 IPv4에서 v6로 바로 넘길 수는 없음


### Three Transition Strategies
#### Dual Stack
IPv4, IPv6 둘 다 지원 가능하게

![](/assets/images/markdown-img-paste-20190304021025190.png)

#### Tunneling

![](/assets/images/markdown-img-paste-20190304021045343.png)

#### Header Translation
헤더 자체를 바꿔서 통신

![](/assets/images/markdown-img-paste-20190304021110375.png)

# ICMPv6
## Introduction
ICMPv4와 기본적으로 비슷함. 하지만 ICPMv6에서 IGMP, ICMP, ARP가 합쳐져 ICMP가 됐음

![](/assets/images/markdown-img-paste-2019030402135988.png)

### ICMPv6

#### Error Messages
IPv4와 거의 유사
* Destination unreachable (=ICMPv4) : Type 1, Code 0 ~ 6

![](/assets/images/markdown-img-paste-20190304022005229.png)

* Packet too big (= Source quench) : Type 2, Code 0
* Time exceeded (=ICMPv4) : Type 3, Code 0 or 1
* Parameter problems (=ICMPv4) : Type 4, Code 0 ~ 2

#### Informational Messages
IPv4의 쿼리문
* Echo request/reply (=ICMPv4) : Type 128, 129, Code = 0

![](/assets/images/markdown-img-paste-20190304022159190.png)

#### Neighbor Discovery Message
ND (Neighbor Discovery) 프로토콜, IND (Inverse Neighbor Discovery) 프로토콜, IPv4의 ARP와 역할이 같음
* Router-Solicitation Message : 호스트가 라우터를 찾음, Type 133, Code 0
* Router-Advertisement Message : 라우터가 호스트에게 알려줌, Type 134, Code 0
* Neighbor-Solicitation Message : IP->MAC, Type 135, Code 0
* Neighbor-Advertisement Message : Type 136, Code 0
* Redirection Message : ICMPv4 쿼리의 Redirection, Type 137, Code 0
* Inverse-Neighbor-Solicitation Message : MAC->IP, Type 141, Code 0
* Inverse-Neighbor-Advertisement Message : Type 142, Code 0

#### Group Membership Message
MLD (Multicast Listener Discovery) 프로토콜, IPv4의 IGMP와 거의 비슷, 사이즈만 달라짐 (IPv6 쓰므로)
* Membership-Query Message : 라우터->호스트, Type 130, Code 0
* Membership-Report Message : 호스트->라우터, Type 143, Code X
