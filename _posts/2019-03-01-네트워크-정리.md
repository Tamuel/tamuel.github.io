---
title: "네트워크 정리"
date: 2019-03-01 18:16:30 -0400
categories: Networw
tags: Network
---
# 네트워크 정리

**Behrouz A. Forouzan "*TCP/IP Protocol Suite*" 참고**

# Introduction

## Brief History
네트워크란 커뮤니케이션 기기들의 그룹이라 볼 수 있고 Internet은 서로 커뮤니케이션 가능한 Network 들이라 볼 수 있음
![img01](/assets/images/markdown-img-paste-20190301183702843.png)

## Protocols and Standards
* Protocol(프로토콜) = Rule(규칙)
* Standards(표준) = 룰을 따르는 것


# The OSI Model and the TCP/IP Protocol Suite

## Protocol Layers
프로토콜은 두 개의 객체가 커뮤니케이션하는데 필요함 (서로 규칙이 맞아야 말이 통함), 만약 커뮤니케이션 방법이 어렵다면 각자 프로토콜을 가진 여러 레이어로 나눌 수 있음

* 커뮤니케이션이 간단할 경우
  ![img02](/assets/images/markdown-img-paste-20190301184122973.png)

* 어려울 경우
  ![img03](/assets/images/markdown-img-paste-20190301184158381.png)

## OSI Model
OSI(Open Systems Interconnection)이란 ISO(International Standards Organization)이 1970년대에 만든 네트워크 커뮤니케이션 표준

* OSI model을 이용한 데이터 교환
  * In-Capsulation : 데이터에 헤더를 붙여 패킷으로 만든 후 하위 레이어로 보냄
  * De-Capsulation : 데이터에서 헤더를 때면서 상위 레이어로 보냄
    ![img04](/assets/images/markdown-img-paste-20190301184825208.png)

* 물리 레이어(Physical Layer)는 각각의 bit를 하나의 노드에서 다른 노드로 옮겨줘야함

### OSI Layers 요약

|#|이름|주소|데이터단위|하는 일|
|-------|-----------|--|--|--|
|7|**Application**|Application Specific||네트워크 자원 접근 가능하게|
|6|Presentation|||데이터 해석, 암호화, 압축|
|5|Session||Message|Session 열기, 관리, 닫기|
|4|**Transport**|PORT (TCP/UDP) 2byte|Segment(TCP), User Datagram(UDP)|신뢰성 있는 **Process-to-Process** 메시지 전송과 에러 복구|
|3|**Network**|IP (Logical) 4byte(v4)/16byte(v6)|Datagram(패킷)|인터넷 작동을 위해 **패킷**을 목적지로 보냄|
|2|**Data Link**|Mac (Physical) 6byte|Frame|Hop-to-Hop 전송을 위해 비트들을 **프레임**으로 관리|
|1|**Physical**||Bit|**비트**를 매체(Medium)를 통해 전송, 기계적, 전자적 능력 필요|

## TCP/IP Protocol Suite
OSI 모델 보다 먼저 만들어짐

|Layer|Name|
|-------|-----------|
|Layer 5|Application|
|Layer 4|Transport|
|Layer 3|Network|
|Layer 2|Data Link|
|Layer 1|Physical|

### Physical Address
6바이트 16진수 주소를 가짐
* eg) 07:01:02:01:2C:4B
* 라우터를 지나면서(Hop-to-Hop) Mac 주소는 바뀌지만 Logical 주소와 Port 주소는 바뀌지 않음
  ![img05](/assets/images/markdown-img-paste-20190301191253987.png)


# Underlying Technology (Layer 1, 2)
레이어 1, 2는 Access가 목적이고 3, 4, 5는 네트워킹이 목적임

## LAN (wired Local Area Networks)
제한된 범위 (가정, 회사) 내에서 사용하는 네트워크, 독립된(Isolated) 네트워크 구성 가능, 최근 LAN은 WAN(Wide Area Network)나 인터넷에 연결됨, 주로 Ethernet(이더넷) 사용
* 이더넷을 주로 사용하나, Token ring, Token bus, FDDI, ATM LAN 등도 존재

![img06](/assets/images/markdown-img-paste-20190301192155477.png)
![](/assets/images/markdown-img-paste-2019030121160800.png)
![](/assets/images/markdown-img-paste-20190301211637562.png)

* 이더넷 주소는 6bytes 사용
  ![](/assets/images/markdown-img-paste-20190301211743623.png)

* 첫 바이트 마지막 자리가 0이면 유니캐스트 (1:1 통신), 1이면 멀티캐스트 (1:N 통신)
  ![](/assets/images/markdown-img-paste-20190301211818904.png)

* 모든 비트가 1 이면 브로드캐스트(Broadcast, 1:ALL)
  * FF:FF:FF:FF:FF:FF


## Wireless Lans
IEEE 802.11 무선랜 (무선 이더넷), 블루투스
![](/assets/images/markdown-img-paste-20190301212635452.png)

## Point-to-Point Wans
Point-to-Point Wide Area Network. WAN은 떨어져 있는 두 기기를 공공 네트워크 선(모뎀 등)으로 이어줌
* DSL, Cable 모뎀, T-line, SONET 등 있음

## Switched Wans
인터넷의 백본 네트워크는 스위치 WAN임. 넓은 영역을 커버하고 몇 포인트에 유저가 접근하는걸 제공해줌. 포트가 여러 개라 여러 입력과 출력을 낼 수 있음

## Connecting Devices
LAN과 WAN들은 보통 떨어져있지 않고 같이 연결되거나 인터넷에 연결되어 사용됨.
* Repeaters (HUB) : 자신에게 온 모든 데이터를 전달하고 (필터링 기능 없음) 증폭기 역할도 함
* Bridges (Two-layer switches) : 테이블이 있어 필터링 가능, 프레임의 물리 주소를 바꾸지 않음
  * Multi Port Bridge = Switch
* Routers (Three-layer switches) : 세개의 레이어(Network, Data Link, Physical)를 가진 기기
  * 라우터는 패킷의 물리 주소(MAC)를 바꿈
* Repeater와 Bridge는 LAN의 세그먼트를 연결해주고, 라우터는 LAN이나 WAN을 서로 연결해줌 (Internetwork)
  ![](/assets/images/markdown-img-paste-20190301213427609.png)


# Introduction to Network Layer

## Introduction
인터넷을 블랙박스라 생각하고, 여기서는 컴퓨터 두 대가 서로의 어플리케이션 레이어끼리의 메시지를 준다고 생각
![](/assets/images/markdown-img-paste-20190301214233753.png)

* 인터넷은 LAN들과 WAN들의 연결이라 생각하면 됨
  ![](/assets/images/markdown-img-paste-20190301214513291.png)


## Switching
만약 메시지가 길을 따라 가다가 연결기기(Connecting device)를 만나면 그 기기가 어디 출력 포트로 보낼지 선택을 해야함. 연결기기가 스위치로서 작동한다고 보면됨

### Circuit Switching
전체 메시지가 패킷으로 나누어지지 않고 출발지(Source)에서 목적지(Destination) 까지 전송됨
* 초기 전화 시스템 생각하면됨

### Packet Switching
메시지가 먼저 관리가 용이한 패킷들로 나뉜 다음 목적지로 전송됨. 목적지에 도착하면 다시 합쳐짐


## Packet Switching
네트워크 레이어(레이어3)은 패킷 스위치 네트워크로 디자인됨. 패킷들을 나눈다고 했는데, 이 패킷들을 **"데이터그램(Datagram)"** 이라 부름. 데이터그램은 목적지에 도착하면 다시 재조립됨. 과거에는 보통 Packet-switched network layer의 경우 Connectionless 서비스로 개발되었지만 최근에는 Conneection-oriented 서비스인 경우가 종종 있음

### Connectionless packet-switched network
  * UDP의 경우
  * 순서가 보존되지 않음 (따로 관리 안함)
  * 속도가 빠름
    ![](/assets/images/markdown-img-paste-20190301215658466.png)

  * Forwarding process in a Connectionless Network
    * Forwarding (포워딩) : 다음 HOP으로 전송하는 것
    * Routing (라우팅) : Ent-to-End 전송
    * 라우터에서 테이블 룩업 후 도착지 주소(Destination address)에 해당하는 인터페이스(포트)를 통해 전송
      ![](/assets/images/markdown-img-paste-20190301215836908.png)

  * Delay in a connectionless network
    * Delay variation(Jitter)이 있어 버퍼링을 함 (편차 상쇄)
      ![](/assets/images/markdown-img-paste-2019030122010750.png)

### Connection-oriented packet-switched network
  * TCP의 경우
  * 순서가 보존됨 (따로 순서와 전송 등을 관리하기 때문)
  * 속도가 UDP 보단 느림
    ![](/assets/images/markdown-img-paste-20190301220257969.png)

  * 포워딩이 도착지 주소가 아닌 패킷의 "라벨"에 따라 이루어짐
    ![](/assets/images/markdown-img-paste-2019030122052996.png)

  * Sending request packet in a virtual-circuit network
    * 마치 전선(길)이 있는 것 처럼 데이터 전송
    * Signaling으로 미리 가상의 길을 만든 후 전
      ![](/assets/images/markdown-img-paste-20190301220646146.png)

  * Delay in a connection-oriented network
    * Setup과 Teardown시 시간이 걸리긴 하지만 전송중 딜레이는 더 적음 (테이블 그때마다 찾아보지 않아도되기 때문)
      ![](/assets/images/markdown-img-paste-20190301221518441.png)

## Network Layer Services

### Services provided at the source computer
  ![](/assets/images/markdown-img-paste-20190301221846187.png)

### Processing at each router
  ![](/assets/images/markdown-img-paste-20190301222047571.png)

### Processing at the destination computer
  ![](/assets/images/markdown-img-paste-20190301222151906.png)


# IPv4 Addresses
IP(Network) 레이어에서 인터넷에 연결된 각 기기를 구분하기 위해 부르는 주소를 **IP주소** 라 한다.
IPv4 주소의 경우 32bit (4byte) 주소를 사용. 인터넷의 Host나 Router를 고유하게 구분하기 위해 사용.
IP 주소는 인터페이스의 주소임

* 32bit 이므로 $2^{32}$개의 주소를 가질 수 있음
* 10진수 사용 eg) 255.124.0.125.

## Classful Addressing
처음 IPv4를 만들 때는 클래스라는 컨셉을 썻음. 1990년대 중반부터 Classless 사용.

![](/assets/images/markdown-img-paste-2019030122333730.png)

* NetID, HostID
  * Netid는 할당해주고 Hostid는 할당 받은 기관이 마음대로 사용
  * A, B 클래스는 너무 많이 낭비됨
  * C 클래스는 너무 적음
  * D 클래스는 통신 할 때만 사용
  * IPv4는 거의 다 할당 됨
    ![](/assets/images/markdown-img-paste-20190301223502121.png)

* 샘플 인터넷
  ![](/assets/images/markdown-img-paste-20190301223819433.png)

* Network address (NetID)는 네트워크의 구분자(Identifier)
  * 라우팅 테이블에 모든 주소가 있는 것이 아니라 NetID들이 있음
    ![](/assets/images/markdown-img-paste-2019030122394633.png)

* Subnetwork mask
  * NetID, SubnetID, HostID로도 구분 가능 (서브넷은 적절히 크기 정함)
    ![](/assets/images/markdown-img-paste-2019030214495810.png)

* Supernet mask도 존재

## Classless Addressing
서브넷, 슈퍼넷을 통해서도 주소 고갈문제를 해결 할 수는 없음. IPv6로 많은 주소 제공도 있지만, 그 전에 같은 주소 공간을 쓰지만 분포를 다르게 해서 각 기관이 공평하게 쓰는 방법이 있고 이를 IPv4를 이용한 **Classless addressing** 방법이라함

* Classless Addressing에서는 접두사(Prefix)는 네트워크를 정의하고, 집미사(Suffix)는 호스트를 정의
  * 접두사는 1에서 32비트까지 쓰임
    ![](/assets/images/markdown-img-paste-20190302145651802.png)

* Classless는 어디까지가 NetworkID인지 따로 알려줘야함
  * 아래에서 n이 접두사의 길이를 뜻함
    * byte.byte.byte.byte/n

* Subnet 잘못 지정시 다른 주소의 NetworkID와 겹침

## Special Addresses
* 0.0.0.0 : 주소를 모를 때 (DHCP에서 처음에 주소를 얻어올 때)
* 255.255.255.255 : Broadcast 주소 (모든 네트워크)
  * 라우터는 Broadcast가 목적지인 패킷을 막음 (해당 라우터 이내에서만 가도록)
* 127.x.y.z : 컴퓨터 내부 프로세스 간 통신 (밖으로 나가지 않음)
* 개인용 네트워크 (공유기)

  |Block|Number of addresses|
  |:----:|:----:|
  |10.0.0.0/8|16,777,216|
  |172.16.0.0./12|1,047,584|
  |192.168.0.0./16|65,536|
  |169.254.0.0./16|65,536|

* Directed Broadcast
  * 네트워크가 221.45.71.0/24 일 경우 라우터에서 221.45.71.255/24(HostID 비트가 모두 1)로 패킷을 보내면 해당 네트워크로 브로드캐스팅함

## NAT
NAT (Network Addres Translation), 공유기라고 생각하면됨 Public 주소 패킷을 받아 Translation Table을 보고 Private 주소로 변환해서 넘겨줌
![](/assets/images/markdown-img-paste-20190302161626536.png)
![](/assets/images/markdown-img-paste-2019030216171290.png)

# Delivery and Forwarding of IP Packets

## Delivery
네트워크 레이어는 패킷 전송을 담당해야함. 목적지까지 패킷을 전송하는 방법은 크게 **Direct** 와 **Indirect** 두 방법이 있음

### Direct Delivery
한 네트워크 안에서 패킷 전송 (네트워크 내의 기기끼리 혹은 네트워크 담당 라우터에서 기기까지)
![](/assets/images/markdown-img-paste-20190302162450901.png)

### Indirect Delivery
라우터를 거치면서 패킷 전송
![](/assets/images/markdown-img-paste-2019030216233979.png)


## Forwarding
라우터 내의 패킷을 패킷의 목적지로 보내는 것 (Deliver to the next Hop)
* Route를 모두 보거나 (Full route), 다음 Hop 만 봄, IP Router는 Next HOP 만 봄
  ![](/assets/images/markdown-img-paste-20190302162726729.png)

### Network-specific routing
  * 네트워크 단위로 보기 때문에 좀 더 간소함
    ![](/assets/images/markdown-img-paste-20190302162903672.png)

### Host-specific routing
  * DNS 같은 경우 예외로 Host specific 쓰기도 함
    ![](/assets/images/markdown-img-paste-20190302163027895.png)

### Default routing
  * 테이블에 따로 명시되지 않은 Route는 Default로 감
  * 보통 PC는 Default 만 가지기도 함
    ![](/assets/images/markdown-img-paste-20190302163307324.png)

### Classful Addressing에서 Routing
* Net
  ![](/assets/images/markdown-img-paste-2019030216344187.png)
* Subnet
  ![](/assets/images/markdown-img-paste-20190302163525278.png)
* 위에서 Interface Number는 라우터 슬롯의 맥주소임
* Classful Addressing에서는 3열로 테이블 표현 가능하지만 Classless일 경우 Prefix까지 합쳐 4열로 표현
  ![](/assets/images/markdown-img-paste-20190302163753157.png)

### Longest mask matching
테이블에서 중복되는 주소가 있을 시 가장 길게 매칭되는 쪽으로 감
  ![](/assets/images/markdown-img-paste-20190302164531537.png)

* Hierarchical routing with ISPs
  * 계층적 구조를 가지고 라우팅 가능
* 목적지 주소로 라우팅
* 라벨을 기반으로 라우팅

## Structure of A Router (라우터 구조)
* Router Components
  ![](/assets/images/markdown-img-paste-20190302164944261.png)
* Input Port
  ![](/assets/images/markdown-img-paste-20190302165020261.png)
* Output Port
  ![](/assets/images/markdown-img-paste-20190302165043913.png)
* Banyan switch
  ![](/assets/images/markdown-img-paste-20190302165202806.png)
* Batcher-banyan switch
  ![](/assets/images/markdown-img-paste-20190302165225207.png)



# IPv4 (Internet Protocol Version 4)

## Introduction
Internet Protocol은 네트워크 레이어에서 TCP/IP 프로토콜이 사용하는 전송 매커니즘
![](/assets/images/markdown-img-paste-20190302165646358.png)

## Datagrams
네트워크 레이어의 패킷을 **Datagram** 이라고 함. "**헤더**"와 "**데이터**"로 이루어져 있음
* 헤더 : 20 ~ 60 바이트로 라우팅과 전송에 필요한 필수 정보를 가짐

### IP Datagram 헤더 구조
![](/assets/images/markdown-img-paste-2019030217005508.png)

|이름|역할|
|----|----|
|VER|버전, IPv4일 경우 0100|
|HLEN|헤더 길이, 단위는 word(4byte), 최소 5이상 (20byte)이상 이어야 정상, 아니면 무시|
|Service type|Real Time, Reliable 등의 패킷 타입 명시 (요즘은 사용 안함), 앞의 6비트만 사용, XXXXX0는 인터넷, XXXX11은 로컬, XXXX01은 임시 혹은 실험용|
|Total length|헤더+데이터 총 길이, 단위는 byte|
|Identification|패킷 ID, Fragmentation 후에도 같은 패킷인지 인식 위해|
Fragmentation offset|바이트/8, 시작 지점으로 부터 얼마나 떨어져 있는지, 175의 경우 시작이 1400byte라는 말|
|Flags|3bit는 [0DM]으로 볼 수 있음, D는 Fragment하면 안됨, M은 Fragment가 더 있음을 의미, 001의 경우 뒤에 패킷이 더 있다는 의미|
|Time to live (TTL)|Hop Count라고도 하며 몇 HOP갈 것인지, 보통 255,128,64|
|Protocol|TCP(6), UDP(17) 기타 등등|
|Header checksum|헤더의 Corruption체크 (정보 손상이 있는지)|
|Source IP address|송신지 주소 (4byte)|
|Destination IP address|수신지 주소 (4byte)|
|Options+Padding|기타|

### Encapsulation of a small datagram in an Ethernet frame
![](/assets/images/markdown-img-paste-20190302171300892.png)

### Multiplexing
* ICMP (1) : Internet Control Message Protocol
* IGMP (2) : Internet Group Management Protocol (Multicast)
* TCP (6) : Transmission Control Protocol
* UDP (17) : User Datagram Protocol
* OSPF (89) : Open Shortest Path First Routing Protocol
![](/assets/images/markdown-img-paste-20190302171359627.png)

## Fragmentation
패킷을 나눔

### MTU (Maximum Transfer Unit)
망에서 지원하는 최대 패킷 사이즈
* Datagram이 왔을 경우 MTU로 사이즈로 나눠서(Fragmentation) 전송
* 오직 data만 나눔 (헤더를 나눌수는 없음)

### Fragmentation 예제
![](/assets/images/markdown-img-paste-20190302173136294.png)

## Options
헤더 20바이트는 앞의 기본 헤더이고 + 40바이트까지 옵션을 설정 가능. 네트워크 테스팅과 디버깅시 사용. 헤더에 꼭 필요하진 않음
* TLV 포맷
![](/assets/images/markdown-img-paste-20190302174804445.png)
![](/assets/images/markdown-img-paste-20190302174847884.png)

|Operation|설명|
|---|---|
|No operation|Padding 용 (4의 배수 byte로 끝나게)|
|End of option|옵션 끝 알림|
|Record route|루트 기억 (총 9개)|
|Strict source route|수신자가 루트를 정해주고, 갈 수 없다면 버림|
|Loose source route|수신자가 루트를 정해주고 웬만하면 따라가게함|
|Timestamp|보낸 시간|

## Checksum
TCP/IP 프로토콜에서 에러 검출 방법을 Checksum이라함. 전송 중 패킷 손상을 방지함. 수신자가 헤더에 대해서 계산을 해서 결과가 만족되면 패킷을 받아들임
* Checksum은 헤더만을 관리하고, Data는 하지 않음 (TCP가 관리)
![](/assets/images/markdown-img-paste-20190302175547556.png)
* 1의 보수 방법
![](/assets/images/markdown-img-paste-2019030217560283.png)

## IP Components
![](/assets/images/markdown-img-paste-20190302175900108.png)


# ARP (Address Resolution Protocol)
주소를 알아오는 프로토콜

## Address Mapping
논리적(Logical), 물리적(Physical) 주소들 끼리 맵핑이 필요함. 정적(Static) 맵핑과 동적(Dynamic) 맵핑 존재. IP 데이터그램에는 목적지의 논리적 주소만 존재함. 하지만 데이터그램은 물리적 네트워크를 통과하기 위해 Encapsulation을 통해 프레임으로 변환되어야 함. 그 말인즉 송신자가 수신자의 물리 주소를 알아야한다는 말. **ARP** 는 IP 프로토콜로 부터 논리 주소를 받고 해당 주소를 물리 주소와 맵핑한 다음 데이터 링크 레이어로 보냄
![](/assets/images/markdown-img-paste-20190302180504154.png)

### ARP Operation
Subnet안에서 브로드캐스트로 ARP Request를 보내면 해당하는 기기에서 물리주소를 채워넣은 다음 다시 보낸 기기로 유니캐스트로 돌려보냄
![](/assets/images/markdown-img-paste-20190302180600914.png)
![](/assets/images/markdown-img-paste-20190302180608362.png)

### ARP Packet
![](/assets/images/markdown-img-paste-20190302180753324.png)

### ARP Packet Encapsulation
![](/assets/images/markdown-img-paste-20190302180852195.png)

### 4가지 케이스
1. 같은 네트워크 상에서 한 호스트가 다른 호스트로 패킷 보낼 경우
  * 타겟 주소는 IP 데이터그램의 목적지 주소
2. 호스트가 다른 네트워크의 호스트로 패킷을 보낼 경우
  * 타겟 주소는 라우터의 IP 주소
3. 라우터가 다른 네트워크의 호스트로 패킷을 보낼 경우
  * 타겟 주소는 다른 라우터의 IP 주소
4. 라우터가 같은 네트워크의 호스트에게 패킷을 보낼 경우
  * 타겟 주소는 IP 데이터그램의 목적지 주소


## ARP Package
![](/assets/images/markdown-img-paste-2019030218153037.png)


# ICMPv4 (Internet Control Message Protocol version 4)
IP의 컨트롤을 보완. IP 프로토콜은 기본적으로 에러 보고나, 에러를 보정하는 매커니즘이 없음.
![](/assets/images/markdown-img-paste-20190302182107708.png)

### ICMP Encapsulation
![](/assets/images/markdown-img-paste-20190302182153337.png)

## Messages
크게 **에러 보고 메시지 (Error-reporting messages)** 와 **쿼리 메시지 (Query messages)** 로 나눌 수 있음. 에러는 목적지를 가기전 라우터나 목적지 호스트가 IP 패킷을 처리하는데 문제가 발생했을 경우 전송. 쿼리 메시지는 호스트나 네트워크 관리자가 다른 라우터나 호스트의 정보를 얻기 위해 사용
* ICMP는 항상 송신자(Original source)에게 에러 메시지를 보고함

### ICMP Messages

|Category|Type|Message|
|---|:--:|:--|
|에러 보고 메시지|3|Destination unreachable, 목적지 도달 불가|
|^|4|Source quench, 송신자에게 그만 전송하라고 연락 (목적지 호스트가 너무 혼잡할 때), 데이터그램 하나마다 메시지 하나씩 전송|
|^|11|Time exceeded, 시간 초과, 라우터가 TTL 값을 0으로 줄이면 소스에 메시지 전송, 수신자가 시간 안에 Fragment들을 다 받지 못하면 메시지 전송|
|^|12|Parameter problem, 헤더 문제 (원인도 함께 보내줌)|
|^|5|Redirection, 호스트와 같은 네트워크 내의 라우터가 다른 라우터로 보낸다고 연락, 호스트 라우팅 테이블 업데이트 시 사용 가능|
|쿼리 메시지|8 or 0|Echo request or reply, Ping 보냄, Echo Request 받은 호스트나 라우터는 Echo Reply 메시지를 다시 보냄|
|^|13 or 14|Timestamp request or reply, 걸린 시간 측정, 두 기기 사이의 시간 동기화 시 사용 가능|

### ICMP Message Format
![](/assets/images/markdown-img-paste-20190302184631328.png)

## Debugging Tools
* PING : Echo request and reply
* Traceroute : HOP 순서 알아볼 수 있음

## ICMP Package
![](/assets/images/markdown-img-paste-2019030219014035.png)


# Mobile IP

## Addressing

### Stationary Host (고정된 호스트)
IP 주소는 기본적으로 고정된 호스트를 가정하고 디자인됨. 주소의 일부는 어디 네트워크에 어떤 호스트가 붙은지 나타내기 때문

### Home address and Care-of address
모바일 IP는 영구적인 Home address와 호스트에 따라 바뀔 수 있는 Care-of address 둘 다 가짐

## Agents
모바일 호스트와 Foreign 에이전트가 같다면 Care-of 주소를 Colocated care-of 주소로 불림
![](/assets/images/markdown-img-paste-20190302190531657.png)

## Three Phases
원격 호스트와 커뮤니케이션을 위해 모바일 호스트는 : **에이전트 발견 (Agent discovery)**, **등록 (Registration)**, **데이터 전송 (Data transfer)** 세 단계를 거친다.
* 모바일 호스트가 이동더라도 나머지 인터넷에 무관함 (Transparent)

### Agent Discovery
에이전트가 어디 있는지 파악
* ICMP 쿼리 메시지의 Router advertisement, Router solicitation 메시지 사용
* Agent solicitation : 에이전트가 어디있는지?
* Agent advertisement : 에이전트 응답

### Registration
Care-of 주소를 Home 에이전트에게 알려줌
* UDP well-known 434포트를 이용해 전송
* Registration request : Home 에이전트에 등록 요청
* Registration reply : Home 에이전트에 등록

### Data Transfer
데이터 전송

![](/assets/images/markdown-img-paste-20190302191036922.png)
![](/assets/images/markdown-img-paste-20190302191757124.png)

## Inefficiency in Mobile IP
더블 크로싱 (Double crossing) 이라는 심각한 문제와, 삼각 라우팅 (Triangle routing) 이라는 덜 문제가 있음

### Double Crossing
같은 네트워크 안인데 먼길을 거쳐와야 함
![](/assets/images/markdown-img-paste-20190302192120368.png)

### Triangle Routing
꼭 홈 에이전트를 거쳐와야 함
![](/assets/images/markdown-img-paste-20190302192201729.png)


# Unicast Routing Protocols

## Inter and Intra Domain Routing
인터넷이 너무 크기 때문에 라우팅 프로토콜이 모든 라우터의 테이블을 관리하기는 힘들어 **AS**(Autonomous system)들로 인터넷이 나누어짐. AS는 하나의 기관이 운영하는 네트워크나 라우터의 그룹. AS 안의 라우팅을 **Intra-domain** 라우팅이라 하고, AS끼리의 라우팅을 **Inter-domain** 라우팅이라 함 (AS를 Domain이라 볼 수 있음)
![](/assets/images/markdown-img-paste-20190302192754890.png)

## 라우팅 프로토콜들
가장 짧은 길을 알기 위한 프로토콜들
![](/assets/images/markdown-img-paste-20190302192856184.png)

### RIP (Routing Information Protocol)
[베르만포드 알고리즘](https://tamuel.github.io/algorithm/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%A0%95%EB%A6%AC/#) 사용, 인접한 곳만 알면 됨
* Intra-domain 용
* Distance vector routing = 베르만포드 사용
* UDP well-known 520 포트 사용
* 3개의 타이머 사용

|Timer|하는일|
|--|--|
|Periodic|주고 받는 간격|
|Expiration|유효 기간|
|Garbage collectipn|에러|

### OSPF (Open Shortest Path First)
[다익스트라](https://tamuel.github.io/algorithm/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%A0%95%EB%A6%AC/#) 사용, 망을 다 알 경우
* Intra-domain 용
* Link state routing = 다익스트라 사용
* OSPF 패킷은 IP 데이터그램에 Encapsulation됨 (Multicast)
* Link 종류
  붉은색은 라우터, 푸른색은 이더넷
  * Point-to-Point
    ![](/assets/images/markdown-img-paste-20190302194833622.png)
  * Transient
    ![](/assets/images/markdown-img-paste-20190302194852822.png)
  * Stub
    ![](/assets/images/markdown-img-paste-20190302194907486.png)
  * Virtual

### Path Vector Routing
Distance vector 라우팅은 Hop이 많으면 불안정하고 Link state 라우팅은 Hop이 많으면 자원소모가 너무 심함. Reachability를 고려하기 위해 라우팅 테이블을 합쳐줌
![](/assets/images/markdown-img-paste-20190302195812345.png)
![](/assets/images/markdown-img-paste-20190302195940367.png)

### BGP (Border Gateway Protocol)
Path Vector Routing을 이용하여 AS 사이에 라우팅을 담당한다
* TCP 179 포트 사용 (신뢰성 보장)
* E-BGP : AS와 AS간 BGP 라우팅
* I-BGP : AS내에서 BGP 정보 교환

### CIDR (Classless Inter-Domain Routing)

# Multicasting and Multicast Routing Protocols

## Unicasting
1:1 통신, 하나의 호스트에서 다른 하나의 호스트로 패킷 전송
* 라우터는 받은 데이터그램을 하나의 인터페이스로만 전송

## Multicasting
1:N 통신, 가입 필요, Class D
* 라우터는 받은 데이터그램을 여러개의 인터페이스로 전송

## Multicasting vs. Multiple unicasting
멀티캐스팅은 동시에 패킷을 전송하지만, 유니캐스트는 패킷을 복제한 후 뿌려줌
* 멀티캐스트 - 딜레이가 비슷함 (실시간 방송 등)
* 유니캐스트 - 딜레이가 다름
![](/assets/images/markdown-img-paste-20190302201734671.png)

## Multicast Addresses
멀티캐스트 주소란, 멀티캐스트 그룹에 포함된 호스트들의 주소를 뜻한다

|CIDR|Range|Assignment|
|--|--|--|
|224.0.0.0/24|224.0.0.0 ~ 224.0.0.255|Local Network Control Block|
|224.0.1.0/24|224.0.1.0 ~ 224.0.1.255|Internetwork Control Block|
||224.0.2.0 ~ 224.0.255.255|AD HOC Block|
|224.1.0.0/16|224.1.0.0 ~ 224.1.255.255| ST(Stream) Multicast Group Block|
|224.2.0.0/16|224.2.0.0 ~ 224.2.255.255|SDP/SAP Block|
||224.3.0.0 ~ 231.255.255.255|Reserved|
|232.0.0.0/8|232.0.0.0 ~ 232.255.255.255|Source Specific Multicast(SSM)|
|233.0.0.0/8|233.0.0.0 ~ 233.255.255.255|GLOP Block|
||234.0.0.0 ~ 238.255.255.255|Reserved|
|239.0.0.0/8|239.0.0.0 ~ 239.255.255.255|Administratively Scoped Block|

### Local Network Control Block

|Address|Assignment|
|--|--|
|224.0.0.0|Base address (reserved)|
|224.0.0.1|All systems (호스트나 라우터들) on this network|
|224.0.0.2|All routers on this network|
|224.0.0.4|DMVRP routers|
|224.0.0.5|OSPF routers|
|224.0.0.7|ST (Stream) routers|
|224.0.0.8|ST hosts|
|224.0.0.9|RIP2 routers|
|224.0.0.10|IGRP routers|
|224.0.0.11|Mobile Agents|
|224.0.0.12|DHCP servers|
|224.0.0.13|PIM routers|
|224.0.0.14|RSVP encapsulation|
|224.0.0.15|CBT routers|
|224.0.0.22|IGMPv3|

### Mapping Class D to Physical address
이더넷 멀티캐스트 물리 주소는 01:00:5E:00:00:00 ~ 01:00:5E:7F:FF:FF 까지임
* 01:00:5E는 기관명 (정해져 있음)
* 7F인 이유는 23비트 사용하기 때문
![](/assets/images/markdown-img-paste-20190302203415885.png)

### Tunneling
멀티캐스트 전송중 멀티캐스트 지원이 안되면 앞에 헤더를 붙여 유니캐스트로 변환해서 전송
![](/assets/images/markdown-img-paste-2019030220361592.png)


## IGMP (Internet Group Management Protocol)
멀티캐스트 통신은 멀티캐스트 그룹에 포함된 호스트에 패킷을 전송하는 것이므로 멀티캐스트 라우터는 로얄(Loyal) 멤버가 어디 인터페이스에 연결되어 있는지 알아야함. 이를 위해 지역적(Locally)으로는 **IGMP 프로토콜** 을 사용하고, 전역적(Globally)이게는 **Multicast Routing Protocol** 사용
* IGMP는 멀티캐스트 라우터가 각 인터페이스에 연관된 로얄 멤버에 대해서 리스트를 만들고 업데이트하는 것을 도와줌
![](/assets/images/markdown-img-paste-20190302203915893.png)

### IGMP Messages
라우터와 호스트간 메시지
* 소캣 레코드 중 하나라도 바뀐다면 인터페이스 상태(State)도 바뀜
![](/assets/images/markdown-img-paste-20190302204259261.png)
* Membership query : 라우터에서 호스트로
![](/assets/images/markdown-img-paste-20190302204530686.png)
* Membership report : 호스트에서 라우터로 (있다고만 보고), 리포트가 먼저 갈 수도 있음
![](/assets/images/markdown-img-paste-20190302204714614.png)

### Socket State
![](/assets/images/markdown-img-paste-20190302205906508.png)

### Sending change state report
![](/assets/images/markdown-img-paste-20190302210943189.png)

### Interface State
226.14.5.2에서 Exclude = {a, b, c}, {b, c, g}, Include = {a, b, d, e} 이므로, Exclude - Include = {c}. 228.24.21.4에서 Include = {b, c, f}, {d, e, f} 이므로  Include = {b, c, d, e, f}
* 226.14.5.2 마지막이 Exclude 이므로 Exclude 필터
* 228.24.21.4 마지막이 Include 이므로 Include 필터
![](/assets/images/markdown-img-paste-20190302205154302.png)

### Router State
![](/assets/images/markdown-img-paste-20190302205348606.png)

## Multicast Routing
Optimal Routing: Shortest Path Trees
* 멀티캐스트 라우팅에서 라우터는 각 그룹에 대한 최단 거리 트리를 만들어야함
![](/assets/images/markdown-img-paste-20190302211332846.png)

### Source-based Tree Approach
각 라우터가 각 그룹에 대해 하나씩 최단 거리 트리를 가져야함
  * Membership이 바뀌거나 Session이 끝날 때마다 계속 바뀜

![](/assets/images/markdown-img-paste-20190302211644357.png)

### Group-shared Tree Approach
각 그룹의 최단 거리 트리를 가진 코어 라우터가 멀티캐스팅에 참여
  * 소스 상관없이 일단 Core로 다 모음

![](/assets/images/markdown-img-paste-20190302211919870.png)

## Routing Protocols
Tree 구성이 목적인 프로토콜
* MOSPF : Multicast extention to [OSPF](#ospf-open-shortest-path-first)
* DVMRP : Distance Vector Muiticast Routing Protocol [RIP](#rip-routing-information-protocol)와 유사
* PIM : Protocol Independent Multicast
  * DM : Dense Mode
  * SM : Sparse Mode
* CBT : Core Base Tree

![](/assets/images/markdown-img-paste-20190302222836616.png)

### RPF, RPB, RPM
* RPF : Reverse Path Forwading, Flooding process에서 루프를 없앰
  * 하지만 목적지에서 동일한 패킷 여러개를 받을 수도 있음
* RPB : Reverse Path Broadcasting, 소스에서 각 목적지까지 Shortest path broadcast tree 만듬
  * 목적지마다 하나의 패킷만 받게 해줌
* RPM : Reverse Path Multicasting, RPB에 가지치기(Pruning)과 접붙이기(Grafting) 추가
  * Dynamic membership change를 제공해줌
* 간단한 순서
  1. 우선 소스에서 브로드캐스팅
  2. 아랫단에서 판단 (RPF)
  3. Pruning
![](/assets/images/markdown-img-paste-20190302224218312.png)

### Group-shared tree with rendezvous router
소스 상관없이 Tree 공유 (랑데뷰 혹은 코어 라우터라고 함)
![](/assets/images/markdown-img-paste-2019030222514539.png)

#### CBT의 경우
소스가 멀티캐스트 패킷(유니캐스트 패킷으로 터널링된)을 코어 라우터로 보내면 코어 라우터가 패킷을 Decapsulate한 다음 알맞은 인터페이스로 뿌려줌

#### PIM-DM
RPF + [Pruning, Grafting] 사용, LAN 같은 Dense 멀티캐스트 환경에서 사용
* 유니캐스트 프로토콜에서 독립적

#### PIM-SM
WAN 같은 Sparse 멀티캐스트 환경에서 사용
* CBT와 유사하지만 더 간단함

## MBONE
멀티캐스트 라우터를 쓰지 않고, 유니캐스트 라우터 사이에 논리적 터널을 만듬


# Introduction to Transport Layer
* **UDP** : User Datagram Protocol
* **TCP** : Transmission Control Protocol
* **SCTP** : TCP 개선 (TCP 장점 + UDP 장점)
* **DCCP** : Datagram Congestion Control Protocol (UDP + Congestion control)
![](/assets/images/markdown-img-paste-20190302230035604.png)

## Process-to-Process Communications
* Network 레이어 : Host-to-Host (IP)
* Transport 레이어 : Process-to-Process (IP + Port)
* 소캣 주소 = IP 주소 + Port
* IP 주소 : Host 선택
* Port 번호 : Process 선택

## Port
16비트로 이루어짐 0 ~ 65535
* Well-known : 0 ~ 1023
* Registered : 1024 ~ 49151
* Dynamic or Private : 49152 ~ 65536


# UDP(User Datagram Protocol)
Application 프로그램과 Network 레이어 사이에서 데이터 전송

## User Datagram
UDP 패킷을 User Datagram이라 함. 헤더는 8 바이트
![](/assets/images/markdown-img-paste-20190302231152547.png)

## UDP Service

### UDP에서 Well-known

|Port|Protocol|Description|
|:--:|--|--|
|7|Echo|Echoes a received datagram back to the sender|
|9|Discard|Discards any datagram that is received|
|11|Users|Active users|
|13|Daytime|Returns the date and the time|
|17|Quote|Returns a quote of the day|
|19|Chargen|Returns a string of characters|
|53|Nameserver|Domain Name Servcie|
|67|Bootps|Server port to download bootstrap information|
|68|Bootpc|Client port to download bootstrap information|
|69|TFTP|Trivial File Transfer Protocol|
|111|RPC|Remote Procedure Call|
|123|NTP|Network Time Protocol|
|161|SNMP|Simple Network Management Protocol|
|162|SNMP|Simple Network Management Protocol(Trap)|

### Simple Checksum 계산
![](/assets/images/markdown-img-paste-20190302231626230.png)

### Encapsulation / Decapsulation
![](/assets/images/markdown-img-paste-20190302231727733.png)

### Queues in UDP
각 포트마다 큐를 가짐
![](/assets/images/markdown-img-paste-20190302231757172.png)

### Multiplexing / Demultiplexing
![](/assets/images/markdown-img-paste-20190302231848981.png)

## UDP Application
* DNS : 클라이언트가 짧은 요청을 보내고 빨리 응답을 받아야 하기 때문
* SMTP 같이 큰 데이터가 있는 패킷을 UDP로 보낼 수는 없음, 받을 때 순서가 고려되지 않고 중간에 손실 가능하기 때문

## UDP Package
![](/assets/images/markdown-img-paste-20190302232325349.png)

### Control Block Table

|State|Process ID|Port Number|Queue Number|
|--|:--:|:--:|:--:|
|IN-USE|2345|52010|34|
|IN-USE|3422|52011||
|FREE||||
|IN-USE|4652|52012|38|
|FREE||||


# TCP (Transmission Control Protocol)

## TCP Services
### Well-known Port TCP

|Port|Protocol|Description|
|:--:|--|--|
|7|Echo|Echoes a received datagram back to the sender|
|9|Discard|Discards any datagram that is received|
|11|Users|Active users|
|13|Daytime|Returns the date and the time|
|17|Quote|Returns a quote of the day|
|19|Chargen|Returns a string of characters|
|20 and 21|FTP|File Transfer Protocol (Data and Control)|
|23|TELNET|Terminal Network|
|25|SMTP|Simple Mail Transfer Protocol|
|53|DNS|Domain Name Server|
|67|BOOTP|Bootstrap Protocol|
|79|Finger|Finger|
|80|HTTP|Hypertext Transfer Protocol|

### Stream delivery
바이트의 흐름이라 생각하면됨
![](/assets/images/markdown-img-paste-20190302232949463.png)

### Sending and Receiving Buffers
Circular Linked List Queue로 버퍼 생성
* 송신자는 수신자가 제대로 받았는지 확인하고 보내기위해 버퍼 사용
* 수신자는 스트림을 계속해서 순서대로 받기 위해 버퍼 사용

![](/assets/images/markdown-img-paste-20190302233028210.png)

### TCP Segment
보통 1024바이트로 나눔 (Segmentation)
![](/assets/images/markdown-img-paste-20190302233201617.png)


## TCP Features

### Numbering System
각 연결에서 보내려는 데이터의 바이트는 TCP에 의해 번호가 매겨짐, 시퀀스 넘버 (Sequence number)는 현재 세그먼트에 들어있는 첫 바이트의 숫자라 생각하면됨
* 각 넘버링은 임의의 수로 시작됨, 패킷 Down 됐을 경우 이전것인지 최근 것인지 헷갈릴 수 있기 때문
* 5000바이트 파일을 전송하고 시작 번호가 10001이고 Segment가 각각 1000바이트일 경우 시퀀스 넘버는 10001, 11001, 12001, 13001, 14001 임
* Acknowledgment number필드의 값은 수신자가 받기를 원하는 다음 바이트 (Ack num이 10001이라면 10000까지는 받았다는 말), Acknowledgment number는 누적됨

## Segment
TCP의 패킷을 세그먼트라고 함

![](/assets/images/markdown-img-paste-2019030223403345.png)

|Field|사이즈|의미|
|--|:-:|--|
|Source port address|16bits|송신자 포트 번호|
|Destination port address|16bits|수신자 포트 번호|
|Sequence number|32bits|Segment의 첫 바이트 번호 (시작 번호 만큼 Offset 가짐)|
|Acknowledgment number|32bits|송신자가 보낸 것 중 Ack - 1바이트까지는 받았다고 수신자가 보냄|
|HLEN|4bits|헤더 길이 word(4byte)단위|
|Reserved|6bits||
|URG|1bit|Urgent, 바로 Application단에 올려야함, Urgent pointer가 있음|
|ACK|1bit|Ack 확인 필요|
|PSH|1bit|Push, 더 받을 패킷이 없으니 Application 단으로 패킷을 올려라|
|RST|1bit|Reset, 접속 Reset|
|SYN|1bit|Sync, Sync 패킷 (가장 처음 패킷), Sequence number 동기화|
|FIN|1bit|Finish, 마지막 패킷, 접속 종료|
|Window size|16bits|수신자가 이용 가능한 버퍼 사이즈, ~65535까지 가짐|
|**Checksum**|16bits|오류 났을 시 복구를 위해, UDP와 마찬가지로 IP헤더까지 같이 Checksum, **TCP에서는 필수**|
|Urgent pointer|16bits|데이터 중 몇 번째 위치가 Argent 인지|
|Options and padding|~40bytes|옵션|

### Control Field (혹은 Flags)
URG, ACK, PSH, RST, SYN, FIN

### Pseudoheader
![](/assets/images/markdown-img-paste-20190302235153563.png)

## TCP Connection
TCP는 **연결 지향 (Connection-oriented)** 특징을 가짐. TCP는 송수신자 사이에 가상의 길(Path)를 만듬. 그 후 세그먼트 들이 가상의 길을 통해서 전송됨. IP가 비연결(Conetionless)이므로 TCP는 자기 스스로 연결을 제어함. 예를 들어 세그먼트가 없어지거나 잘못되는 경우 다시 전송함

### Connection Establishment (접속)
Three-way handshake를 통해 연결을 함
* rwnd는 Receiver Window Size
* SYN 세그먼트는 데이터가 없으면 Sequence number 하나 소모
* SYN + ACK도 마찬가지
* ACK 세그먼트는 데이터가 없으면 Sequence number 소모하지 않음

![](/assets/images/markdown-img-paste-20190303022327455.png)

### Data Transfer (데이터 전송)
![](/assets/images/markdown-img-paste-2019030302300842.png)

### Connection Termination (접속 해제)
Three-way handshake를 통해 연결 해제
* FIN 세그먼트는 데이터가 없으면 Sequence number 하나 소모
* FIN + ACK도 마찬가지
* 클라이언트에서 서버로 보내는 마지막 ACK는 Kernel 단에서 보내는 것, Connection closed에서 이미 Application 단의 연결은 끊김
![](/assets/images/markdown-img-paste-20190303025406424.png)

### Half-close (Four-way Handshaking)
나머지 패킷을 다 보내고 (소용은 없지만) 그 후 커널 단에서 접속 해제
* 만약 Reset 패킷을 받으면 바로 끝냄

![](/assets/images/markdown-img-paste-20190303025456457.png)

### State Transition Diagram
마지막 TIME_WAIT는 ACK가 없어질까봐 기다리는 것
![](/assets/images/markdown-img-paste-20190303024438384.png)

### Simultaneous Open (동시 열기)
![](/assets/images/markdown-img-paste-20190303025720535.png)

### Simultaneous Close (동시 닫기)
![](/assets/images/markdown-img-paste-20190303025737584.png)

### Denying a Connection (연결 거부)
바로 Reset 패킷을 보내면 연결 거부
![](/assets/images/markdown-img-paste-20190303025829304.png)

### Aborting a Connection (연결 중단)
![](/assets/images/markdown-img-paste-20190303030035162.png)


## Windows in TCP
TCP는 송수신자가 각각 버퍼를 가지고 있고 이를 윈도우라 함. 만약 Bidirectional 커뮤니케이션을 하고 싶다면 윈도우가 4개 필요 (송수신 각각 두 개 씩)

### Send Window
* ACK를 받아야 윈도우를 슬라이딩함 (좌측 벽은 Close, 우측 벽은 Open)
* Send Window Size는 좌측벽과 우측벽 사이 전체 사이즈
* Send Window Size를 조절해서 Flow, Congestion Control 가능

![](/assets/images/markdown-img-paste-20190303030558139.png)
![](/assets/images/markdown-img-paste-20190303030620603.png)

### Receive Window
* Byte를 받으면 ACK 보냄과 동시에 윈도우를 닫음 (Close)
* 받은 Byte는 Process가 사용하길 기다리다가, 사용이 끝나면 윈도우를 염 (Open)
* Receive Window Size는 현재 받을 수 있는 윈도우 크기

![](/assets/images/markdown-img-paste-20190303031026448.png)


## Flow Control
송신자가 데이터를 전송하는 속도와 수신자가 데이터를 받는 속도를 서로를 고려해 적절히 조절해주는 것

### TCP/IP Protocol Suite
* Application 레이어는 Process, Transport 레이어는 Kernel이라 볼 수 있음
* 커널과 프로세스 사이, 커널과 커널 사이에 Flow Control Feedback 가능
* Sending Window Size < min(Receiver Buffer Size, Congestion Buffer Size)

![](/assets/images/markdown-img-paste-20190303031752549.png)

### Flow Control 예시
![](/assets/images/markdown-img-paste-20190303032255463.png)


## Error Control
TCP가 신뢰성(Reliable) 있다는 말은 한 프로그램에서 다른 프로그램으로 데이터를 보낼 때 에러가 없고, 잃거나 복제된 자료가 없이 제대로 가야 한다는 것을 뜻함. TCP의 에러는 **Checksum, Acknowledgment, Time-out** 세 가지를 사용해서 컨트롤 함

* ACK 세그먼트는 Sequence number를 소모하지 않고 Acknowledge하지 않는다 (ACK에 ACK를 보내지 않는다는 말)
* 데이터가 순서대로 오지 않아도 TCP는 순서를 정렬해서 Process에 전송해줌
* TCP는 Selective Repeat Protocol로서 가장 잘 모델링될 수 있음

### Sender FSM
![](/assets/images/markdown-img-paste-20190303040650370.png)

### Receiver FSM
![](/assets/images/markdown-img-paste-20190303041614602.png)

### Acknowledgment Generation Rule
1. 데이터를 보낼 때 ACK 포함
2. 데이터가 없어도 ACK Timer가 다 되면 ACK 보냄
3. TImer 종료 전 두 번 연속으로 ACK 받으면 ACK 보냄 (속도 향상을 위해)
4. 중간 ACK가 빠지면 받아야할 번호 ACK 보냄
5. 빠진 패킷이 제대로 오면 ACK
6. ACK가 누락되어 세 번 같은 패킷을 받으면 버리고 다시 ACK 보냄

![](/assets/images/markdown-img-paste-20190303042023827.png)
![](/assets/images/markdown-img-paste-20190303042043121.png)
![](/assets/images/markdown-img-paste-20190303042401633.png)

### Fast Retransmission
ACK 세 번 중첩해서 오면 큐 가장 앞의 세그먼타 다시 전송 후 타이머 재시작
![](/assets/images/markdown-img-paste-20190303042511250.png)

### Lost Acknowledgment
ACK 누락되면 그냥 그 다음 필요한 ACK를 보냄
* 잘 처리해주지 않으면 Deadlock에 빠질 수도

![](/assets/images/markdown-img-paste-20190303042616512.png)


## Congestion Control
Congestion(네트워크 혼잡)을 알아채고, 컨트롤 해야함

### Slow Start, Exponential Increase
Threshold를 만나기 전까지 Congestion Window Size가 Exponential하게 증가함
![](/assets/images/markdown-img-paste-2019030304315027.png)


### Congestion Avoidance, Additive Increase
한단계씩 증가
![](/assets/images/markdown-img-paste-20190303043328556.png)

### TCP Congestion Policy
* Retransmission 패킷이 발생하면 Congestion 일어난 걸로 봄
* Time-out이 ACK 세 번 온 것보다 더욱 심각함
* Threshold는 계속 줄어듬

![](/assets/images/markdown-img-paste-20190303043514845.png)

### Congestion 예시
![](/assets/images/markdown-img-paste-20190303043856796.png)


## TCP Timers
최소 4개 사용

### Persistence Timer
수신자의 윈도우 사이즈가 0임을 알리는 ACK가 왔을 때 송신자에서 Timer 시작하고 송신을 보류. 왜냐하면 만약 수신자 윈도우 사이즈가 다시 리사이징 돼었을 때 ACK가 손실된다면 수신자 측에서는 마냥 기다리기 때문에 Deadlock에 빠질 수 있음.
* 수신자 윈도우 사이즈가 0임을 알리는 ACK가 송신자에게 왔을 시 타이머 시작
* 타이머가 다되면 Probe라는 특수한 세그먼트를 송신자가 수신자에게 보내서 ACK를 요청함

### Keepalive Timer
Idle 상태로 연결이 오래 지속되는 것을 방지하기 위해 있는 타이머, 서버에서 타이머가 시작되고, 만약 클라이언트로 부터 세그먼트를 받는 다면 타이머 초기화, Time-out은 보통 2시간인데, 2시간이 지나도록 아무 응답이 없다면 서버가 클라이언트에게 Probe 패킷을 전송하고, 서버가 ACK를 받지 못할 경우 클라이언트와의 연결을 끊음

### TIME-WAIT Timer
접속 해제 시 필요 (1 ~ 2분, 2MSL(Maximum Segment Lifetime)) 마지막 ACK가 누락될 것을 대비

### Retransmission Timer
누락된 세그먼트를 재전송하기 위해 ACK를 기다리는 타이머. 만약 타이머가 끝나기 전까지 ACK가 오지 않았다면 세그먼트 손실로 간주하고 재전송. 이 Time-out을 RTO(Retransmission Time-Out) 이라함

### RTO 계산
RTO를 계산하기 위해서는 RTTm, RTTs, RTTd가 필요하다
* **RTTm (measurement RTT)** : 세그먼트 전송 후 실제 ACK가 돌아올 때 까지 걸리는 시간
* **RTTs (smoothed RTT)** : RTTs = (1 - a)RTTs + a * RTTm (a = 1/8), 스무딩을 위해
* **RTTd (deviation RTT)** : RTTd = (1 - d)RTTd + b * |RTTm - RTTs| (b = 1/4), 편차를 활용
* **RTO** = RTTs + 4RTTd
* **만약 재전송이 일어나면 RTO = RTO * 2**

## Options
TCP 헤더는 최대 40바이트까지 옵션 가능

### Options

<table>
  <tr>
    <td rowspan=7><b>Options</b></td>
    <td rowspan=2><b>Single-byte</b></td>
    <td>End of option list</td>
    <td>옵션의 끝 알림, 한 번만 사용 가능</td>
  </tr>
  <tr>
    <td>No operation</td>
    <td>4byte단위로 (Word단위) 헤더 사이즈 맞추기 위해 혹은 옵션의 시작 지점 정렬위해, 여러 번 사용 가능</td>
  </tr>
  <tr>
    <td rowspan=5><b>Multiple-byte</b></td>
    <td>Maximum segment size</td>
    <td>Connection setup 시 설정, 바뀌지 않음, 보통 1024byte</td>
  </tr>
  <tr>
    <td>Window scale factor</td>
    <td>Connection setup 시 설정, 바뀌지 않음, 16bit, 윈도우 사이즈가 2의 몇 승인지</td>
  </tr>
  <tr>
    <td>Timestamp</td>
    <td>RTT(Round Trip Time) 계산 시 사용</td>
  </tr>
  <tr>
    <td>SACK-permitted</td>
    <td></td>
  </tr>
  <tr>
    <td>SACK</td>
    <td>Selective ACK, 전송 중간에 빠진 패킷 용 (보통 ACK는 Cumulative ACK)</td>
  </tr>
</table>

#### End-of-option
![](/assets/images/markdown-img-paste-20190303161637541.png)

#### No-operation
![](/assets/images/markdown-img-paste-20190303161655372.png)

#### Maximum-segment-size
![](/assets/images/markdown-img-paste-20190303161729746.png)

#### Window-scale-factor
![](/assets/images/markdown-img-paste-20190303161744240.png)

#### Timestamp
![](/assets/images/markdown-img-paste-20190303161815821.png)
![](/assets/images/markdown-img-paste-20190303161919930.png)

#### SACK
![](/assets/images/markdown-img-paste-20190303161942935.png)
![](/assets/images/markdown-img-paste-20190303162111808.png)

## TCP Package
![](/assets/images/markdown-img-paste-20190303162238565.png)
### TCBs
TCP 컨트롤에 필요한 DB를 TCBs라 함
![](/assets/images/markdown-img-paste-20190303162403847.png)
