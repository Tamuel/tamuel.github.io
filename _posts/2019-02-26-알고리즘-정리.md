---
title: "알고리즘 정리"
date: 2019-02-26 18:10:30 -0400
categories: Algorithm
tags: Algorithm
---

# 알고리즘 정리

### Time Complexity
알고리즘의 시간 복잡도 측정 가능
1. 입력 사이즈 N
2. Basic operation 선택
3. 2가 N 당 얼마나 계산 필요한지 계산
* n = 10<sup>2</sup>일 경우 시간 복잡도

	| O(logN) | O(N) | O(NlogN) | O(N<sup>2</sup>) | O(N<sup>3</sup>) | O(2<sup>N</sup>) | O(N!) |
	| --- | --- | --- | --- | --- | --- | --- |
	| 0.007µs | 0.10µs | 0.664µs | 10µs | 1ms | 4 * 10<sup>13</sup> years| INF |

* **O(N) (Big-Oh)** : Upper Bound, 가장 오래 걸려도 N 시간과 작거나 같게 걸릴 경우
* **Ω(N) (Omega)** : Lower Bound, 최소한 N 시간과 같거나 오래 걸릴 경우
* **θ(N) (Omega)** : N 만큼 걸리는 집합 (O와 Ω의 교집합)
* **o(N) (Small-Oh)** : N 시간 보다 적게 걸리는 모든 집합
* Lower bound 와 Upper bound가 같다면 Optimal한 알고리즘이라 할 수 있음
	
### Swap
배열의 a 인덱스와 b 인덱스의 데이터 교환
* ```Time complexity``` O(1)
* ```Space complexity``` O(1)
{% highlight c linenos=table %}
void swap(int* a, int* b) {
	int temp = *a;
	*a = *b;
	*b = temp;
}
{% endhighlight %}

## Sort
정렬하는 방법

### Bubble sort
현재 인덱스와 다음 인덱스의 데이터만 보고 스왑한다 
* ```Time complexity``` O(N<sup>2</sup>)
* ```Space complexity``` O(N)
{% highlight c linenos=table %}
int arr[size];
for (int i = size - 1; i >= 0; i--) {
  for (int j = 0; j < i; j++) {
    if (arr[j] > arr[j + 1])
      swap(arr[j], arr[j + 1]);
  }
}
{% endhighlight %}

### Selection sort
정렬되지 않은 데이터 중 가장 작은 수를 찾아서 스왑한다
* ```Time complexity``` O(N<sup>2</sup>)
* ```Space complexity``` O(N)
{% highlight c linenos=table %}
int arr[size];
for (int i = 0; i < size; i++) {
  int min = i;
  for (int j = i + 1; j < size; j++)
    if (arr[min] > arr[j])
      min = j;
  swap(arr[min], arr[i]);
}
{% endhighlight %}

### Insertion sort
현재 인덱스에서 뒤로 데이터를 찾아보면서 알맞은 위치를 찾아 넣는다
* ```Time complexity``` O(N<sup>2</sup>)
* ```Space complexity``` O(N)
* 정렬이 되었을 경우 한 번 순회하면서 체크하기만 하면 됨 N
{% highlight c linenos=table %}
	for (int i = 0; i < arr.size(); i++) {
		int current = arr[i];
		for (int j = i - 1; j >= 0; j--) {
			if (arr[j] < current) break;
			else swap(arr[j], arr[j + 1]);
		}
	}
{% endhighlight %}

### Merge sort
데이터를 나눈 다음 정렬하고 다시 합친다.
* Divide-and-Conquer
* ```Time complexity``` O(NlogN)
* ```Space complexity``` O(2N)
* Stable하지만 In-place는 
{% highlight c++ linenos=table %}
void mergeSort(vector<int>& arr, int start, int end) {
	if (start >= end)
		return;
	else if (end - start == 1) {
		if (arr[start] > arr[end])
			swap(arr[start], arr[end]);
		return;
	}
	int center = (start + end) / 2;
	mergeSort(arr, start, center);
	mergeSort(arr, center + 1, end);

	vector<int> temp(end - start + 1);
	int l = start, r = center + 1, i = 0;
	while (l <= center && r <= end) {
		if (arr[l] <= arr[r])
			temp[i++] = arr[l++];
		else 
			temp[i++] = arr[r++];
	}
	if (l == center + 1)
		while (i < end - start + 1) temp[i++] = arr[r++];
	if (r == end + 1)
		while (i < end - start + 1) temp[i++] = arr[l++];
	for (i = 0; i < end - start + 1; i++)
		arr[i + start] = temp[i];
}
{% endhighlight %}

### Quick sort
피봇을 정해 피봇을 기준으로 작은 것과 큰 것을 나눈 다음 피봇 양쪽을 다시 재귀적으로 정렬한다.
* Divide-and-Conquer
* ```Time complexity``` O(NlogN)
* ```Space complexity``` O(N)
* Stable하지 않지만 In-place
* 재귀적으로 구현 시 Stack memory 많이 잡아 먹을 수도 있음
* 피봇이 계속 가장 크거나 작을 경우 O(N<sup>2</sup>) 일 수도 있다.
* 파티션을 나눠서 작은 파티션부터 먼저 처리한 다면 Stack Depth 낮출 수 있음
{% highlight c++ linenos=table %}
void quickSort(vector<int>& arr, int start, int end) {
	if (start >= end)
		return;
	int pivot = start, l = start + 1, r = end;
	while (l < r) {
		while (l <= end && arr[pivot] > arr[l]) l++;
		while (r >= start && arr[pivot] < arr[r]) r--;
		if (l <= r) swap(arr[l], arr[r]);
	}
	swap(arr[r], arr[pivot]);
	quickSort(arr, start, r - 1);
	quickSort(arr, r + 1, end);
}
{% endhighlight %}

## Search
탐색하는 방법

### Sequential search
하나하나 다 찾아봄
* ```Time complexity``` O(N)
* ```Space complexity``` O(N)
{% highlight c linenos=table %}
int arr[size], i;
int query = 10;
for (i = 0; i < size; i++)
  if (arr[i] == query) break;
arr[i] == query;
{% endhighlight %}

### Binary search
정렬된 자료에서 반씩 버려가면서 찾음
* Divide-and-Conquer
* ```Time complexity``` O(logN)
* ```Space complexity``` O(N)
{% highlight c linenos=table %}
int arr[size];
int query = 10;
int low = 0, high = size, center;
while (low != high) {
  center = (low + high) / 2;
  if (arr[center] < query)
    low = center + 1;
  else
    high = center;
}
arr[query] == query;
{% endhighlight %}

## Dynamic Programming
Subproblem들의 Overlapping이 없으면 Divide-and-Conquer 하면 되지만 Overlapping이 있을 경우 Dynamic Programming 기법 사용.
* Recursive property를 먼저 찾고
* Bottom-up으로 이전에 저장해 놓은 데이터를 참고하여 문제 해결
* Prinsiple of Optimality 만족해야함 (Optimal 솔루션의 Subproblem이 Optimal 할 경우)

### Binomial Coefficient
iCj(조합)은 DP로 표현 가능
* b[i][j] = b[i - 1][j - 1] + b[i - 1][j], (j = 0 이거나 j = i 일 경우 1)
{% highlight c linenos=table %}
int b[11][11];
int n = 10, k = 4;
for (int i = 0; i <= n; i++)
	for (int j = 0; j <= min(i, k); j++)
		if (j == 0 || i == j) b[i][j] = 1;
		else b[i][j] = b[i - 1][j - 1] + b[i - 1][j];
b[n][k]; // 10C4
{% endhighlight %}

### Floyd Algorithm
Graph에서 임의의 노드 A에서 B노드로 갈 수 있는 가장 짧은 길
* 모든 edge의 weight가 양수 일 경우
* 메인 아이디어 : A노드에서 B노드로 갈 때 1 ~ K 노드 까지만 사용해서 가는 최단 거리
{% highlight c linenos=table %}
// Directed weighted graph
int d[5][5] = {
	{0, 1, INF, 1, 5},
	{9, 0, 3, 2, INF},
	{INF, INF, 0, 4, INF},
	{INF, INF, 2, 0, 3},
	{3, INF, INF, INF, 0}
};

for (int k = 0; k < 5; k++) {
	for (int i = 0; i < 5; i++) {
		for (int j = 0; j < 5; j++) {
			if (d[i][j] > d[i][k] + d[k][j])
				d[i][j] = d[i][k] + d[k][j];
		}
	}
}
{% endhighlight %}

### TSP (Traveling Salesman Problem)
모든 노드를 지나는 최단 경로 구하기 (Euler cycle 구하기)
* 처음 노드에서 다른 노드를 지나고 다시 돌아오는 경우의 최단 거리 값을 저장해 놓았다가 사용
* 방문한 노드를 bit로 치환해서 사용 eg) 1->2->3의 경우 0111, 1->3->4의 경우 1101
* TSP(current, visited) = min(TSP(next, visited + next) + distance[current][next])
{% highlight c linenos=table %}
int TSP(int cur, int visited) {
	if (visited == (1 << N) - 1)
		return dist[cur][0];

	if (dp[cur][visited] != INF)
		return dp[cur][visited];

	for (int i = 0; i < N; i++) {
		if (visited & (1 << i) || dist[cur][i] == INF) continue;
		dp[cur][visited] = min(dp[cur][visited], TSP(i, visited | (1 << i)) + dist[cur][i]);
	}

	return dp[cur][visited];
}
TSP(0, 1)
{% endhighlight %}
