---
title: "알고리즘 정리"
date: 2019-02-26 18:10:30 -0400
categories: Algorithm
tags: Algorithm
---

# 알고리즘 정리

### Time Complexity
알고리즘의 시간 복잡도 측정 가능
1. 입력 사이즈 N
2. Basic operation 선택
3. 2가 N 당 얼마나 계산 필요한지 계산

### Swap
배열의 a 인덱스와 b 인덱스의 데이터 교환
{% highlight c linenos=table %}
void swap(int* a, int* b) {
	int temp = *a;
	*a = *b;
	*b = temp;
}
{% endhighlight %}

## Sort
정렬하는 방법

### Bubble sort
현재 인덱스와 다음 인덱스의 데이터만 보고 스왑한다 O(N^2)
{% highlight c linenos=table %}
int arr[size];
for (int i = size - 1; i >= 0; i--) {
  for (int j = 0; j < i; j++) {
    if (arr[j] > arr[j + 1])
      swap(arr[j], arr[j + 1]);
  }
}
{% endhighlight %}

### Selection sort
정렬되지 않은 데이터 중 가장 작은 수를 찾아서 스왑한다 O(N^2) 
{% highlight c linenos=table %}
int arr[size];
for (int i = 0; i < size; i++) {
  int min = i;
  for (int j = i + 1; j < size; j++)
    if (arr[min] > arr[j])
      min = j;
  swap(arr[min], arr[i]);
}
{% endhighlight %}

### Insertion sort
현재 인덱스에서 뒤로 데이터를 찾아보면서 알맞은 위치를 찾아 넣는다 O(N^2)
* 정렬이 되었을 경우 한 번 순회하면서 체크하기만 하면 됨 O(N)
{% highlight c linenos=table %}
	for (int i = 0; i < arr.size(); i++) {
		int current = arr[i];
		for (int j = i - 1; j >= 0; j--) {
			if (arr[j] < current) break;
			else swap(arr[j], arr[j + 1]);
		}
	}
{% endhighlight %}

## Search
탐색하는 방법

### Sequential search
하나하나 다 찾아봄 O(N)
{% highlight c linenos=table %}
int arr[size], i;
int query = 10;
for (i = 0; i < size; i++)
  if (arr[i] == query) break;
arr[i] == query;
{% endhighlight %}

### Binary search
정렬된 자료에서 반씩 버려가면서 찾음 O(logN) 
{% highlight c linenos=table %}
int arr[size];
int query = 10;
int low = 0, high = size, center;
while (low != high) {
  center = (low + high) / 2;
  if (arr[center] < query)
    low = center + 1;
  else
    high = center;
}
arr[query] == query;
{% endhighlight %}
