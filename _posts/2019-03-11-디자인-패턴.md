---
title: "디자인 패턴"
date: 2019-03-11 00:25:30 -0400
categories: Design-Pattern
tags: Design-Pattern
mathjax: true
---
[heejeong Kwno님 블로그 참고](https://gmlwjd9405.github.io/2018/07/06/design-pattern.html)
[Wiki Docs](https://wikidocs.net/584)
[Jeong-pro님 블로그 참고](https://jeong-pro.tistory.com/98)

# 디자인 패턴
소프트웨어 개발 시 어떤 특정한 상황에 자주 발생하는 문제들을 해결하기 패턴

# 디자인 패턴의 구조
* **Context**
  * 문제가 발생하는 상황 기술
  * 유용하지 못한 상황도 기술
* **Problem**
  * 해결할 필요가 있는 여러 디자인 이슈 기술
  * 제약 사항과 영향력도 함께 고려
* **Solution**
  * 문제를 해결하도록 설계를 구성하는 요소들과, 요소들 사이 관계
  * 구체적인 방법이나 언어에 의존적이지 않은 탬플릿 이여야함

# GoF 디자인 패턴
* GoF(Gang of Fout)라 불리는 사람들이 디자인 패턴 구체화 및 체계화
* 에리히 감마(Erich Gamma), 리차드 헬름(Richard Helm), 랄프 존슨(Ralph Johnson), 존 블리시디스(John Vissides)

# GoF 디자인 패턴의 분류

## 생성(Creational) 패턴
객체 생성에 관한 패턴

* **Abstract Factory (Kit)**
  * 구체적인 클래스에 의존하지 않고, 서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페이스를 제공하는 패턴
* **Builder**
  * 제품을 여러 단계로 나누어 만들 수 있도록 제품 생산 단계들을 캡슐화한다고 생각하면됨
  * 복합 객체의 생성 과정과 표현 방법을 분리하여 동일한 생성 절차에서 서로 다른 표현을 가능하도록 하는 패턴
* **Factory Method**
  * 객체 생성 처리를 서브 클래스로 만들어 분리하여 캡슐화해 처리
* **Prototype**
  * 생성할 객체의 종류의 원형이 되는 예시물을 이용해, 그 원혀을 복제해 새로운 객체를 생성하는 패턴
  * 어떤 객체를 생성할 때 자원이나 시간을 많이 잡아먹는 경우 사용
* **Singleton**
  * 전역 변수를 사용하지 않고 하나의 객체만 생성하도록 하여, 생성된 객체를 어디서든지 참조할 수 있도록 하는 패턴

## 구조(Structural) 패턴
클래스나 구조를 결합하여 더 큰 구조를 만드는 패턴

* **Adapter**
  * 클래스의 인터페이스를 사용자가 원하는 다른 인터페이스로 변환하는 패턴
* **Bridge**
  * 구현부에서 추상층을 분리하여 각자 독립적으로 변형할 수 있게 하는 패턴
* **Composite**
  * 여러 개의 객체들로 구성된 복합 객체와, 단일 객체를 클라이언트에서 구별 없이 다루게 해주는 패턴
* **Decorator**
  * 객체를 감싸(Deco) 새로운 행동을 제공
* **Facade**
  * 서브시스템 내의 인터페이스에 대해 하나의 통합된 인터페이스를 만들어 서브 시스템 사용을 편리하게 하는 패턴
* **Flyweight**
  * 크기가 작은 객체가 여러 개 있을 때, 공유를 통해 이들을 효율적으로 지원하는 패턴
* **Proxy**
  * 어떤 다른 객체가 접근하는 것을 통제하기 위해 해당 객체의 대리자(Surrogate) 혹은 자리채움자(Placeholder)를 제공하는 패턴
  * 다른 객체 접근 통제를 위해 대리자 제공
  * C++의 포인터와 스마트 포인터가 한 예

## 행위(Behavioral) 패턴
객체나 클래스 사이의 알고리즘 혹은 책임 분배에 관련된 패턴

* **Chain of Responsibility**
  * 요청을 처리하는 객체들을 여러 개 만들어 요청하는 객체와 요청 받는 객체의 결합을 피하기 위한 패턴
  * 요청 받을 수 있는 객체를 여러 개 묶고, 요청 처리가 가능한 객체를 만날 때까지 체인을 따라 요청 전달
* **Command**
  * 요청을 객체 형태로 캡슐화하여 사용
  * 실행될 기능을 캡슐화해 주어진 여러 기능을 실행할 수 있게 재상용성이 높은 클래스를 설계하는 패턴
  * 요청 저장, 로깅, 연산 취소를 가능하게함
* **Interpreter**
  * 주어진 언어에 대해 해당 언어의 문법을 위한 표현 수단을 정의하고, 표현 수단을 사용하여 해당 언어로 작성된 문장을 해석하는 해석기를 정의하는 패턴
* **Iterator**
  * 내부 표현을 노출하지 않고, 어떤 객체 안의 원소들을 순차적으로 접근할 수 있게 해주는 패턴
* **Mediator (중재자)**
  * 한 집합 안의 객체들의 상호작용을 캡슐화해 객체를 정의하는 패턴
  * 객체들이 직접 서로 참조하지 않게 해 Loose Coupling (소결합)
* **Memento**
  * 객체를 이전 상태로 복구시킬 수 있어야 할 경우 사용하는 패턴
* **Observer**
  * 한 객체의 상태가 변한다면 다른 객체의 상태도 연동되도록 일대다 객체 의존 관계를 구성하는 패턴
* **State**
  * 객체의 상태에 따라 객체의 행위 내용을 변경하는 패턴
* **Strategy**
  * 행위를 클래스로 캡슐화해 동적으로 행위를 자유롭게 바꿀 수 있게 해주는 패턴
  * 객체마다 다를 수 있는 행위(메소드) 부분을 캡슐화해 교환하여 사용할 수 있도록하는 패턴
* **Template Method**
  * 탬플릿을 만들어주고, 해당 메소드 안을 채워 넣기만하면 되는 디자인 패턴
  * 하위 클래스에서 실제 메소드 구현
* **Visitor**
  * 객체 구조를 이루는 원소에 대해 수행할 연산을 표현하는 패턴
  * 연산을 적용할 원소의 클래스르 변경하지 않고도 새로운 연산을 정의할 수 있게 함
