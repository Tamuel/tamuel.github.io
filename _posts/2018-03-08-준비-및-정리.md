---
title: "준비 및 정리"
date: 2019-03-08 19:58:30 -0400
categories: Ready
tags: Ready
mathjax: true
---

# MVC 패턴

---

# 자바 프레임워크

---

# 스프링 프레임워크

---

# 검색 방식

---

# JVM (Java Virtual Machine)
* Javac(자바 컴파일러)에 의해 만들어진 Byte code(.class파일)을 OS에 맞게 해석
* OS에 독립적이게 JAVA 실행 가능
* JVM 인스턴스 : 자바 바이트코드로 컴파일된 컴퓨터 프로그램을 실행하는 프로세스

## 아키텍처

![](/assets/images/markdown-img-paste-20190310021509195.png)

### Class Loader
* 런타임 중 클래스(`.class`)를 로드 (Runtime Data Area에 올려줌)
* 바이트 코드가 제대로 작성되었는지 검사
* 객체 생성 시 메모리에 올려줌
* Lazy-loading (지연 로딩), Caching (캐싱) 등을 이용

### Runtime Data Areas
* 프로그램 수행을 위한 JVM의 메모리 공간
* **PC Register, JVM Stack, Native Method Stack은 스레드마다** 생성되며, **Method Area, Heap은 모든 스레드가 공유**함

  |Space|Description|
  |--|--|
  |PC Registers|프로그램 카운터 (스레드 용). 실제 PC처럼 레지스터 단에서 작동하지는 않고 Stack 기반 작동. Method Byte나 Native Pointer. Native Method 실행 시는 JVM거치지 않고 API로 바로 수행|
  |JVM Stack|스레드를 위한 Stack. 스레드 시작 시 생성되며, 각 스레드 별로 생성. 일반 프로그램에서 Stack 영역이라 생각하면 될 듯 (지역 변수, 임시 변수, 매개 변수 등 저장)|
  |Native Method Stack|JNI를 통해 호출되는 자바 외 네이티브 코드를 위한 Stack 공간|
  |Method Area|모든 스레드가 공유하는 메모리 영역. 일반 OS의 Data 영역이라고 생각하면됨. Type 데이터들 (클래스, 인터페이스, 메소드, 필드, 전역 변수 등) 보관. 각 Type마다 Runtime Constant Pool을 가짐. 해당 풀은 메소드, 필드, 상수 등의 레퍼런스를 가지고 있어 실제 물리적 메모리 위치 참조. Runtime Constant Pool은 추후 참조해서 실행할 바이트 코드를 따로 찾아 메모리에 적재하는 동적 로딩을 가능하게함|
  |Heap|클래스의 객체를 생성하면 Heap에 저장. 일반 OS의 동적 메모리 할당을 위한 Heap과 같음|

### Excution Engine
로드된 클래스의 Byte code를 실행하는 런타임 모듈. Runtime Data Area 영역의 바이트 코드를 실행하는 모듈. 자바 바이트 코드 단위로 읽어서 실행

#### JIT / Interpreter
* 자바 바이트 코드를 기계 언어로 번역해줌
* JVM은 JIT과 Interpreter를 함께 사용함
* **Interpreter** : 기존에 JVM은 인터프리터만을 사용했음. 인터프리터는 바이트 코드를 명령어 단위를 읽고 실행하기 때문에 컴파일 방식보다 속도가 느림
* **JIT** : 인터프리터의 단점을 상쇄하기 위해 도입한 Just-In-Time 컴파일러. JVM은 인터프리터 방식으로 코드를 진행하다가, 해당 코드가 실행되는 빈도수를 체크하여 자주 실행되는 코드를 JIT를 통해 바이트코드를 컴파일하고 이를 캐싱하여 속도를 빠르게 함. JIT로 컴파일된 코드는 인터프리터 형식보다 빠르긴 하지만 컴파일 하는 시간이 오래 걸리기 때문에 융합해서 사용

#### Garbage Collector
* C/C++등 기존 프로그래밍 언어의 경우 프로그래머가 프로그램 메모리를 관리해줘야 했지만, 자바에서는 JVM이 프로그램 메모리를 관리해줌
* 자바 프로그램에서 사용되지 않는 메모리 지속적으로 찾아내 제거
* 참조되지 않은 객체들 탐색 및 삭제
* GC는 Heap과 Method Area를 관리

##### Method Area / Heap
* Heap은 다시 **Eden, 두 개의 Survivor, Old** 총 4개의 영역으로 나뉘어짐

  ![](/assets/images/markdown-img-paste-20190310000941340.png)

* **Young Generation 영역**
  * Old 보다 사이즈도 작고 객체가 잔존하는 시간도 짧음
  * 대부분 객체는 잠깐 생성되었다가 금방 접근 불가능 상태가되기 때문에 Young에 생성되었다가 사라짐
  * 여기서 GC가 발생하면 **Minor GC**
* **Old Generation 영역**
  * Young 보다 사이즈가 크지만 객체가 잔존하는 시간이 김
  * 여기서 GC가 발생하면 **Major GC**
* **Permanent Generation 영역**
  * Method Area를 뜻함
  * 여기서 GC가 발생하면 **Major GC**
* Old의 객체는 카드 테이블(Card Table)을 가지고 있어 Old의 객체가 Young의 객체를 참조하면 Young 영역에서 GC 발생 시 카드 테이블만 뒤져 Old에서 GC 대상이 무엇인지 판별해 전반적인 GC 시간이 줄어듬

##### **Minor GC**
1. 최초 객체 생성 시 Eden에 생성
2. Eden에서 GC가 발생한 후 남은 객체들을 Survivor1으로 이동
3. 1, 2를 계속 반복하면 Survivor1에 객체들이 쌓임
4. Survivor1이 가득찼다면 GC 수행 후, 살아남은 객체들을 Survivor2로 모두 옮김 (Survivor1은 빈상태)
5. 이후에는 Survivor2에서 2, 3을 실행하고 4에서는 Survivor1으로 모두 옮김 (Survivor2가 빈상태)
6. 1 ~ 5를 계속 **반복해도 살아 남은 객체** 혹은 Eden영역의 살아있는 객체가 Survivor 영역 보다 더 많은 경우 **Old영역으로** 이동
* 위의 방법을 보면 **Survivor1이나 Survivor2 둘 중 하나는 반드시 비어있어야함**. 둘 다 데이터가 존재하거나, 둘 다 데이터가 없다면 시스템이 오류를 일으킨것
* HotSpot VM의 경우 더 빠른 메모리 할당을 위해 **Bump-the-pointer**라는 기술 사용
  * **Bump-the-pointer** : Eden에 삽입된 마지막 객체는 Eden 영역의 가장 위 (Top)에 있는데 이를 가리키는 포인터를 말함. 이 포인터를 이용해 해당 객체가 Eden에 들어갈 수 있는 크기인지만 확인해서 적당하다면 Eden에 삽입. 마지막 객체만 확인하면 되므로 매우 빠르게 객체 할당 일어남
  * **TLABs(Thread-Local Allocation Buffers)** : Bump-the-pointer의 경우 멀티 스레딩 환경이라면 Eden에 객체를 저장할 때 마다 Lock을 걸어야해 비효율적. 이를 위해 TLABs는 각각의 스레드가 Eden에서 일정 부분의 작은 영역을 가질 수 있고 각 스레드는 해당 영역만 접근 할 수 있도록해 Lock없이 메모리 접근 가능

##### **Major GC (Full GC)**
* 보통 Old 영역이 가득차면 Major GC를 수행
* 5가지 방법 존재
  * **Serial GC** : Young은 앞의 Minor GC 사용. Old 영역 GC는 Mark-Sweep-Compact 사용. Mark는 첫 단계로 Old에서 살아 있는 객체를 식별. Sweep은 Heap의 앞부분부터 확인하여 살아 있는 객체만 남김. Compact는 각 객체들 사이에 빈 공간이 없도록 메모리를 앞부터 순서대로 정렬. 싱글 코어 CPU에서 사용
  * **Parallel GC** : Serial GC의 병렬화 알고리즘. 기본 알고리즘은 Serial GC와 똑같음. 멀티 코어 CPU에서 사용
  * **Parallel Compacting(Old) GC** : Serial GC와 달리 Mark-Summary-Compact 사용. Sweep의 경우 단일 스레드가 Heap을 훑지만, Summary의 경우 여러 스레드가 Old 영역을 분리하여 훑음
  * **Concurrent Mark & Sweep GC (CMS)**
    * Initial Mark : 클래스 로더에서 가장 가까운 객체 중 살아있는 객체 찾음 (짧은 Stop-the-world)
    * Concurrent Mark : Initial Mark에서 살아남은 객체의 참조를 따라가며 살아있는 객체를 찾음
    * Remark : Concurrent Mark 수행 중 객체가 끈기거나, 새롭게 생긴 객체가 없는지 확인 (짧은 Stop-the-world)
    * Concurrent Sweep : 쓰레기 정리
    * 별도의 Compaction 단계가 없어 멈추는 시간이 짧지만 시스템 자원을 더 소모하고, Old 영역 크기가 충분치 않거나 크기에 비해 조각난 메모리가 많으면 오히려 Stop-the-world 시간이 늘어남
  * **G1(Garbage First) GC**

    ![](/assets/images/markdown-img-paste-20190310014959227.png)

    * 앞선 GC들과 달리 Young, Old 나누지 않고 바둑판 모양의 영역이 각각 Eden, Survivor, Old 역할을 모두 함. 역할들이 동적으로 바뀌면서 GC가 일어남

### JNI(Java Native Interface)
* 자바로 구현되지 않은 네이티브 코드를 호출 가능하게 해주는 프레임워크

### Native Method Libraries
* JNI 실행에 필요한 라이브러리들

---

# RESTful
## REST
REpresentational State Transfer
* WWW 소프트웨어 아키텍처 중 하나
* ROA 따름

## ROA
* Resource Oriented Architecture
* 행동 보다는 리소스에 주안
* HTTP 사용
* URI에 명사 사용
* 리소스의 표현과 분리

## 아키텍처
* Resource (URI) : 자원
* Services (HTTP : POST, GET, PUT, DELETE) : 액션
* Representation (JSON, XML 등) : 표현

## 장점
* 서버를 데이터 저장소라 생각해 클라이언트의 이식성 높아짐
* 클라이언트가 UI와 유저 상태 고려
  * 서버가 더 간단해짐
* 서버와 클라이언트 따로 개발 가능
* Stateless : 서버는 클라이언트 상태를 저장하지 않음
* Cacheable : 클라이언트가 응답을 캐싱 가능

## REST 디자인
* Uniform interface : REST를 디자인한 가장 큰 이유
  * 아키텍처를 간소화함
  * Identification of resources : 각 자원은 요청(Request)에서 확인(Identify) 가능. 하지만 실제 자원과 표현은 별개!
  * 표현을 통해 자원 변경 : 클라이언트가 자원의 표현을 안다면 충분히 자원을 조작 가능
  * Self-descriptive message : 각각의 메시지안에는 자원이 명확하게 명시되어 있음 (읽기 편함)

    ```
    "students":
		[
			{"name":"Rhino", "major":"Computer Science"},
			{"name":"Anderson", "major":"Health"},
			{"name":"Peter", "lastName":"Statistics"}
		]
    ```

  * Hypermedia As The Engine Of Application State (HATEOAS)
    * HATEOAS-driven 사이트들은 사이트의 REST 인터페이스에 동적으로 접근할 수 있도록 Response에 링크를 걸어서도 보냄

    ```
    GET /account/12345 HTTP/1.1
    HTTP/1.1 200 OK
    <?xml version="1.0"?>
    <account>
      <account_number>12345</account_number>
      <balance currency="usd">100.00</balance>
      <link rel="deposit" href="/account/12345/deposit"/>
      <link rel="withdraw" href="/account/12345/withdraw"/>
    </account>
    ```
* HTTP 기반 RESTful API는 다음으로 정의됨
  1. URI
  2. JSON / XML (Media type)
  3. HTTP 함수 (POST, GET, PUT, DELETE)
  4. Hypertext Link (State, Resource)

---

# 아이디어
## [실시간] 검색어 보기 쉽게 시각화
* 현재 실시간 혹은 일반 검색어는 단순히 우측에 숫자만 표시하는 등 사용자가 명확히 얼마나 뜨는지 파악이 힘듬
* 한 눈에 보기 쉽고, 비교도 잘되게 나타낸다면 사람들이 더 관심을 가지고 이해하기 쉬울 것
* 연관 검색어도 그래프 형태로 보기 쉽게 나타낸다면 어떨까?

## 이미지를 검색 쿼리로
* 이미지 자체의 피쳐를 뽑아 검색어 쿼리로 집어넣고, 해당 이미지와 유사한 이미지가 나오게 (Vector 거리 등으로) 계산하면 유사한 이미지 찾을 수 있지 않을까?
* 이미지 자체에서 목적으로 하는 영역을 Crop할 수 있게 사용자가 전처리하게
* 사용자가 이미지의 카테고리를 정해서, 특정 카테고리에서 검색 가능하게

---

# 왜 가고 싶을까

---

# 웹표준 접근성
