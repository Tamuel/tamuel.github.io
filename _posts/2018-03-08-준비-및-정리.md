---
title: "준비 및 정리"
date: 2019-03-08 19:58:30 -0400
categories: Ready
tags: Ready
mathjax: true
---

# MVC 패턴

# 자바 프레임워크

# 스프링 프레임워크

# 검색 방식

# JVM (Java Virtual Machine)
* Javac(자바 컴파일러)에 의해 만들어진 Byte code(.class파일)을 OS에 맞게 해석 (OS에 상관없이 JAVA 실행 가능)
* JIT 컴파일러 사용

## 아키텍처
### Class Loader
* 런타임 중 클래스를 로드
* 객체 생성 시 메모리에 올려줌

### Runtime Data Areas
* 프로그램 수행을 위한 JVM의 메모리 공간

  |Space|Description|
  |--|--|
  |PC Registers|프로그램 카운터 (쓰레드 용). 실제 PC처럼 레지스터 단에서 작동하지는 않고 Stack 기반 작동. Method Byte나 Native Pointer. Native Method 실행 시는 JVM거치지 않고 API로 바로 수행|
  |JVM Stack|쓰레드를 위한 Stack. 쓰레드 시작 시 생성되며, 각 쓰레드 별로 생성. 일반 프로그램에서 Stack 영역이라 생각하면 될 듯 (지역 변수, 임시 변수, 매개 변수 등 저장)|
  |Native Method Stack|JNI(Java Native Interface)를 통해 호출되는 자바 외 네이티브 코드를 위한 Stack 공간|
  |Method Area|모든 쓰레드가 공유하는 메모리 영역. 일반 OS의 Data 영역이라고 생각하면됨. 클래스, 인터페이스, 메소드, 필드, 전역 변수 등 보관|
  |Heap|클래스의 객체를 생성하면 Heap에 저장. 일반 OS의 동적 메모리 할당을 위한 Heap과 같음|

### Excution Engine
로드된 클래스의 Byte code를 실행하는 런타임 모듈. Runtime Data Area 영역의 바이트 코드를 실행하는 모듈. 자바 바이트 코드 단위로 읽어서 실행

#### JIT Compiler
처음 JVM은 Interpreter를 사용해서 한 줄씩 읽고 해석해 속도가 느렸지만, JIT 컴파일러를 도입해서 속도를 향상시킴. JIT는 Byte Code를 Native Code로 바꿔서 실행이 빠름


#### Garbage Collector


# RESTful
## REST
REpresentational State Transfer
* WWW 소프트웨어 아키텍처 중 하나
* ROA 따름

## ROA
* Resource Oriented Architecture
* 행동 보다는 리소스에 주안
* HTTP 사용
* URI에 명사 사용
* 리소스의 표현과 분리

## 아키텍처
* Resource (URI) : 자원
* Services (HTTP : POST, GET, PUT, DELETE) : 액션
* Representation (JSON, XML) : 표현

## 장점
* 서버를 데이터 저장소라 생각해 클라이언트의 이식성 높아짐
* 클라이언트가 UI와 유저 상태 고려
  * 서버가 더 간단해짐
* 서버와 클라이언트 따로 개발 가능
* Stateless : 서버는 클라이언트 상태를 저장하지 않음
* Chcheable : 클라이언트가 응답을 캐싱 가능

## REST 디자인
* Uniform interface : REST를 디자인한 가장 큰 이유
  * 아키텍처를 간소화함
  * Identification of resources : 각 자원은 요청(Request)에서 확인(Identify) 가능. 하지만 실제 자원과 표현은 별개!
  * 표현을 통해 자원 변경 : 클라이언트가 자원의 표현을 안다면 충분히 자원을 조작 가능
  * Self-descriptive message : 각각의 메시지안에는 자원이 명확하게 명시되어 있음 (읽기 편함)

    ```
    "students":
		[
			{"name":"Rhino", "major":"Computer Science"},
			{"name":"Anderson", "major":"Health"},
			{"name":"Peter", "lastName":"Statistics"}
		]
    ```

  * Hypermedia As The Engine Of Application State (HATEOAS)
    * HATEOAS-driven 사이트들은 사이트의 REST 인터페이스에 동적으로 접근할 수 있도록 Response에 링크를 걸어서도 보냄

    ```
    GET /account/12345 HTTP/1.1
    HTTP/1.1 200 OK
    <?xml version="1.0"?>
    <account>
      <account_number>12345</account_number>
      <balance currency="usd">100.00</balance>
      <link rel="deposit" href="/account/12345/deposit"/>
      <link rel="withdraw" href="/account/12345/withdraw"/>
    </account>
    ```
* HTTP 기반 RESTful API는 다음으로 정의됨
  1. URI
  2. JSON / XML (Media type)
  3. HTTP 함수 (POST, GET, PUT, DELETE)
  4. Hypertext Link (State, Resource)

# 아이디어
## [실시간] 검색어 보기 쉽게 시각화
* 현재 실시간 혹은 일반 검색어는 단순히 우측에 숫자만 표시하는 등 사용자가 명확히 얼마나 뜨는지 파악이 힘듬
* 한 눈에 보기 쉽고, 비교도 잘되게 나타낸다면 사람들이 더 관심을 가지고 이해하기 쉬울 것
* 연관 검색어도 그래프 형태로 보기 쉽게 나타낸다면 어떨까?

## 이미지를 검색 쿼리로
* 이미지 자체의 피쳐를 뽑아 검색어 쿼리로 집어넣고, 해당 이미지와 유사한 이미지가 나오게 (Vector 거리 등으로) 계산하면 유사한 이미지 찾을 수 있지 않을까?
* 이미지 자체에서 목적으로 하는 영역을 Crop할 수 있게 사용자가 전처리하게
* 사용자가 이미지의 카테고리를 정해서, 특정 카테고리에서 검색 가능하게

# 왜 가고 싶을까

# 웹표준 접근성
