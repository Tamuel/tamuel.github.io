---
title: "준비 및 정리"
date: 2019-03-08 19:58:30 -0400
categories: Ready
tags: Ready
mathjax: true
---

---

# 하둡
##

---

# MVC 패턴

## MVC
* Model-View-Controller의 약자
* 디자인 패턴 중 하나

## Model
어플리케이션이 무엇을 할 것인지

## View
사용자에게 어떻게 보여주고 UI를 제공할 것인지

## Controller
Model과 View를 어떻게 처리할 것인지 (로직)
* Model과 View를 분리하는 역할

## Model1 방식
View와 Controller가 통합

![](/assets/images/markdown-img-paste-20190310174229779.png)

## Model2 방식
Model, View, Controller가 모두 따로

![](/assets/images/markdown-img-paste-20190310174246667.png)

## 단점
Model과 View가 서로 너무 의존적이라 개발이 복잡해질 수 있음

---

# 스프링 프레임워크

[12bme님 블로그 참고](https://12bme.tistory.com/157)

## 스프링 프레임워크
* **자바 엔터프라이즈 개발을 편하게 해주는 오픈소스 경량급 애플리케이션 프레임워크**
  * **애플리케이션 프레임워크** : 애플리케이션 개발의 전 과정을 빠르고 편리하고 효율적으로 진행하는게 목적인 프레임워크
  * **경량급** : 불필요하게 무겁지 않음. 이전 EJB의 경우 프레임워크와 서버환경에 의존적인 부분 때문에 불필요하게 무거웠음
  * **자바 엔터프라이즈 개발을 편하게** : 이전 프레임워크와는 근본적인 부분에서 엔터프라이즈 개발의 복잡함 제거함. 사용자는 애플리케이션 개발에 촛점을 맞춰서 개발 가능
  * **오픈소스** : 스프링은 오픈소스
* 자바SE의 POJO (Plain Old Java Object)를 자바EE에 의존적이지 않게 연결해줌
  * POJO : 평범한 자바 빈즈 (Javabeans) 객체

## 특징
* 경량 컨테이너로 자바 객체를 직접 관리
  * 객체 소멸, 생성 같은 사이클 관리 및 스프링으로부터 필요한 객체를 얻어옴
* POJO 방식 프레임워크
  * J2EE 프레임워크 처럼 특정 인터페이스를 구현하거나 상속 받을 필요가 없어 기존 라이브러리 등을 지원하기 용이하고 가벼움
* 제어반전 형식 (IoC : Inversion Of Control)
  * 컨트롤의 제어권을 스프링이 가지고 있어 스프링이 필요에 따라 사용자 코드를 호출
* 의존성 주입 지원 (DI : Dependency Injection)
  * 각 계층, 서비스가 서로 의존성이 존재하면 프레임워크가 연결해줌
* 관점 지향 프로그래밍 (Apect-Oriented Programming)
  * 로킹, 보안, 트랜젝션 등 여러 모듈에서 공통적으로 사용하는 기능을 분리하여 관리 가능
* 다양한 서비스 지원, 확장성 높음
  * 간단하게 기존 라이브러리 적용 가능
* 동적 웹사이트 개발을 위한 프레임워크
* 대한민국 전자정부 표준 프레임워크 기반 기술
* MVC 패턴 지원
  * Controller (Controller)
  * Repository (DB)
  * Model (Javabeans)
  * View (Html)

---

# 검색 방식
## 구글의 검색 방식
### 1. 크롤링 및 색인(Index) 생성
* 크롤링 : 웹 페이지를 가져와 데이터를 추출함
* 사이트맵 : 사이트 보유자가 제공하는 사이트의 페이지, 동영상, 파일과 각 관계에 대한 정보가 저장됨
* 스파이더 소프트웨어 : 사이트가 주어지면 해당 사이트에 연결된 하이퍼링크를 타고 해당 사이트로 가 다시 탐색을 반복하는 소프트웨어
* 과거의 크롤링 결과 웹 주소 목록과 사이트맵을 사용해서 스파이더 소프트웨어로 웹을 돌아다니며 색인을 생성

### 2. 검색 알고리즘
* 단어 분석 : 처음 검색어가 주어지면 먼저 검색어의 철자가 잘못된건 없는지 등을 확인
  * 최근에는 자연어 데이터까지 사용하여 동의어 중 어떤 의미인지 등 구문을 해석해 사용
  * 검색어의 구체성, 광범위성, 범위, 분류 등 고려
* 페이지 분석 : 검색어와 일치하는 정보가 포함된 웹페이지 검색
  * 페이지의 제목, 텍스트, 본문 등 어떤 위치에 자주 등장하는지
  * 사이트의 문서는 어떤 언어로 작성되었는지
  * 걱색어의 환경 또는 배경 고려
* 국가, 위치, 이전 검색 기록 등을 고려하여 맞춤 검색 결과 제공
* 페이지 랭크 : 컨텐츠의 최신성, 등장 빈도, 페이지의 우수성 등을 고려해 스코어를 매김
  * 기본적인 구글의 페이지 랭크 알고리즘 PR (Page Rank)
  * P는 페이지, d는 Damping factor로 사용자가 다른 링크를 클릭할 확률이라 보면 되고 0.85정도가 논문의 실험적 최적값, C는 페이지 내의 링크 갯수

    $$PR(P)=(1 - d) + d(PR(P_1) / C(P_1) + ... + PR(P_n)/C(P_n))$$

  * 선형 대수로 나타낼 수도 있음
    * A를 웹들의 인접 행렬 (Adjacency Matrix) 이라고 하고, S는 사이트 내의 링크 갯수로 나눈 행렬, S에서 링크가 없는 페이지는 1/n을 기본값으로 채워줌. E는 전체가 1/n으로 채워진 행렬이고 이 때 구글 랭크를 G라고 두고, G의 고유 벡터 (Eigen Vector) 중 고유값 (Eigen Value) 이 가장 큰 값을 고르면 PR이라고 볼 수 있음

        ![](/assets/images/markdown-img-paste-20190310144503809.png)

    $$
    A =\begin{bmatrix}
      0 & 1 & 1 & 1 & 0 \\
      1 & 0 & 0 & 1 & 0 \\
      0 & 0 & 0 & 1 & 0 \\
      1 & 0 & 0 & 0 & 0 \\
      0 & 0 & 1 & 0 & 0 \\
    \end{bmatrix}
    $$

    $$
    S =\begin{bmatrix}
      0 & 1 & 1/2 & 1/3 & 1/5 \\
      1/2 & 0 & 0 & 1/3 & 1/5 \\
      0 & 0 & 0 & 1/3 & 1/5 \\
      1/2 & 0 & 0 & 0 & 1/5 \\
      0 & 0 & 1/2 & 0 & 1/5 \\
    \end{bmatrix}
    $$

    $$
    E =\begin{bmatrix}
      1/5 & 1/5 & 1/5 & 1/5 & 1/5 \\
      1/5 & 1/5 & 1/5 & 1/5 & 1/5 \\
      1/5 & 1/5 & 1/5 & 1/5 & 1/5 \\
      1/5 & 1/5 & 1/5 & 1/5 & 1/5 \\
      1/5 & 1/5 & 1/5 & 1/5 & 1/5 \\
    \end{bmatrix}
    $$

    $$ G = (1-d)E + dS $$

    $$ PR = MAX_{EigenValue}(EigenVector(G)) $$

* 1에서 만든 색인에서 검색어를 기반으로 사이트들의 리스트를 뽑고 해당 리스트를 페이지 랭크에 따라 정렬해서 보여줌

### 3. 다양한 검색 결과
* 검색 결과를 단순히 사이트의 리스트로 보여주는 것이 아니라, 날씨일 경우 날씨 정보를 상단에 보여주고, 일기예보의 경우도 마찬가지
* 다양한 검색 결과를 보여줌


---

# JVM (Java Virtual Machine)
* Javac(자바 컴파일러)에 의해 만들어진 Byte code(.class파일)을 OS에 맞게 해석
* OS에 독립적이게 JAVA 실행 가능
* JVM 인스턴스 : 자바 바이트코드로 컴파일된 컴퓨터 프로그램을 실행하는 프로세스

## 아키텍처

![](/assets/images/markdown-img-paste-20190310021509195.png)

### Class Loader
* 런타임 중 클래스(`.class`)를 로드 (Runtime Data Area에 올려줌)
* 바이트 코드가 제대로 작성되었는지 검사
* 객체 생성 시 메모리에 올려줌
* Lazy-loading (지연 로딩), Caching (캐싱) 등을 이용

### Runtime Data Areas
* 프로그램 수행을 위한 JVM의 메모리 공간
* **PC Register, JVM Stack, Native Method Stack은 스레드마다** 생성되며, **Method Area, Heap은 모든 스레드가 공유**함

  |Space|Description|
  |--|--|
  |PC Registers|프로그램 카운터 (스레드 용). 실제 PC처럼 레지스터 단에서 작동하지는 않고 Stack 기반 작동. Method Byte나 Native Pointer. Native Method 실행 시는 JVM거치지 않고 API로 바로 수행|
  |JVM Stack|스레드를 위한 Stack. 스레드 시작 시 생성되며, 각 스레드 별로 생성. 일반 프로그램에서 Stack 영역이라 생각하면 될 듯 (지역 변수, 임시 변수, 매개 변수 등 저장)|
  |Native Method Stack|JNI를 통해 호출되는 자바 외 네이티브 코드를 위한 Stack 공간|
  |Method Area|모든 스레드가 공유하는 메모리 영역. 일반 OS의 Data 영역이라고 생각하면됨. Type 데이터들 (클래스, 인터페이스, 메소드, 필드, 전역 변수 등) 보관. 각 Type마다 **Runtime Constant Pool**을 가짐. 해당 풀은 메소드, 필드, 상수 등의 레퍼런스를 가지고 있어 실제 물리적 메모리 위치 참조. Runtime Constant Pool은 추후 참조해서 실행할 바이트 코드를 따로 찾아 메모리에 적재하는 동적 로딩을 가능하게함|
  |Heap|클래스의 객체를 생성하면 Heap에 저장. 일반 OS의 동적 메모리 할당을 위한 Heap과 같음|

### Excution Engine
로드된 클래스의 Byte code를 실행하는 런타임 모듈. Runtime Data Area 영역의 바이트 코드를 실행하는 모듈. 자바 바이트 코드 단위로 읽어서 실행

#### JIT / Interpreter
* 자바 바이트 코드를 기계 언어로 번역해줌
* JVM은 JIT과 Interpreter를 함께 사용함
* 스레드 스케쥴링 담당
* **Interpreter** : 기존에 JVM은 인터프리터만을 사용했음. 인터프리터는 바이트 코드를 명령어 단위를 읽고 실행하기 때문에 컴파일 방식보다 속도가 느림
* **JIT** : 인터프리터의 단점을 상쇄하기 위해 도입한 Just-In-Time 컴파일러. JVM은 인터프리터 방식으로 코드를 진행하다가, 해당 코드가 실행되는 빈도수를 체크하여 자주 실행되는 코드를 JIT를 통해 바이트코드를 컴파일하고 이를 캐싱하여 속도를 빠르게 함. JIT로 컴파일된 코드는 인터프리터 형식보다 빠르긴 하지만 컴파일 하는 시간이 오래 걸리기 때문에 융합해서 사용

#### Garbage Collector
* C/C++등 기존 프로그래밍 언어의 경우 프로그래머가 프로그램 메모리를 관리해줘야 했지만, 자바에서는 JVM이 프로그램 메모리를 관리해줌
* 자바 프로그램에서 사용되지 않는 메모리 지속적으로 찾아내 제거
* 참조되지 않은 객체들 탐색 및 삭제
* GC는 Heap과 Method Area를 관리

##### Method Area / Heap
* Heap은 다시 **Eden, 두 개의 Survivor, Old** 총 4개의 영역으로 나뉘어짐

  ![](/assets/images/markdown-img-paste-20190310000941340.png)

* **Young Generation 영역**
  * Old 보다 사이즈도 작고 객체가 잔존하는 시간도 짧음
  * 대부분 객체는 잠깐 생성되었다가 금방 접근 불가능 상태가되기 때문에 Young에 생성되었다가 사라짐
  * 여기서 GC가 발생하면 **Minor GC**
* **Old Generation 영역**
  * Young 보다 사이즈가 크지만 객체가 잔존하는 시간이 김
  * 여기서 GC가 발생하면 **Major GC**
* **Permanent Generation 영역**
  * Method Area를 뜻함
  * 여기서 GC가 발생하면 **Major GC**
* Old의 객체는 카드 테이블(Card Table)을 가지고 있어 Old의 객체가 Young의 객체를 참조하면 Young 영역에서 GC 발생 시 카드 테이블만 뒤져 Old에서 GC 대상이 무엇인지 판별해 전반적인 GC 시간이 줄어듬

##### **Minor GC**
1. 최초 객체 생성 시 Eden에 생성
2. Eden에서 GC가 발생한 후 남은 객체들을 Survivor1으로 이동
3. 1, 2를 계속 반복하면 Survivor1에 객체들이 쌓임
4. Survivor1이 가득찼다면 GC 수행 후, 살아남은 객체들을 Survivor2로 모두 옮김 (Survivor1은 빈상태)
5. 이후에는 Survivor2에서 2, 3을 실행하고 4에서는 Survivor1으로 모두 옮김 (Survivor2가 빈상태)
6. 1 ~ 5를 계속 **반복해도 살아 남은 객체** 혹은 Eden영역의 살아있는 객체가 Survivor 영역 보다 더 많은 경우 **Old영역으로** 이동
* 위의 방법을 보면 **Survivor1이나 Survivor2 둘 중 하나는 반드시 비어있어야함**. 둘 다 데이터가 존재하거나, 둘 다 데이터가 없다면 시스템이 오류를 일으킨것
* HotSpot VM의 경우 더 빠른 메모리 할당을 위해 **Bump-the-pointer**라는 기술 사용
  * **Bump-the-pointer** : Eden에 삽입된 마지막 객체는 Eden 영역의 가장 위 (Top)에 있는데 이를 가리키는 포인터를 말함. 이 포인터를 이용해 해당 객체가 Eden에 들어갈 수 있는 크기인지만 확인해서 적당하다면 Eden에 삽입. 마지막 객체만 확인하면 되므로 매우 빠르게 객체 할당 일어남
  * **TLABs(Thread-Local Allocation Buffers)** : Bump-the-pointer의 경우 멀티 스레딩 환경이라면 Eden에 객체를 저장할 때 마다 Lock을 걸어야해 비효율적. 이를 위해 TLABs는 각각의 스레드가 Eden에서 일정 부분의 작은 영역을 가질 수 있고 각 스레드는 해당 영역만 접근 할 수 있도록해 Lock없이 메모리 접근 가능

##### **Major GC (Full GC)**
* 보통 Old 영역이 가득차면 Major GC를 수행
* 5가지 방법 존재
  * **Serial GC** : Young은 앞의 Minor GC 사용. Old 영역 GC는 Mark-Sweep-Compact 사용. Mark는 첫 단계로 Old에서 살아 있는 객체를 식별. Sweep은 Heap의 앞부분부터 확인하여 살아 있는 객체만 남김. Compact는 각 객체들 사이에 빈 공간이 없도록 메모리를 앞부터 순서대로 정렬. 싱글 코어 CPU에서 사용
  * **Parallel GC** : Serial GC의 병렬화 알고리즘. 기본 알고리즘은 Serial GC와 똑같음. 멀티 코어 CPU에서 사용
  * **Parallel Compacting(Old) GC** : Serial GC와 달리 Mark-Summary-Compact 사용. Sweep의 경우 단일 스레드가 Heap을 훑지만, Summary의 경우 여러 스레드가 Old 영역을 분리하여 훑음
  * **Concurrent Mark & Sweep GC (CMS)**
    * Initial Mark : 클래스 로더에서 가장 가까운 객체 중 살아있는 객체 찾음 (짧은 Stop-the-world)
    * Concurrent Mark : Initial Mark에서 살아남은 객체의 참조를 따라가며 살아있는 객체를 찾음
    * Remark : Concurrent Mark 수행 중 객체가 끈기거나, 새롭게 생긴 객체가 없는지 확인 (짧은 Stop-the-world)
    * Concurrent Sweep : 쓰레기 정리
    * 별도의 Compaction 단계가 없어 멈추는 시간이 짧지만 시스템 자원을 더 소모하고, Old 영역 크기가 충분치 않거나 크기에 비해 조각난 메모리가 많으면 오히려 Stop-the-world 시간이 늘어남
  * **G1(Garbage First) GC**

    ![](/assets/images/markdown-img-paste-20190310014959227.png)

    * 앞선 GC들과 달리 Young, Old 나누지 않고 바둑판 모양의 영역이 각각 Eden, Survivor, Old 역할을 모두 함. 역할들이 동적으로 바뀌면서 GC가 일어남

### JNI(Java Native Interface)
* 자바로 구현되지 않은 네이티브 코드를 호출 가능하게 해주는 프레임워크

### Native Method Libraries
* JNI 실행에 필요한 라이브러리들

---

# RESTful
## REST
REpresentational State Transfer
* WWW 소프트웨어 아키텍처 중 하나
* ROA 따름

## ROA
* Resource Oriented Architecture
* 행동 보다는 리소스에 주안
* HTTP 사용
* URI에 명사 사용
* 리소스의 표현과 분리

## 아키텍처
* Resource (URI) : 자원
* Services (HTTP : POST, GET, PUT, DELETE) : 액션
* Representation (JSON, XML 등) : 표현

## 장점
* 서버를 데이터 저장소라 생각해 클라이언트의 이식성 높아짐
* 클라이언트가 UI와 유저 상태 고려
  * 서버가 더 간단해짐
* 서버와 클라이언트 따로 개발 가능
* Stateless : 서버는 클라이언트 상태를 저장하지 않음
* Cacheable : 클라이언트가 응답을 캐싱 가능

## REST 디자인
* Uniform interface : REST를 디자인한 가장 큰 이유
  * 아키텍처를 간소화함
  * Identification of resources : 각 자원은 요청(Request)에서 확인(Identify) 가능. 하지만 실제 자원과 표현은 별개!
  * 표현을 통해 자원 변경 : 클라이언트가 자원의 표현을 안다면 충분히 자원을 조작 가능
  * Self-descriptive message : 각각의 메시지안에는 자원이 명확하게 명시되어 있음 (읽기 편함)

    ```
    "students":
		[
			{"name":"Rhino", "major":"Computer Science"},
			{"name":"Anderson", "major":"Health"},
			{"name":"Peter", "lastName":"Statistics"}
		]
    ```

  * Hypermedia As The Engine Of Application State (HATEOAS)
    * HATEOAS-driven 사이트들은 사이트의 REST 인터페이스에 동적으로 접근할 수 있도록 Response에 링크를 걸어서도 보냄

    ```
    GET /account/12345 HTTP/1.1
    HTTP/1.1 200 OK
    <?xml version="1.0"?>
    <account>
      <account_number>12345</account_number>
      <balance currency="usd">100.00</balance>
      <link rel="deposit" href="/account/12345/deposit"/>
      <link rel="withdraw" href="/account/12345/withdraw"/>
    </account>
    ```
* HTTP 기반 RESTful API는 다음으로 정의됨
  1. URI
  2. JSON / XML (Media type)
  3. HTTP 함수 (POST, GET, PUT, DELETE)
  4. Hypertext Link (State, Resource)

---

# 아이디어
## [실시간] 검색어 보기 쉽게 시각화
* 현재 실시간 혹은 일반 검색어는 단순히 우측에 숫자만 표시하는 등 사용자가 명확히 얼마나 뜨는지 파악이 힘듬
* 한 눈에 보기 쉽고, 비교도 잘되게 나타낸다면 사람들이 더 관심을 가지고 이해하기 쉬울 것
* 연관 검색어도 그래프 형태로 보기 쉽게 나타낸다면 어떨까?
* 네이버의 실시간 급등 검색어 수식
  * 기대 횟수는 15초 마다 산출, 관측 횟수는 10분간

$$ Score=\dfrac{관측 횟수 - 기대 횟수}{표준편차} + 순위차 보정 + 관측 횟수 보정 $$

$$ 기대횟수=MAX\begin{bmatrix} 과거\ 일주일\ 평균 \\ 어제\ 검색 \end{bmatrix}\times \begin{bmatrix} 시간대\ 특징\ 보정\\전체\ 검색량\ 보정\\실급검\ 노출\ 보정 \end{bmatrix} $$


## 이미지 검색
* 현재 다음은 꽃 검색 지원
* 이미지 자체의 피쳐를 뽑아 검색어 쿼리로 집어넣고, 해당 이미지와 유사한 이미지가 나오게 (Vector 거리 등으로) 계산하면 유사한 이미지 찾을 수 있지 않을까?
* 이미지 자체에서 목적으로 하는 영역을 Crop할 수 있게 사용자가 전처리하게
* 사용자가 이미지의 카테고리를 정해서, 특정 카테고리에서 검색 가능하게

## 카카오톡
* 카카오톡 전체 톡방에 대한 검색

---

# 왜 가고 싶을까

---

# 웹표준 접근성
* 웹 = 문서라고 생각하면됨
* 웹 표준이란, 웹이라는 문서(HTML)을 작성하는 양식을 말함
* **HTML 문서 양식을 준수하는 의미론적인 마크업**
* **접근성** : 가능한 많은 사용자가 불편 없이 서비스를 이용할 수 있도록 하는 것
  * 배경음 사용 금지
  * 키보드 사용 보장
  * 응답시간 조절
  * 정지 기능 제공
  * 사용자 요구에 따른 실행
  * 오류 정정
