---
title: "준비 및 정리"
date: 2019-03-08 19:58:30 -0400
categories: Ready
tags: Ready
mathjax: true
---

# MVC 패턴

# 자바 프레임워크

# 스프링 프레임워크

# 검색 방식

# JVM (Java Virtual Machine)
* Javac(자바 컴파일러)에 의해 만들어진 Byte code(.class파일)을 OS에 맞게 해석
* OS에 독립적이게 JAVA 실행 가능
* JIT 컴파일러 사용
* JVM 인스턴스 : 자바 바이트코드로 컴파일된 컴퓨터 프로그램을 실행하는 프로세스

## 아키텍처
### Class Loader
* 런타임 중 클래스(`.class`)를 로드 (Runtime Data Area에 올려줌)
* 바이트 코드가 제대로 작성되었는지 검사
* 객체 생성 시 메모리에 올려줌
* Lazy-loading (지연 로딩), Caching (캐싱) 등을 이용

### Runtime Data Areas
* 프로그램 수행을 위한 JVM의 메모리 공간
* PC Register, JVM Stack, Native Method Stack은 스레드마다 생성되며, Method Area, Heap은 모든 스레드가 공유함

  |Space|Description|
  |--|--|
  |PC Registers|프로그램 카운터 (쓰레드 용). 실제 PC처럼 레지스터 단에서 작동하지는 않고 Stack 기반 작동. Method Byte나 Native Pointer. Native Method 실행 시는 JVM거치지 않고 API로 바로 수행|
  |JVM Stack|쓰레드를 위한 Stack. 쓰레드 시작 시 생성되며, 각 쓰레드 별로 생성. 일반 프로그램에서 Stack 영역이라 생각하면 될 듯 (지역 변수, 임시 변수, 매개 변수 등 저장)|
  |Native Method Stack|JNI를 통해 호출되는 자바 외 네이티브 코드를 위한 Stack 공간|
  |Method Area|모든 쓰레드가 공유하는 메모리 영역. 일반 OS의 Data 영역이라고 생각하면됨. Type 데이터들 (클래스, 인터페이스, 메소드, 필드, 전역 변수 등) 보관. 각 Type마다 Runtime Constant Pool을 가짐. 해당 풀은 메소드, 필드, 상수 등의 레퍼런스를 가지고 있어 실제 물리적 메모리 위치 참조. Runtime Constant Pool은 추후 참조해서 실행할 바이트 코드를 따로 찾아 메모리에 적재하는 동적 로딩을 가능하게함|
  |Heap|클래스의 객체를 생성하면 Heap에 저장. 일반 OS의 동적 메모리 할당을 위한 Heap과 같음|

### Excution Engine
로드된 클래스의 Byte code를 실행하는 런타임 모듈. Runtime Data Area 영역의 바이트 코드를 실행하는 모듈. 자바 바이트 코드 단위로 읽어서 실행

#### JIT / Interpreter
* 자바 바이트 코드를 기계 언어로 번역해줌
* 처음 JVM은 Interpreter만을 사용해서 한 줄씩 읽고 해석해 속도가 느렸지만, JIT 컴파일러를 도입해서 속도를 향상시킴
* JIT는 Byte Code를 Native Code로 바꾼 후 캐싱을 하기 때문에 실행이 빠름. 하지만 모든 코드를 Native Code로 바꾸는 작업도 비용이 소모되기 때문에 적절히 Interpreter와 JIT를 함께 사용함


#### Garbage Collector
* C/C++등 기존 프로그래밍 언어의 경우 프로그래머가 프로그램 메모리를 관리해줘야 했지만, 자바에서는 JVM이 프로그램 메모리를 관리해줌
* 자바 프로그램에서 사용되지 않는 메모리 지속적으로 찾아내 제거
* 참조되지 않은 객체들 탐색 및 삭제
* Heap은 5개의 영역인 Eden, Survivor1, Survivor2, Old, Permanent로 나뉘어짐
* GC는 Minor GC, Major GC로 나뉘어짐
* Minor GC
  1. 최초 객체 생성 시 Eden에 생성
  2. Eden에 객체가 가득 차면 GC가 일어남
  3. Survivor1에 Eden이 그대로 복사됨. 그 후 Survivor1 영역 제외한 다른 영역의 객체 제거
  4. Eden 영역도 가득차고  Survivor1 영역도 가득 찬다면, Eden 영역의 객체와 Survivor1 영역의 객체 중에 참조되고 있는 객체가 있는지 확인
  5. 참조되고 있는 객체는 Survivor2 영역에 복사 후 다른 영역의 객체들 제거
  6. 위 과정 중 일정 횟수 이상 참조되고 있는 개체들을 Survivor2에서 Old 영역으로 이동
  7. 1 ~ 6을 반복하고, Survivor2 영역까지 꽉차기 전까지는 Old로 이동
* **Major GC (Full GC)**
  1. Old의 모든 객체들을 검사하여 참조되고 있는지 확인
  2. 참조되지 않은 객체들을 모아 한 번에 제거
  * Old에 참조가 되지 않는 객체들을 모두 제거하게되면 Heap 영역 중간 중간에 생기는 빈공간을 없애기 위해 재구성을 하게 되는데 이 때문에 메모리 재구성 중 다른 쓰레드의 작동을 정지시킴
  
  

### JNI(Java Native Interface)
* 자바로 구현되지 않은 네이티브 코드를 호출 가능하게 해주는 프레임워크

### Native Method Framework
* JNI 실해에 필요한 라이브러리들


# RESTful
## REST
REpresentational State Transfer
* WWW 소프트웨어 아키텍처 중 하나
* ROA 따름

## ROA
* Resource Oriented Architecture
* 행동 보다는 리소스에 주안
* HTTP 사용
* URI에 명사 사용
* 리소스의 표현과 분리

## 아키텍처
* Resource (URI) : 자원
* Services (HTTP : POST, GET, PUT, DELETE) : 액션
* Representation (JSON, XML) : 표현

## 장점
* 서버를 데이터 저장소라 생각해 클라이언트의 이식성 높아짐
* 클라이언트가 UI와 유저 상태 고려
  * 서버가 더 간단해짐
* 서버와 클라이언트 따로 개발 가능
* Stateless : 서버는 클라이언트 상태를 저장하지 않음
* Chcheable : 클라이언트가 응답을 캐싱 가능

## REST 디자인
* Uniform interface : REST를 디자인한 가장 큰 이유
  * 아키텍처를 간소화함
  * Identification of resources : 각 자원은 요청(Request)에서 확인(Identify) 가능. 하지만 실제 자원과 표현은 별개!
  * 표현을 통해 자원 변경 : 클라이언트가 자원의 표현을 안다면 충분히 자원을 조작 가능
  * Self-descriptive message : 각각의 메시지안에는 자원이 명확하게 명시되어 있음 (읽기 편함)

    ```
    "students":
		[
			{"name":"Rhino", "major":"Computer Science"},
			{"name":"Anderson", "major":"Health"},
			{"name":"Peter", "lastName":"Statistics"}
		]
    ```

  * Hypermedia As The Engine Of Application State (HATEOAS)
    * HATEOAS-driven 사이트들은 사이트의 REST 인터페이스에 동적으로 접근할 수 있도록 Response에 링크를 걸어서도 보냄

    ```
    GET /account/12345 HTTP/1.1
    HTTP/1.1 200 OK
    <?xml version="1.0"?>
    <account>
      <account_number>12345</account_number>
      <balance currency="usd">100.00</balance>
      <link rel="deposit" href="/account/12345/deposit"/>
      <link rel="withdraw" href="/account/12345/withdraw"/>
    </account>
    ```
* HTTP 기반 RESTful API는 다음으로 정의됨
  1. URI
  2. JSON / XML (Media type)
  3. HTTP 함수 (POST, GET, PUT, DELETE)
  4. Hypertext Link (State, Resource)

# 아이디어
## [실시간] 검색어 보기 쉽게 시각화
* 현재 실시간 혹은 일반 검색어는 단순히 우측에 숫자만 표시하는 등 사용자가 명확히 얼마나 뜨는지 파악이 힘듬
* 한 눈에 보기 쉽고, 비교도 잘되게 나타낸다면 사람들이 더 관심을 가지고 이해하기 쉬울 것
* 연관 검색어도 그래프 형태로 보기 쉽게 나타낸다면 어떨까?

## 이미지를 검색 쿼리로
* 이미지 자체의 피쳐를 뽑아 검색어 쿼리로 집어넣고, 해당 이미지와 유사한 이미지가 나오게 (Vector 거리 등으로) 계산하면 유사한 이미지 찾을 수 있지 않을까?
* 이미지 자체에서 목적으로 하는 영역을 Crop할 수 있게 사용자가 전처리하게
* 사용자가 이미지의 카테고리를 정해서, 특정 카테고리에서 검색 가능하게

# 왜 가고 싶을까

# 웹표준 접근성
