---
title: "JAVA 정리"
date: 2019-02-26 02:56:30 -0400
categories: Java
tags: Java
---

# JAVA 정리
## Java Program
Edit → Compile → Load → Verify → Execute 크게 4 부분으로 이루어짐

### Edit
* 자바 소스코드를 작성하는 것 (.java 파일)

### Compile
* javac를 사용하여 소스코드를 컴파일해 바이트코드로 만듬 (.class 파일)
* eg) javac welcome.java

### Load
* JVM(Java Virtual Machine)이 바이트코드를 메모리에 올림
* 디스크나 네트워크의 .class 파일 로드 가능

### Verify
* Load 후 Bytecode varifier가 바이트코드 검사
* 네트워크에서 온 코드의 안전을 위해 강하게 검사

### Execute
* JVM이 바이트코드를 실행
* Interpretation + JIT(Just-in-time) compilation 수행
* 바이트코드를 기계언어로 변환

## 메인 함수
public static void main(String[] args);
* args는 Command-Line arguments

## Javadoc
/** */

## 전체 실행 순서
```
// source.java 작성
source.java
// source.class 생성
javac source.java
// source.class 실행
java source
```
## 표준 출력
* 한 줄 출력 ```System.out.println()```
* 형식을 가진 출력 (C의 printf 같이) ```System.out.printf()```

## 표준 입력
```Scanner(System.in)```
{% highlight java linenos=table %}
import java.util.Scanner;
public class Main {
  public static void main(String[] args) {
    Scanner
  }
}
{% endhighlight %}

## 3항 연산자
C와 동일 ```a > b ? a : b;```

## 메소드
```type methodName(parameters)```

## 변수 초기화
지역 변수 말고는 다 초기값 가짐, String의 경우 null, boolean은 false가 초기값 나머지는 0

## get, set 메소드

## Primitive Type
int, char, boolean, short, long, float, double

## Reference Type
Primitive를 Reference로 가지는 타입 다

## Floating Point
* float : Single precision (소수점 아래 7자리)
* double : Double precision (소수점 아래 15자리)

## Control Statements
if, if-else, while, for, switch, do-while, break, continue

## Static 키워드
정적 메소드 선언
* static 변수 : 클래스 객체들이 모두 공유함
* static 변수나 함수는 클래스 생성을 안하고도 접근 가능
* static 함수는 static이 아닌 클래스 멤버를 부를 수 없음

## Static Import
static import로 클래스의 Static 멤버들 가져올 수 있음

```import static package.class.member;```

## Math 클래스
수학 연산 관련 클래스
{% highlight java linenos=table %}
import java.lang.Math;

Math.abs(x); // 절대값
Math.ceil(x); // 올림
Math.floor(x); // 내림
Math.cos(x); // Cos
Math.sin(x); // Sin
Math.tan(x); // Tan
Math.exp(x); // e^x
Math.log(x); // Log
Math.max(x, y); // 큰 값
Math.min(x, y); // 작은 값
Math.pow(x, y); // x^y
Math.sqrt(x); // 루트
{% endhighlight %}

## Final 키워드
값 변경 불가
* 처음 선언 시 값 할당해야함
* 값 바꾸려하면 컴파일 에러
* 초기화 되기 전에 접근해도 

## Promotion (형 변환)
연산 시 높은 형으로 자동 변환되어서 계산됨

| Type| Valid promotions |
| --- | --- |
| double | None |
| float | double |
| long | float, double |
| int | long, float, double |
| char | int, long, float, double |
| short | int, long, float, double (char X) |
| byte | short, int, long, float, double (char X) |
| boolean | None |

## 랜덤
{% highlight java linenos=table %}
import java.util.Random;

Random rand = new Random();
int randomInteger = rand.nextInt(); // Random
int randomInteger = rand.nextInt(5); // 0 ~ 5
int randomInteger = 5 + rand.nextInt(5); // 5 ~ 10
{% endhighlight %}

## Overloading
이름은 같고 인자는 다른 함수 정의 가능
{% highlight java linenos=table %}
void sum(int a, int b) {
  return a + b;
}
void sum(int a, int b, int c) {
  return a + b + c;
}
{% endhighlight %}

## Java.awt.Graphics
간단하게 그래픽 객체를 그리는 클래스

## Javax.swing.JPanel
그릴 수 있는 공간 제공

## Javax.swing.JFrame
GUI를 띄울 수 있는 창

{% highlight java linenos=table %}
import java.awt.Graphics;
import javax.swing.JPanel;

public class DrawPanel extends JPanel {
  public void paintComponent(Graphics g) {
    super.paintComponent(g);
    int width = getWidth();
    int height = getHeight();
    
    g.drawLine(0, 0, width, height);
    g.drawLine(0, height, width, 0);
  }
}
{% endhighlight %}

{% highlight java linenos=table %}
import javax.swing.JFrame;

public class DrawPanelTest {
  public static void main(String[] args) {
    DrawPanel panel = new DrawPanel();
    
    JFrame application = new JFrame();
    application.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    application.add(panel);
    application.setSize(250, 250);
    application.setVisible(true);
  }
}
{% endhighlight %}

## Array
같은 타입으로 이루어진 변수들의 모음. 한 번 만들어지면 크기는 고정된다
* Array는 Reference type이다
* Array의 Element들은 Primitive type 이거나 Reference type이 될 수 있다
* index로 접근 ```array[0]```
* index는 0부터
* length 변수를 가지고 있어 크기를 알 수 있음 ```array.length```
{% highlight java linenos=table %}
int c[] = new int[12];
int a[];
a[] = new int[12];
int[] n = { 10, 20, 30, 40, 50 }; // Initializer list
{% endhighlight %}

## Arrays Class
{% highlight java linenos=table %}
import java.util.Arrays;

double[] doubleArray = { 8.3, 1.5, 4.6, 7.5 };
Arrays.sort(doubleArray); // 정렬
Arrays.binarySearch(doubleArray); // 이진 검색
Arrays.equals(doubleArray, doubleArray2); // ==
Arrays.fill(doubleArray, 7.0); // 채워넣기

System.arraycopy(srcArray, 0, dstArray, 0, srcArray.length); // 두 번째 네 번째 인자는 시작 위치를 나타냄
{% endhighlight %}

## Enhanced for
간단한 문법으로 Array나 Collection의 아이템에 순차적 반복적으로 접근 가능함
* 값을 쉽게 가져오기 위해 사용 가능하지만 Array의 값을 바꿀 수는 없음
{% highlight java linenos=table %}
for (parameter : arrayName)
  statement;
{% endhighlight %}

## Pass-by-value (Call-by-value)
자바 모든 Argument들은 다 Pass-by-value (값 복사)

## Variable-Length Argument Lists
메소드가 정해지지 않은 개수의 인자를 받을 수 있게 해줌
* ellipsis(...)는 인자 리스트 제일 마지막에만 넣을 수 있음
{% highlight java linenos=table %}
public static double average(double... numbers) {
  double total = 0.0;
  for (double d : numbers)
    total += d;
  return total / numbers.length;
}
{% endhighlight %}

## Collections
자바에서 지원하는 미리 선언된 자료구조들

## ArrayList
Array와 유사하지만 유동적으로 사이즈 변경이 가능하다 (Dynamic Resizing)
```ArrayList<T>```
* Generic class : 여러 형을 받을 수 있는 클래스 <T>
{% highlight java linenos=table %}
import java.util.ArrayList;

ArrayList<String> strs = new ArrayList<String>();
strs.add("Hello"); // Item 추가
strs.add("World");
strs.size(); // Size 반환
strs.get(0); // index의 Item 가져옴
strs.remove(0); // index의 Item 삭제
strs.remove("World"); // index의 Item 삭제
strs.contains("Hello"); // Item이 있는지 확인
{% endhighlight %}

## Predicate method
Condition이 true인지 false인지 나타내는 메소드 eg) ```ArrayList.isEmpty()```

## Class
* 이름 : 대문자로 시작해서 카멜케이스 (eg) JavaClassOne
* Case sensitive (대소문자 구분함)
* private : 외부에서 접근 불가, 접근 시 컴파일 에러
* public : 외부에서 접근 가능
* this : 현재 오브젝트 멤버 접근
* 생성자가 없으면 Default 생성자 자동으로 만들어짐
* 생성자가 하나라도 있으면 Default 생성자 생성 안됨
* 생성자는 Overloading 가능
{% highlight java linenos=table %}
public class ClassName {
  public ClassName() {}
}
{% endhighlight %}

## Composition
클래스는 다른 클래스 오브젝트를 멤버로 가질 수 있음
* has-a relationship 이라고도 함

## Enumerations
* enum 도 Reference type
* enum constant 들은 묵시적으로 final 이자 static 이다
* new enum 은 컴파일 에러
* switch 구문이나 Enhanced for 구문에서 사용 가능
* ```enum.values()```는 enum의 constant들의 collection을 반환함

{% highlight java linenos=table %}
import java.util.EnumSet;
public enum Book {
  JHTP("Java How to Program", "2010"),
  CHTP("C How to Program", "2007"),
  IW3HTP("Internet & World Wide Web How to Program", "2008");
  
  private final String title;
  private final String copyrightYear;
  
  Book (String bookTitle, String year) {
    title = bookTitle;
    copyrightYear = year;
  }
  
  public String getTitle() {
    return title;
  }
  
  public String getCopyrightYear() {
    return copyightYear;
  }

System.out.println(Book.JHTP.getTitle());
for (Book book : Book.values())
  System.out.println(book.getTitle() + book.getCopyrightYear());
  
EnumSet.range(Book.JHTP, Book.CHTP); // EnmSet으로 일정 범위 볼 수 있음
{% endhighlight %}

## Garbage Collector
JVM의 Garbage collector가 Garbage collection을 통해서 Object들이 필요없을 시 메모리를 자동으로 해제함
* ```Object.finalize()```로 Garbage collector에 Object 할당을 해제해 달라고 할 수는 있음, 하지만 함수가 호출되자마나 처리해준다고 보장 못함 (안쓰는게 좋음)
* 객체를 다 쓰고나서 ```object = null```로 명시해 주는 것도 좋음

## String
자바의 String 오브젝트는 immutable (변형 불가능)
* + 나 += 연산은 새로운 String 객체를 만드는 것

## Inheritance (상속)
부모 클래스의 속성을 자식 클래스가 받을 수 있음
* Superclass : 부모
* Subclass : 자식
* 자바는 Single inheritance (하나만 상속 가능)
* 자바의 Class hierarchy는 Object로 부터 시작
* is-a relationship
* Override : 자식 클래스가 부모 클래스의 함수를 재정의 ```@Override```
* ```super.method()``` 형식으로 부모 클래스 함수 접근 가능
* ```super(arguments)``` 형태로 자식 클래스 생성자에서 부모 클래스 생성자 호출 해야함

## Protected
부모 클래스의 멤버, 부모 클래스와 같은 패키지의 클래스들, 자식 클래스가 접근 가능한 멤버

## Polymorphism
프로그램을 일반화 시켜줌
* 자식 클래스들을 모두 부모 클래스로 볼 수 있음
* 부모 클래스를 자식 클래스로 볼 수는 없음 (컴파일 에러)
* Dynamic binding : execution time에 객체가 참조해서 사용하는 매소드가 뭔지 판별

## Abstract class
객체를 만들 수는 없지만 hierarcy를 위해 만듬
* 자식 클래스는 abstract 메소드 모두 구현 필요
* abstract 메소드가 하나라도 있으면 Abstract class
* ```public abstract void method()``` 형태로 함수 정의

## Concrete class
객체를 만들 수 있는 모든 멤버가 구현된 클래스

## Final class
다른 클래스의 부모가 될 수 없음
* 멤버 함수들도 묵시적으로 final

## Interface
연관 없는 클래스들을 일반적인 메소드로 연결해 줄 수 있음
* 인터페이스를 통해 행동 양식을 표준화할 수 있음

{% highlight java linenos=table %}
public interface handle {
  public void turnRight();
  public void turnLeft();
}
public class car implements handle {
  public void turnRight() {
    statement;
  }
  public void turnLeft() {
    statement;
  }
}
{% endhighlight %}

## 자바 Common Interface
* Comparable : 비교문구 사용 가능하게
* Serializable : 직렬화 가능하게 (File IO, Object IO에서 사용)
* Runnable : 멀티스레딩시 사용 가능하게

## Exception Handling
* Exception : 문제가 있다는 걸 알려주는 표시
* try → catch... → finally 순으로 실행
* Throwable : Exception의 부모 클래스
* Finally 블록은 항상 실행되기 때문에 자원을 해제시킬 때 주로 사용
* Stack unwinding : 현재 Try에서 catch 불가능할 시 상위 Try 블록에서 Catch

| Exception | 설명 |
| --- | --- |
| ArrayIndexOutOfBoundsException | 배열 바깥의 인덱스 접근 시 |
| ClassCastException | 클래스 캐스팅 시 |
| NullPointerException | 객체 사용 시 참조가 null 일 경우 |
| ArithmeticException | 정수가 0으로 나누어질 경우 [^1] |
| InputMistmatchException | 입력이 잘못 주어질 경우 (Scanner) |

[^1] floating number가 0으로 나뉠 경우 -Infinity 나 Infinity, 0.0 나누기 0.0 은  NaN
* ```java.lang.Throwable``` 클래스를 상속 받아 Exception handling 가능
* try 문 후에는 꼭 catch 나 finally가 하나 이상 있어야함
* Exception 처리 안되면 프로그램 종료

{% highlight java linenos=table %}
import java.util.InputMismatchException;
import java.util.Scanner;

public static int divide(int a, int b) throws ArithmeticException {
  return a / b;
}
public static void main(String[] args) {
  Scanner scanner = new Scanner(System.in);
  try {
    int a = Scanner.nextInt();
    int b = Scanner.nextInt();
    int result = divide(a, b);
  }
  catch (InputMismatchException e) {
    e.printStackTrace();
  }
  finally {
    // Resource deallocation
  }
}
{% endhighlight %}

## Precondition
메소드가 불려질 때 오류가 없는지

## Postcondition
메소드가 값을 반환 할 때 오류가 없는지

## Assertions
```assert expression;```의  expression이 False일 경우 AssertionError 발생
* ```assert expression : output;```으로 AssertionError 발생 시 표시해줄 output 명시 가능

{% highlight java linenos=table %}
static void method(int a) {
  assert (a >= 0 && a <= 10) : "bad number: " + a;
  return a + 1;
}
{% endhighlight %}

* Assert 사용 시 성능이 저하되기 때문에 따로 옵션을 둬서 실행해야함
{% highlight bash linenos=table %}
java -ea AssertTest
{% endhighlight %}
