---
title: "데이터베이스 정리"
date: 2019-03-04 12:50:30 -0400
categories: Database
tags: Database
---

# 데이터베이스(DB) 정리

---

# 왜 DBMS를 사용하는가?

## DBMS
DBMS (Database Management System), 데이터베이스 관리 시스템
* DB를 사용자가 만들고 관리할 수 있게 해주는 프로그램
* DB를 정의 한다는 것은 DB에 들어갈 **데이터 타입, 구조, 제약 조건** 을 특정하는 것을 말함
* DB에 대한 정의들이나 스펙은 DB Catalog, Dictionary 혹은 **Meta-data** 라는 이름으로 저장됨
* **쿼리**(Query, 질의)란 DBMS에 던지는 질의로서 쿼리를 던지면 DBMS가 그에 맞는 데이터를 보내줌
* **트렌섹션**(Transaction)이란 데이터가 DB로 부터 읽어지거나, DB에 쓰여지는 한 번의 과정을 말함
  * ACID 속성을 따르는 DB Operation의 배열(Sequence)을 말함

  |속성|설명|
  |--|--|
  |Atomicity (원자성)|All or Nothing, 시작에서 끝까지 전체가 성공적으로 수행되었거나, 전혀 수행되지 않거나(부분이 수행되면 안됨)|
  |Consistency (일관성)|트렌섹션이 일어나더라도 제약조건을 계속 만족해야함|
  |Isolation (고립성)|여러 트렌섹션이 동시에 일어나더라도 차례대로 실핸한 것과 같은 효과가 나야함|
  |Durability (지속성)|트렌섹션의 데이터는 다른 트렌섹션이 변경하지 않는 한 변경되지 않아야함|

* DBMS는 S/W, H/W적인 데이터 방어, 보안을 담당하기도함
* **Database System** = DBMS + DB
* **DDL** (Data Definition Language) : Conceptual, External 스키마 정의를 위한 언어
* **DML** (Data Manipulation Language) : DB 관리를 위한 언어 (Retrieval, Insertion, Deletion, Modification)
* **SDL** (Storage Definition Language) : Internal 스키마 정의를 위한 언어
  * 최근 SDL을 제공하는 언어는 없으며, Internal 스키마는 함수, 파라미터, 스토리지 명세로 이루어짐

![](/assets/images/markdown-img-paste-20190304130007739.png)

## DB와 파일 프로세싱의 차이
1. 자기기술성(Self-describing nature)을 위해 DB스키마를 저장하는 카탈로그를 이용함
  * **DB스키마** : DB구조와 제약 조건 등에 관한 전반적인 명세를 기술한 메타데이터 집합
2. 프로그램과 데이터가 서로 독립적 (분리해줌)
3. 데이터에 대한 여러 사용자 View를 제공함 (필요한 데이터만 볼 수 있도록)
4. 데이터 공유와, 다수의 유저의 트렌섹션 프로세싱을 담당

## Three-Schema 아키텍쳐
* 사용자 어플리케이션과 물리적 DB를 나누기위해 사용

#### External 스키마
각각의 사용자에 대한 정보 (=User views), 특정 사용자 그룹에 대해 보여줄 데이터와 숨길 데이터 정의 등

#### Conceptual 스키마
사용자와 의사소통을 DB의 모든 구조가 정의

#### Internal 스키마
물리적인 DB 정보, Conceptual 스키마의 실제 정보가 들어있음, 물리적인 스토리지 구조에 대해 정의
* 맵핑(Mapping) : 만약 사용자가 데이터에 접근하려 한다면 Exterenal -> Conceptual -> Internal 까지가서 데이터를 가져온 다음 반대로 Internal -> Conceptual -> External까지 나오게 되는데 이 때 각 레벨에 맞게 포멧을 변경하는 것을 맵핑이라 한다

![](/assets/images/markdown-img-paste-20190304132153712.png)

## 데이터 독립성 (Data Independence)
한 레벨의 스키마를 수정하더라도 상위 레벨의 스키마에는 변화가 없는 DB의 능력

#### Logical Data Independence
Conceptual 스키마를 수정하더라도 External 스키마나 어플리케이션 프로그램에 영향을 주지 않음. View 정의 정도는 수정해줘야함

#### Physical Data Independence
Internal 스키마를 수정하더라도 Conceptual 스키마를 바꿀 필요는 없음, 그렇기 때문에 External 스키마도 수정하지 않아도됨

---

# Relational Data Model (관계 데이터 모델)

## Relational Data Model
Table과 집합 이론, 1차 Predicate 로직을 사용한 모델
* Oracle DBMS가 사용
* **SQL 쿼리 언어** 가 상업적 DBMS의 표준
* Relational algebra와 Relational calculus는 관계 모델의 형식 언어. Relational calculus는 SQL 언어 제작 시, Relational algebra는 DB 구현 및 쿼리 프로세싱과 최적화 시 사용

![](/assets/images/markdown-img-paste-20190304140510345.png)

#### Operation
* Retrieval : query
* Modification : insert, delete, update

### The Structure Component of the Relational Model (구조)
Relation, 관계의 구조 (Tuple, Attribute, Value 등)

#### Relation 스키마 R(A1, A2, ... An)
* R은 Relation 이름, A1 ~ An은 Attribute 들
* Relation 안의 튜플은 순서를 가지지 않음 (집합)

|스키마|설명|
|--|--|
|**Tuple**|값들의 순서 리스트, t=<v1, v2, ..., vn>, n-tuple이라고도 함|
|**t[Ai], t.Ai**|튜블 t의 Attribute Ai의 값, dom(Ai)의 한 원소|
|**Domain** (dom)|Attribute가 가질 수 있는 값의 집합, 제약 조건이라 할 수 있음|
|**t[Au, Aw, ..., Az], t.(Au, Aw, ..., Az)**|Attribute Au, Aw, .. Az의 값을 포함하는 **서브튜플** <vu, vw, ... vz>|
|**R에서 D로의 맵핑**|D = dom(A1) U dom(A2) U ... U dom(An) 일 때 Tuple t를 R에서 D로의 맵핑이라함|
|**Relation Instance**|r(R) or r : r(R) = {t1, t2, ..., tm}, 튜플의 집합|

### The Integrity Component of the Relational Model (완전성)
Constraints, 제약 조건, Relation의 모든 Relation instance들이 만족해야하는 조건

#### Key Constraint
* NULL Value : 해당 사항 없음 혹은 누락

|키|설명|
|--|--|
|**Superkey**(슈퍼키)|**Attribute 집합 A** 중 한 Relation 안의 두 튜플 T1, T2의 A 값들이 모두 다를 경우 (T1[A] != T2[A]) A를 Superkey 라함, 유일하지만 최소는 아님|
|**Key**(키)|최소 Superkey라고 생각하면됨. Superkey를 구성하는 Attribute 중 어느 하나라도 빠지면 Superkey가 될 수 없을 경우, 유일하고 최소|
|**Candidate key**(후보키)|키의 집합|
|**Primary key**(기본키)|Candidate key 중 선택된 하나의 메인 키, NULL이면 안되고, 동일한 값 중복되어 저장될 수 없음|
|**Alternative key**(대체키)|Candidate key 중 Primary key를 제외한 키|
|**Foreign key**(외래키)|릴레이션 R1에서 다른 릴레이션 R2의 Primary key를 가리키는 키, 다른 릴레이션 참조 가능하게 만듬,Foreign key의 도메인은 R2의 Primary key의 도메인과 같아야함, Foreign key의 Attribute들을 **Reference**라고함|

#### Domain Constraint
각 열은 그 열(Attribute)의 **<데이터 타입, 범위>** 를 만족해야함
* 범위가 데이터 타입 마다 똑같을 필요는 없음
* 범위는 default value (기본값), NOT NULL constraint, CHECK constraint, collations 등등 사용 가능

#### Constraints on NULLs
NULL, NOT NULL constraints

#### Entity Integrity Constraints
Primary 키의 열은 무조건 NOT NULL

#### Referential Integrity Constraints
Foreign 키는 참조하는 Relation의 Primary 키와 같은 것을 가지거나 NULL 값을 가져야 함 (Foreign 키의 허상 참조 방지)

#### Oracle의 SQL 구문

![](/assets/images/markdown-img-paste-20190304150612738.png)

#### 변경 연산과 Integry Constraints Violation
변경 연산은 Integrity Constraints를 위반하지 않아야 함
* 위반할 경우 Error 처리 (해당 구문이 수행되지 않은 것과 같음)
* **INSERT (삽입)** : Integrity Constraints를 위반할 가능성이 있음 (NULL)
* **DELETE (삭제)** : Referential Integry Constraints를 위반할 가능성 있음 (다른 데이터가 참조하고 있을 수도 있음)
* **UPDATA (갱신)** : Integrity Constraints를 위반할 가능성이 있음 (이미 참조하는 대상이 있을 경우)


### The Manipulative Component of the Relational Model (구현)
Query language, 쿼리 언어 (Relational algebra(Operation 제작) + Relational calculus(SQL 언어 제작))

#### Relational Argebra (관계 대수)
* Relation들에 대한 질의를 기술하는데 사용하는 기본 연산들의 집합
* 질의 결과 또한 Relation

##### Unary Relational Operation
* **SELECT** $\sigma_c(R)$
  * Relation **R**에서 Selection condition **c**를 만족하는 튜플들을 선택해서 Relation **RR**을 돌려줌
  * **c**는 **R**의 Attribute들에 대한 임의의 Boolean expression, **RR**은 **R**과 동일한 Attribute 가짐
    *  **c** = `[attribute][비교 연산자][상수 값]` or `[attribute][비교 연산자][attribute]`
    *  **[비교 연산자]** : =, <, >, <=, >=, !=
    *  AND, OR, NOT으로 c끼리 연결 가능
  * eg
    * $\sigma_{DNO=4}(EMP)$
    * $\sigma_{SALARY > 30000\ AND\ DNO = 4}(EMP)$
  * Oracle SQL : `select * from EMP where (d_id=4 AND salary > 30000)`
  * Selectivity (선택률) : c에 의해 선택된 튜플의 비율

* **PROJECT** $\Pi_L(R)$
  * Relation **R**에서 **L**에 명시된 Attribute들만 선택해서 Result relation **RR**을 돌려줌
  * **RR**이 집합이므로 **Duplicate elimination** 수행
  * eg
    *  $\Pi_{SEX,SALARY}(EMP)$ : 만약 남자 사원 중 봉급이 10000인 사람이 여러명 있더라도 하나의 튜플만 나온다
  *  Oracle SQL : `select sex, salary from EMP;`

* **Sequence of Operations** and the **RENAME Operation** $\rho$
  * 몇 개의 연산들이 결합되어 Relational algebra expression을 형성
    * eg) 부서 4에 일하는 사원들의 이름과 봉급
      $\Pi_{FNAME, LNAME, SALARY}(\sigma_{DNO=4}(EMP))$
  * 중간 단계 Relation에 이름 부여 가능
    * $DEPT4 \larr \sigma_{DNO=4}(EMP)$
    * $R \larr \Pi_{FNAME, LNAME, SALARY}(DEPT4)$
  * Result relation에 나타나는 Attribute도 Rename 가능
    * $R(FIRSTNAME, LASTNAME, SALARY) \larr \Pi_{FNAME, LNAME, SALARY}(DEPT4)$

##### Relational Algebra Operations from Set Theory
* **UNION** (합집합)
* **INTERSECTION** (교집합)
* **SET DIFFERENCE** (MINUS) (차집합)
* **CROSS PRODUCT** (곱집합)
* UNION, INTERSECTION, MINUS에서는 피연산자 R1, R2의 Attribute 갯수가 같고 서로 Domain이 호환되어야 함
* UNION, INTERSECTION, MINUS의 결과 RR은 R1과 같은 Attribute 이름을 같는다
* eg
  * $DEP\_EMP \larr \Pi_{DNAME, NAME}(\sigma_{MGRSSN=SSN}(DEPT \times EMP))$
  * `select d.dname, e.name from DEPT d, EMP e where d.mgrssn=e.ssn;`

##### Binary Relational Operations
* **JOIN** $R1 \bowtie_c R2$
  * **c** : Join condition
  * 두 개의 Relation R1, R2에서 튜플을 결합하여 긴 튜플을 만들어줌 (R1 기준)
  * eg
    * 모든 DEPT의 이름과 관리자의 이름 검색
    * $RESULT \larr \Pi_{DNAME, FNAME, LNAME}(DEPT \bowtie_{MGRSSN=SSN} EMP)$
    * `select d.dname, e.fanme, e.lname from DEPT d, EMP e where d.mgrssn = e.ssn`
    * `select d.dname, e.fanme, e.lname from DEPT d INNER JOIN EMP e ON (d.mgrssn = e.ssn)`
  * **EQUIJOIN** : **c**가 =로 이루어짐
  * **NATURAL JOIN** : 중복 빼고 한 번만 나오게 할 때 사용 (집합)
  * **Join Selectivity** : 조인 결과 튜플 수 / (R1 튜플 * R2 튜플)
  * 하나의 Relation도 Join 가능
    * $SUPERVISOR(SSSN, SFN, SLN) \larr \Pi_{SSN, FNAME, LNAME}(EMP)$
    * $RESULT \larr \Pi_{FNAME, LNAME, SFN, SLN}(EMP \bowtie_{SUPERSSN=SSSN}SUPERVISOR)$

* **관계적으로 완전(Relationally complete)** 연산
  * **Complete set** : ${\sigma, \Pi, \cup, \rho, -, \times}$

* **DIVISION** $\div$
  * RDBMS에서 제공 안함
  * $S \subseteq R$인 두 Relation r(R), s(R)에 대해
    * $r \div s = \Pi_{R-S}(r)-\Pi_{R-S}((\Pi_{R-S}(r) \times s) - r)$
  * 쉽게 말하면 `R-S Attribute들을 가지는 r'`와 `s`의 곱집합을 원래 r이 모두 가지지 않는다면 해당 R-S 튜플을 제외
  * eg)
    * r(A, B, C, D)={abcd, abef, abde, bcef, edcd, edef}, s(C, D) = {cd, ef}
    * $r \div s$ = {ab, ed}
    * 왜냐하면 bc의 경우 r에 bccd가 없기 때문

##### Additional Relational Operations
* **Generalized Projection**
  * Attribute들에 함수 사용할 수 있게
  * EMP(SSN, SALARY, DEDUCTION, YEARS_SERVICE)
  * $REPORT \larr \rho(SSN, NET\_SALARY, BONUS, TAX)(\Pi_{SSN, SALARY-DEDUCTION, 2000 * YEARS\_SERVICE, 0.25 * SALARY}(EMP))$

* **Aggregate Functions and Grouping**
  * **SUM, COUNT, AVG, MIN, MAX**
    * 값 혹은 튜플 집합에 사용 가능
  * **Grouping**
    * $_{<grouping\ attributes>}\Im_{<function\ list>}(R)$
    * $\Im$ (Script F)
    * eg
      * 모든 사원의 평균 봉급
        * $R(AVGSAL) \larr \Im_{AVG(SALARY)}(EMP)$ (그룹화 안함)
      * 각 부서의 부서 번호와 사원 수와 평균 봉급
        * $R(DNO, NUMEMPS, AVGSAL) \larr _{DNO}\Im_{COUNT(SSN), AVG(SALARY)}(EMP)$
    * Oracle SQL
      * `select avg(salary) from EMP;`
      * `select dno, count(ssn), avg(salary) from EMP group by dno`
      * `select d.dnumber, d.dname, count(ssn), avg(salary) from DEPT d, EMP e where d.dnumber = e.dno group by d.dnumber;`

* **Recursive Closure**
  * 만약 "James Borg" 라는 사람이 지도하는 사람을 알고 싶다면
    1. $BORG\_SSN \larr \Pi_{SSN}(\sigma_{FNAME='James'\ AND\ LNAME='Borg'}(EMP))$
    2. $SUPERVISION(SSN1, SSN2) \larr \Pi_{SSN, SSSN}(EMP)$
    3. $RESULT1(SSN) \larr \Pi_{SSN1}(SUPERVISION \bowtie_{SSN2=SSN} BORG\_SSN))$
  * "James Borg" 라는 사람이 지도하는 사람들이 지도하는 사람
    1. $REULST2(SSN) \larr \Pi_{SSN1}(SUPERVISION \bowtie_{SSN2=SSN} RESULT1)$
  * RESULT1, RESULT2를 합하면
    * $RESULT \larr RESULT1 \cup RESULT2$
  * Oracle SQL
    * `select level, e.name, e.id, e.super_id from EMP e start with id = 10 connect by prior id = e.super_id`

* **OUTER JOIN**
  * EQUIJOIN 이나 NATURAL JOIN에서는 R1 또는 R2에 대응되는 튜플이 없으면 결과에 나타나지 않음
  * OUTER JOIN의 경우 원하는 Relation의 튜플이 모두 나타남
  * INNER JOIN : $R1 \bowtie_c R2$
  * **LEFT OUTER JOIN** : R1의 튜플이 모두 나타남 ![](/assets/images/markdown-img-paste-20190304174000855.png)
  * **RIGHT OUTER JOIN** : R2의 튜플이 모두 나타남 ![](/assets/images/markdown-img-paste-20190304174113866.png)
  * **FULL OUTER JOIN** : R1, R2의 모든 튜플이 나타남
  * Oracle SQL
    * Left : `select e.name, d.dname from EMP e LEFT OUTER JOIN DEPT d ON (e.dno = d.dnumber)`
    * Right : `select e.name, d.dname from EMP e, DEPT d where e.dno = d.dnumber(+)`

* **OUTER UNION**
  * Attribute들이 모두 있는 FULL OUTER JOIN과 동일한 연산
  * Oracle에서는 FULL OUTER JOIN이 없으므로 LEFT OUTER JOIN 결과와 RIGHT OUTER JOIN 결과를 UNION 한다

#### Relational Calculus
* **First order logic** (Predicate logic, First-order predicate calculus)에 기반을 둔 형식 언어
* Relational Algebra와 차이점
  * **Relational Algebra** : Procedure language (절차적, 어떻게(HOW) 검색할 것인가)
  * **Relational Calculus** : 선언적 (비절차적, 무엇(WHAT)을 검색할 것인가)
  * 두 언어의 Expressive power는 동등
  * **Relational Calculus는 SQL의 기반**
* Relational Completeness (관계적 완전성)
  * Relational Algebra와 Relational Calculus의 표현력이 같으므로 관계적으로 완전 (서로가 서로 할 수 있는 일을 할 수 있음)

##### Tuple Relational Calculus
* 쿼리 : `{ t1.Ai, t2.Ak, ... tn.Am | CONDITION(t1, t2, ..., tn+m) }`
* CONDITION이 모두 TRUE인 튜플들이 결과가 됨
* eg
  * `{ t | EMP(t) AND t.SALARY > 50000 }`
  * `{ t.FNAME, t.LNAME | EMP(t) AND t.SALARY > 50000 }`
* **Atom** 단위로 나뉨
  * **R(ti)** : Relation R의 튜플 ti, R에 ti가 있다면 True
  * **ti.A op tj.B** : op는 비교 연산자, A는 ti의 **range** 안, B는 tj의 **range** 안
  * **ti.A op c** or **c op tj.B** : c는 상수값
* **Formula** (Boolean condition)
  * 여러개의 Atom이 AND, OR, NOT으로 연결되어 구성됨
* **Existential** (어떤, $\exists$) and **Universal** (모든, $\forall$) Quantifiers
  * Bound Tuple Variable : 튜플 변수에 수량사(Quantifiers)가 붙었을 경우
  * Free : 튜플 변수에 수량사가 없을 경우
* **RULE**
  1. 모든 Atom은 Formula
  2. F1과 F2가 Formula 라면 (F1 AND F2), (F1 OR F2), NOT(F1) 모두 Formula
  3. F가 Formula라면 $(\exists t)(F)$도 Formula. 하나라도 튜플이 TRUE라면 $(\exists t)(F)$는 TRUE, 아니면 FALSE
  4. F가 Formula라면 $(\forall t)(F)$도 Formula. 모든 튜플이 TRUE라면 $(\forall t)(F)$는 TRUE, 아니면 FALSE
* eg
  * `{ t.FNAME, t.LNAME, t.ADDRESS | EMP(t) AND (∃d)(DEPT(d) AND d.DNAME='Research' AND d.DNUMBER=t.DNO)}`
  * `select e.fname, e.lname, e.address from EMP e, DEPT d where d.dname = 'Research' and d.dnumber = e.dno;`
  * $\Pi_{FNAME, LNAME, ADDRESS}(EMP \bowtie_{DNO = DNUMBER} (\sigma_{DNAME = 'Research'}(DEPT)))$
* **Transforming the Univarsal and Existential Quantifiers**
  ![](/assets/images/markdown-img-paste-20190304191218891.png)
  ![](/assets/images/markdown-img-paste-20190304191136307.png)
* **Safe Expressions**
  * 결과가 유한개 나올 수 있는 표현을 Safe하다고 함
  * { t | NOT (EMP(t)) } 는 Unsafe (Infinitely numerous)

##### Domain Relational Calculus
* 튜플 변수 (Tuple Variables) 대신 Domain variables 사용
* Domain variables는 한 Attribute의 Domain을 범위로 가짐
* eg
  * 이름이 'John B. Smith'인 사원의 생일과 주소 검색 (EMP가 10개의 Attributes 가졌을 경우)
    `{ uv | (∃q)(∃r)(∃s)(EMP(qrstuvwxyz) AND q = 'John' AND r = 'B' AND s = 'Smith')}`
  * QBE의 경우
    `{ uv | EMP('John', 'B', 'Smith', t, u, v, w, x, y, z)}`
  * qrstuvwxyz는 EMP의 Attribute에 각각 맵핑됨


## Database Design Theory

### Functional Dependecy
* R이 Relation scheme이라 하고 $V \subseteq R$이고 $W \subseteq R$ 일 경우
  * **FD (Functional Dependency)** $V \rarr W$가 R에 대해 만족함
  * r(R)의 모든 튜플쌍 t1, t2에 대해서 t1[V] = t2[V] 이면 t1[W] = t2[W] 임
  * eg
    * $student\_id \rarr student\_name$ (학생 ID가 같으면 학생 이름도 같다)
    * $studet\_id, course\_number, year) \rarr grade$ (학생 ID, 코스 번호, 년도가 같다면 점수도 같다)
* $FD\ X \rarr Y$에서 X를 Y의 **Determinant**(결정자)라 함
* $Y \subseteq X$ 일 경우 $FD\ X \rarr Y$을 **Trivial** 이라함
* $X \rarr Y$이고 $Z \rarr Y$, $Z \subset X$인 Z가 있을 때  Y가 X에 **Partially dependent** (부분 의존)하다 하고, Z가 없을 경우 **Fully dependent** (완전 의존)
  * eg) $AB \rarr C$이고 $A \rarr C$라면 C는 AB에 부분 의존
* $X \rarr Y$이고 $Y \rarr Z$일 경우 Z는 X에 **Transitively dependent**하다고 한다
* K가 R의 Super 키라면 $K \rarr R$
* FD의 집합인 F가 있을 때 다른 FD들이 만족하는지 증명할 수 있을 때 그 FD들을 F에 **Logically implied** 되었다고 함

#### Armstring's Axioms
* $FD\ X \rarr Y$에서 좌변 X는 절대 분해하면 안됨

|Rule|Discription|
|--|--|
|Reflexive rule|$Y \subset X$라면 $X \rarr Y$|
|Augmentation rule|$X \rarr Y$라면 $XW \rarr YW$
|Transitivity rule|$X \rarr Y$이고 $Y \rarr Z$라면 $X \rarr Z$
|Union rule|$X \rarr Y$이고 $X \rarr Z$이면 $X \rarr YZ$
|Decomposition rule|$X \rarr YZ$이면 $X \rarr Y$, $X \rarr Z$
|Pseudotransitivity|$X \rarr Y$이고 $YW \rarr Z$라면 $XW \rarr Z$

#### Closure
X가 Attribute들의 집합일 때, X의 Closure($X^+$)는 FD들의 집합 F에서 X에 의해 Functionally determined ($X \rarr F$)된 모든 Attribute들의 집합을 말함

{% highlight c linenos=table %}
def compute_closure(X, F) {
  result = X;
  while(result가 변했으면)
    for each FD Y -> Z in F {
      if (Y ⊆ result) result = result ∪ Z;
    }
}
{% endhighlight %}

* R = { A, B, C, G, H, I }
* F = { A → B, A → C, CG → H, CG → I, B → H }
  ![](/assets/images/markdown-img-paste-20190304195048913.png)
  * A → H는 만족하는가? A → B, B → H 이므로 Transitivity 규칙에 의해 만족
  * AG → I는 만족하는가? Closure안에 있으면 가능
    * $AG^+$
      result = AG
      1st loop:
        result = ABG (A → B)
        result = ABCG (A → C)
        result = ABCGH (CG → H)
        result = ABCGHI (CG → I)
      2nd loop:
        새로운 추가 없음 → 끝
      그러므로 AG → I 만족함

* $F^+$ : FD의 집합 F의 Closure는 F로부터 추론할 수 있는 모든 가능한 FD들의 집합이다

#### Canonical Cover (Minimal Cover)
F의 Canonical Cover Fc는, F가 Fc의 모든 Dependecy들을 Logically implied할 수 있고, Fc 또한 F의 모든 Dependecy들을 Logically implied할 수 있을 때, Dependency의 집합을 Fc라함
* FD에서 어떤 F를 삭제해도 FD의 Closure가 같을 때 F를 **Extraneous attribute**라 한다
* 모든 $FD\ \ X \rarr Y$에 대해 Fc가 X의 Extraneous attribute들을 가지지 않아야함
* 모든 $FD\ \ X \rarr Y$에 대해 Fc가 Y의 Extraneous attribute들을 가지지 않아야함
* FD의 좌변은 Fc에서 Unique

{% highlight c linenos=table %}
def compute_canonical_cover(F) {
  Fc = F;
  for each FD X -> Y in Fc {
    우변에 Attribute 하나만 남게 분해;
  }
  똑같은 FD 끼리 Merge;
  for each FD X -> Y in Fc {
    X_+ = compute_closure(X, Fc - {X -> Y});
    if (Y ⊆ X_+) {
      Fc = Fc - {X -> Y};
    }
  }
  좌변이 같은 것 Merge;
}
{% endhighlight %}


### Normal Forms

#### 1NF, 2NF, 3NF, 4NF
* Relation scheme **R**
* **Prime attribute** : Attribute가 R의 Candidate 키의 멤버일 경우, 아니면 **Nonprime**
* **Transitivity dependency** : $X \rarr Y$에서 $X \rarr Z$, $Z \rarr Y$를 만족하는 R의 호부키도, 어떤 키의 부분 집합도 아닌 Z가 있을 때
* **1NF** : R의 모든 Attribute들의 Domain이 **Atomic**할 경우
  * Domain의 요소(Element)들이 분해할 수 없어 보일 때 Domain을 Atomic이라 함
* **2NF** : R이 1NF이면서, Nonprime attribute들이 R의 모든 키에 Fully dependent할 경우
  * R이 1NF이면서, Nonprime attribute들이 어떤 키에 대해서도 Partially dependent하지 않을 경우
* **3NF** : R에서 $X \rarr A$이고 $A \not\in X$이면서 (a) X가 R의 Super 키이거나, (b) A가 R의 Prime attribute일 경우
  * R의 Nonprime attribute들이 R의 모든 키에 대해서 Fully dependent하고, Nontransitively dependent할 경우
* **BCNF** (Boyee-Codd normal form) : R에서 $X \rarr A$이고 $A \not\in X$이면 X가 R의 Super키일 경우
* 3NF, BCNF는 Insertion, Deletion anomaly와 redundancy로 부터 안전하다

#### First Normal Form (1NF)
* 1NF X

|Student||
|--|--|
|NAME|SEX|
|{peter, john, david}|male|
|{anna, marry}|female|

* 1NF O

|Student||
|--|--|
|NAME|SEX|
|peter|male|
|john|male|
|david|male|
|anna|female|
|marry|female|

#### Transitive Dependency
* `STUDENT(s_id, s_name, year, dept_id, dept_name)`
* `F = { s_id → s_name | year | dept_id | dept_name, dept_id → dept_name, dept_name → dept_name}`
* `Fc = { s_id → s_name | year | dept_id, dept_id → dept_name, dept_name → dept_name}`
* `Key = s_id`
* s_id와 s_name, year, dept_id 는 Fully dependent하고, dept_name은 Transitively dependent함
* 문제점
  * Redundancy (중복) : 같은 d_id에도 d_name이 또 붙음
  * Update Anomaly (변경 이상) : Insertion, Deletion, Modification 시 문제
    * d_name을 바꾼다고 한다면 d_id가 같은 모든 튜플을 다시 찾아내서 바꿔야함
* 3NF(BCNF)로 변환 (Nontransitively dependent하게)
  * `STUDENT(s_id, s_name, year, dept_id)`
  * `DEPARTMENT(dept_id, dept_name)`

![](/assets/images/markdown-img-paste-20190304230318655.png)

#### Partial Dependency
* `STUDENT(id, name, addr, course, year, grade)`
* `F = { id → name | addr, (id, course, year) → grade}`
* `Fc = { id → name | addr, (id, course, year) → grade}`
* `key = (id, course, year)`
* 키에 대해서 grade는 Fully dependent하고, name, addr는 Partially dependent함
* 문제점
  * Redundancy (중복) : 매 과목마다 학생의 이름과 주소를 새로 기록해야함
  * Update anomaly
    * Insertion 시 : 과목이 없으면 학생 정보를 기록할 수 없음
      * (id, course, year)가 기본키인데 course, year가 NULL이 되버림
    * Entity Integrity Constraints가 위배됨
* 2NF (Nonprime attribute들이 키에 대해 Fully dependent하게 만들어줌)
  * `STUDENT(id, name, addr)`
  * `GRADE(id, course, year, grade)`

![](/assets/images/markdown-img-paste-20190304232357476.png)

#### Decomposition
* **Lossless-join decomposition** : R1, R2가 R이 분해된 것이고, $F^+$안에 $R1 \cap R2 \rarr R1$이나 $R1 \cap R2 \rarr R2$가 하나라도 포함된다면
  * 다르게 말하면 `R = R1 JOIN R2`라면 분해 가능
  * 다르게 말하면 $R1 \cap R2$가 R1이나 R2의 키라면 분해가능
* **Dependecy-preserving decomposition** : R1, R2, ..., Rn이 R이 분해된 것일 때, $F'=F1 \cup F2 \cup ... \cup Fn$이고 $F'^+=F^+$ 일 경우

![](/assets/images/markdown-img-paste-20190304233925710.png)

{% highlight c linenos=table %}
def BCNF with Lossless-join decomposition(R) {
  result = {R};
  done = FALSE;
  F_+ 계산;
  while(!done) {
  for each Ri in result {
    if (Ri가 BCNF가 아닐 경우) {
      X → Y가 Nontrivial(Y )
    }
  }
}
{% endhighlight %}
