---
title: "데이터베이스 정리"
date: 2019-03-04 12:50:30 -0400
categories: Database
tags: Database
---

# 데이터베이스(DB) 정리

---

# 왜 DBMS를 사용하는가?

## DBMS
DBMS (Database Management System), 데이터베이스 관리 시스템
* DB를 사용자가 만들고 관리할 수 있게 해주는 프로그램
* DB를 정의 한다는 것은 DB에 들어갈 **데이터 타입, 구조, 제약 조건** 을 특정하는 것을 말함
* DB에 대한 정의들이나 스펙은 DB Catalog, Dictionary 혹은 **Meta-data** 라는 이름으로 저장됨
* **쿼리**(Query, 질의)란 DBMS에 던지는 질의로서 쿼리를 던지면 DBMS가 그에 맞는 데이터를 보내줌
* **트렌섹션**(Transaction)이란 데이터가 DB로 부터 읽어지거나, DB에 쓰여지는 한 번의 과정을 말함
  * ACID 속성을 따르는 DB Operation의 배열(Sequence)을 말함

  |속성|설명|
  |--|--|
  |Atomicity (원자성)|All or Nothing, 시작에서 끝까지 전체가 성공적으로 수행되었거나, 전혀 수행되지 않거나(부분이 수행되면 안됨)|
  |Consistency (일관성)|트렌섹션이 일어나더라도 제약조건을 계속 만족해야함|
  |Isolation (고립성)|여러 트렌섹션이 동시에 일어나더라도 차례대로 실핸한 것과 같은 효과가 나야함|
  |Durability (지속성)|트렌섹션의 데이터는 다른 트렌섹션이 변경하지 않는 한 변경되지 않아야함|

* DBMS는 S/W, H/W적인 데이터 방어, 보안을 담당하기도함
* **Database System** = DBMS + DB
* **DDL** (Data Definition Language) : Conceptual, External 스키마 정의를 위한 언어
* **DML** (Data Manipulation Language) : DB 관리를 위한 언어 (Retrieval, Insertion, Deletion, Modification)
* **SDL** (Storage Definition Language) : Internal 스키마 정의를 위한 언어
  * 최근 SDL을 제공하는 언어는 없으며, Internal 스키마는 함수, 파라미터, 스토리지 명세로 이루어짐

![](/assets/images/markdown-img-paste-20190304130007739.png)

## DB와 파일 프로세싱의 차이
1. 자기기술성(Self-describing nature)을 위해 DB스키마를 저장하는 카탈로그를 이용함
  * **DB스키마** : DB구조와 제약 조건 등에 관한 전반적인 명세를 기술한 메타데이터 집합
2. 프로그램과 데이터가 서로 독립적 (분리해줌)
3. 데이터에 대한 여러 사용자 View를 제공함 (필요한 데이터만 볼 수 있도록)
4. 데이터 공유와, 다수의 유저의 트렌섹션 프로세싱을 담당

## Three-Schema 아키텍쳐
* 사용자 어플리케이션과 물리적 DB를 나누기위해 사용

#### External 스키마
각각의 사용자에 대한 정보 (=User views), 특정 사용자 그룹에 대해 보여줄 데이터와 숨길 데이터 정의 등

#### Conceptual 스키마
사용자와 의사소통을 DB의 모든 구조가 정의

#### Internal 스키마
물리적인 DB 정보, Conceptual 스키마의 실제 정보가 들어있음, 물리적인 스토리지 구조에 대해 정의
* 맵핑(Mapping) : 만약 사용자가 데이터에 접근하려 한다면 Exterenal -> Conceptual -> Internal 까지가서 데이터를 가져온 다음 반대로 Internal -> Conceptual -> External까지 나오게 되는데 이 때 각 레벨에 맞게 포멧을 변경하는 것을 맵핑이라 한다

![](/assets/images/markdown-img-paste-20190304132153712.png)

## 데이터 독립성 (Data Independence)
한 레벨의 스키마를 수정하더라도 상위 레벨의 스키마에는 변화가 없는 DB의 능력

#### Logical Data Independence
Conceptual 스키마를 수정하더라도 External 스키마나 어플리케이션 프로그램에 영향을 주지 않음. View 정의 정도는 수정해줘야함

#### Physical Data Independence
Internal 스키마를 수정하더라도 Conceptual 스키마를 바꿀 필요는 없음, 그렇기 때문에 External 스키마도 수정하지 않아도됨

---

# Relational Data Model (관계 데이터 모델)

## Relational Data Model
Table과 집합 이론, 1차 Predicate 로직을 사용한 모델
* Oracle DBMS가 사용
* **SQL 쿼리 언어** 가 상업적 DBMS의 표준
* Relational algebra와 Relational calculus는 관계 모델의 형식 언어. Relational calculus는 SQL 언어 제작 시, Relational algebra는 DB 구현 및 쿼리 프로세싱과 최적화 시 사용

![](/assets/images/markdown-img-paste-20190304140510345.png)

#### Operation
* Retrieval : query
* Modification : insert, delete, update

### The Structure Component of the Relational Model (구조)
Relation, 관계의 구조 (Tuple, Attribute, Value 등)

#### Relation 스키마 R(A1, A2, ... An)
* R은 Relation 이름, A1 ~ An은 Attribute 들
* Relation 안의 튜플은 순서를 가지지 않음 (집합)

|스키마|설명|
|--|--|
|**Tuple**|값들의 순서 리스트, t=<v1, v2, ..., vn>, n-tuple이라고도 함|
|**t[Ai], t.Ai**|튜블 t의 Attribute Ai의 값, dom(Ai)의 한 원소|
|**Domain** (dom)|Attribute가 가질 수 있는 값의 집합, 제약 조건이라 할 수 있음|
|**t[Au, Aw, ..., Az], t.(Au, Aw, ..., Az)**|Attribute Au, Aw, .. Az의 값을 포함하는 **서브튜플** <vu, vw, ... vz>|
|**R에서 D로의 맵핑**|D = dom(A1) U dom(A2) U ... U dom(An) 일 때 Tuple t를 R에서 D로의 맵핑이라함|
|**Relation Instance**|r(R) or r : r(R) = {t1, t2, ..., tm}, 튜플의 집합|

### The Integrity Component of the Relational Model (완전성)
Constraints, 제약 조건, Relation의 모든 Relation instance들이 만족해야하는 조건

#### Key Constraint
* NULL Value : 해당 사항 없음 혹은 누락

|키|설명|
|--|--|
|**Superkey**(슈퍼키)|**Attribute 집합 A** 중 한 Relation 안의 두 튜플 T1, T2의 A 값들이 모두 다를 경우 (T1[A] != T2[A]) A를 Superkey 라함, 유일하지만 최소는 아님|
|**Key**(키)|최소 Superkey라고 생각하면됨. Superkey를 구성하는 Attribute 중 어느 하나라도 빠지면 Superkey가 될 수 없을 경우, 유일하고 최소|
|**Candidate key**(후보키)|키의 집합|
|**Primary key**(기본키)|Candidate key 중 선택된 하나의 메인 키, NULL이면 안되고, 동일한 값 중복되어 저장될 수 없음|
|**Alternative key**(대체키)|Candidate key 중 Primary key를 제외한 키|
|**Foreign key**(외래키)|릴레이션 R1에서 다른 릴레이션 R2의 Primary key를 가리키는 키, 다른 릴레이션 참조 가능하게 만듬,Foreign key의 도메인은 R2의 Primary key의 도메인과 같아야함, Foreign key의 Attribute들을 **Reference**라고함|

#### Domain Constraint
각 열은 그 열(Attribute)의 **<데이터 타입, 범위>** 를 만족해야함
* 범위가 데이터 타입 마다 똑같을 필요는 없음
* 범위는 default value (기본값), NOT NULL constraint, CHECK constraint, collations 등등 사용 가능

#### Constraints on NULLs
NULL, NOT NULL constraints

#### Entity Integrity Constraints
Primary 키의 열은 무조건 NOT NULL

#### Referential Integrity Constraints
Foreign 키는 참조하는 Relation의 Primary 키와 같은 것을 가지거나 NULL 값을 가져야 함 (Foreign 키의 허상 참조 방지)

#### Oracle의 SQL 구문

![](/assets/images/markdown-img-paste-20190304150612738.png)

#### 변경 연산과 Integry Constraints Violation
변경 연산은 Integrity Constraints를 위반하지 않아야 함
* 위반할 경우 Error 처리 (해당 구문이 수행되지 않은 것과 같음)
* **INSERT (삽입)** : Integrity Constraints를 위반할 가능성이 있음 (NULL)
* **DELETE (삭제)** : Referential Integry Constraints를 위반할 가능성 있음 (다른 데이터가 참조하고 있을 수도 있음)
* **UPDATA (갱신)** : Integrity Constraints를 위반할 가능성이 있음 (이미 참조하는 대상이 있을 경우)


### The Manipulative Component of the Relational Model (구현)
Query language, 쿼리 언어 (Relational algebra(Operation 제작) + Relational calculus(SQL 언어 제작))

#### Relational Argebra (관계 대수)
* Relation들에 대한 질의를 기술하는데 사용하는 기본 연산들의 집합
* 질의 결과 또한 Relation

##### Unary Relational Operation
* **SELECT** $\sigma_c(R)$
  * Relation **R**에서 Selection condition **c**를 만족하는 튜플들을 선택해서 Relation **RR**을 돌려줌
  * **c**는 **R**의 Attribute들에 대한 임의의 Boolean expression, **RR**은 **R**과 동일한 Attribute 가짐
    *  **c** = `[attribute][비교 연산자][상수 값]` or `[attribute][비교 연산자][attribute]`
    *  **[비교 연산자]** : =, <, >, <=, >=, !=
    *  AND, OR, NOT으로 c끼리 연결 가능
  * eg
    * $\sigma_{DNO=4}(EMP)$
    * $\sigma_{SALARY > 30000\ AND\ DNO = 4}(EMP)$
  * Oracle SQL : `select * from EMP where (d_id=4 AND salary > 30000)`
  * Selectivity (선택률) : c에 의해 선택된 튜플의 비율

* **PROJECT** $\Pi_L(R)$
  * Relation **R**에서 **L**에 명시된 Attribute들만 선택해서 Result relation **RR**을 돌려줌
  * **RR**이 집합이므로 **Duplicate elimination** 수행
  * eg
    *  $\Pi_{SEX,SALARY}(EMP)$ : 만약 남자 사원 중 봉급이 10000인 사람이 여러명 있더라도 하나의 튜플만 나온다
  *  Oracle SQL : `select sex, salary from EMP;`

* **Sequence of Operations** and the **RENAME Operation** $\rho$
  * 몇 개의 연산들이 결합되어 Relational algebra expression을 형성
    * eg) 부서 4에 일하는 사원들의 이름과 봉급
      $\Pi_{FNAME, LNAME, SALARY}(\sigma_{DNO=4}(EMP))$
  * 중간 단계 Relation에 이름 부여 가능
    * $DEPT4 \larr \sigma_{DNO=4}(EMP)$
    * $R \larr \Pi_{FNAME, LNAME, SALARY}(DEPT4)$
  * Result relation에 나타나는 Attribute도 Rename 가능
    * $R(FIRSTNAME, LASTNAME, SALARY) \larr \Pi_{FNAME, LNAME, SALARY}(DEPT4)$

##### Relational Algebra Operations from Set Theory
* **UNION** (합집합)
* **INTERSECTION** (교집합)
* **SET DIFFERENCE** (MINUS) (차집합)
* **CROSS PRODUCT** (곱집합)
* UNION, INTERSECTION, MINUS에서는 피연산자 R1, R2의 Attribute 갯수가 같고 서로 Domain이 호환되어야 함
* UNION, INTERSECTION, MINUS의 결과 RR은 R1과 같은 Attribute 이름을 같는다
* eg
  * $DEP\_EMP \larr \Pi_{DNAME, NAME}(\sigma_{MGRSSN=SSN}(DEPT \times EMP))$
  * `select d.dname, e.name from DEPT d, EMP e where d.mgrssn=e.ssn;`

##### Binary Relational Operations
* **JOIN** $R1 \bowtie_c R2$
  * **c** : Join condition
  * 두 개의 Relation R1, R2에서 튜플을 결합하여 긴 튜플을 만들어줌 (R1 기준)
  * eg
    * 모든 DEPT의 이름과 관리자의 이름 검색
    * $RESULT \larr \Pi_{DNAME, FNAME, LNAME}(DEPT \bowtie_{MGRSSN=SSN} EMP)$
    * `select d.dname, e.fanme, e.lname from DEPT d, EMP e where d.mgrssn = e.ssn`
    * `select d.dname, e.fanme, e.lname from DEPT d INNER JOIN EMP e ON (d.mgrssn = e.ssn)`
  * **EQUIJOIN** : **c**가 =로 이루어짐
  * **NATURAL JOIN** : 중복 빼고 한 번만 나오게 할 때 사용 (집합)
  * **Join Selectivity** : 조인 결과 튜플 수 / (R1 튜플 * R2 튜플)
  * 하나의 Relation도 Join 가능
    * $SUPERVISOR(SSSN, SFN, SLN) \larr \Pi_{SSN, FNAME, LNAME}(EMP)$
    * $RESULT \larr \Pi_{FNAME, LNAME, SFN, SLN}(EMP \bowtie_{SUPERSSN=SSSN}SUPERVISOR)$

* **관계적으로 완전(Relationally complete)** 연산
  * **Complete set** : ${\sigma, \Pi, \cup, \rho, -, \times}$

* **DIVISION** $\div$
  * RDBMS에서 제공 안함
  * $S \subseteq R$인 두 Relation r(R), s(R)에 대해
    * $r \div s = \Pi_{R-S}(r)-\Pi_{R-S}((\Pi_{R-S}(r) \times s) - r)$
  * 쉽게 말하면 `R-S Attribute들을 가지는 r'`와 `s`의 곱집합을 원래 r이 모두 가지지 않는다면 해당 R-S 튜플을 제외
  * eg)
    * r(A, B, C, D)={abcd, abef, abde, bcef, edcd, edef}, s(C, D) = {cd, ef}
    * $r \div s$ = {ab, ed}
    * 왜냐하면 bc의 경우 r에 bccd가 없기 때문

##### Additional Relational Operations
* **Generalized Projection**
  * Attribute들에 함수 사용할 수 있게
  * EMP(SSN, SALARY, DEDUCTION, YEARS_SERVICE)
  * $REPORT \larr \rho(SSN, NET\_SALARY, BONUS, TAX)(\Pi_{SSN, SALARY-DEDUCTION, 2000 * YEARS\_SERVICE, 0.25 * SALARY}(EMP))$

* **Aggregate Functions and Grouping**
  * **SUM, COUNT, AVG, MIN, MAX**
    * 값 혹은 튜플 집합에 사용 가능
  * **Grouping**
    * $_{<grouping\ attributes>}\Im_{<function\ list>}(R)$
    * $\Im$ (Script F)
    * eg
      * 모든 사원의 평균 봉급
        * $R(AVGSAL) \larr \Im_{AVG(SALARY)}(EMP)$ (그룹화 안함)
      * 각 부서의 부서 번호와 사원 수와 평균 봉급
        * $R(DNO, NUMEMPS, AVGSAL) \larr _{DNO}\Im_{COUNT(SSN), AVG(SALARY)}(EMP)$
    * Oracle SQL
      * `select avg(salary) from EMP;`
      * `select dno, count(ssn), avg(salary) from EMP group by dno`
      * `select d.dnumber, d.dname, count(ssn), avg(salary) from DEPT d, EMP e where d.dnumber = e.dno group by d.dnumber;`

* **Recursive Closure**
  * 만약 "James Borg" 라는 사람이 지도하는 사람을 알고 싶다면
    1. $BORG\_SSN \larr \Pi_{SSN}(\sigma_{FNAME='James'\ AND\ LNAME='Borg'}(EMP))$
    2. $SUPERVISION(SSN1, SSN2) \larr \Pi_{SSN, SSSN}(EMP)$
    3. $RESULT1(SSN) \larr \Pi_{SSN1}(SUPERVISION \bowtie_{SSN2=SSN} BORG\_SSN))$
  * "James Borg" 라는 사람이 지도하는 사람들이 지도하는 사람
    1. $REULST2(SSN) \larr \Pi_{SSN1}(SUPERVISION \bowtie_{SSN2=SSN} RESULT1)$
  * RESULT1, RESULT2를 합하면
    * $RESULT \larr RESULT1 \cup RESULT2$
  * Oracle SQL
    * `select level, e.name, e.id, e.super_id from EMP e start with id = 10 connect by prior id = e.super_id`

* **OUTER JOIN**
  * EQUIJOIN 이나 NATURAL JOIN에서는 R1 또는 R2에 대응되는 튜플이 없으면 결과에 나타나지 않음
  * OUTER JOIN의 경우 원하는 Relation의 튜플이 모두 나타남
  * INNER JOIN : $R1 \bowtie_c R2$
  * **LEFT OUTER JOIN** : R1의 튜플이 모두 나타남 ![](/assets/images/markdown-img-paste-20190304174000855.png)
  * **RIGHT OUTER JOIN** : R2의 튜플이 모두 나타남 ![](/assets/images/markdown-img-paste-20190304174113866.png)
  * **FULL OUTER JOIN** : R1, R2의 모든 튜플이 나타남
  * Oracle SQL
    * Left : `select e.name, d.dname from EMP e LEFT OUTER JOIN DEPT d ON (e.dno = d.dnumber)`
    * Right : `select e.name, d.dname from EMP e, DEPT d where e.dno = d.dnumber(+)`

* **OUTER UNION**
  * Attribute들이 모두 있는 FULL OUTER JOIN과 동일한 연산
  * Oracle에서는 FULL OUTER JOIN이 없으므로 LEFT OUTER JOIN 결과와 RIGHT OUTER JOIN 결과를 UNION 한다

#### Relational Calculus
* **First order logic** (Predicate logic, First-order predicate calculus)에 기반을 둔 형식 언어
* Relational Algebra와 차이점
  * **Relational Algebra** : Procedure language (절차적, 어떻게(HOW) 검색할 것인가)
  * **Relational Calculus** : 선언적 (비절차적, 무엇(WHAT)을 검색할 것인가)
  * 두 언어의 Expressive power는 동등
  * **Relational Calculus는 SQL의 기반**
* Relational Completeness (관계적 완전성)
  * Relational Algebra와 Relational Calculus의 표현력이 같으므로 관계적으로 완전 (서로가 서로 할 수 있는 일을 할 수 있음)

##### Tuple Relational Calculus
* 쿼리 : `{ t1.Ai, t2.Ak, ... tn.Am | CONDITION(t1, t2, ..., tn+m) }`
* CONDITION이 모두 TRUE인 튜플들이 결과가 됨
* eg
  * `{ t | EMP(t) AND t.SALARY > 50000 }`
  * `{ t.FNAME, t.LNAME | EMP(t) AND t.SALARY > 50000 }`
* **Atom** 단위로 나뉨
  * **R(ti)** : Relation R의 튜플 ti, R에 ti가 있다면 True
  * **ti.A op tj.B** : op는 비교 연산자, A는 ti의 **range** 안, B는 tj의 **range** 안
  * **ti.A op c** or **c op tj.B** : c는 상수값
* **Formula** (Boolean condition)
  * 여러개의 Atom이 AND, OR, NOT으로 연결되어 구성됨
* **Existential** (어떤, $\exists$) and **Universal** (모든, $\forall$) Quantifiers
  * Bound Tuple Variable : 튜플 변수에 수량사(Quantifiers)가 붙었을 경우
  * Free : 튜플 변수에 수량사가 없을 경우
* **RULE**
  1. 모든 Atom은 Formula
  2. F1과 F2가 Formula 라면 (F1 AND F2), (F1 OR F2), NOT(F1) 모두 Formula
  3. F가 Formula라면 $(\exists t)(F)$도 Formula. 하나라도 튜플이 TRUE라면 $(\exists t)(F)$는 TRUE, 아니면 FALSE
  4. F가 Formula라면 $(\forall t)(F)$도 Formula. 모든 튜플이 TRUE라면 $(\forall t)(F)$는 TRUE, 아니면 FALSE
* eg
  * `{ t.FNAME, t.LNAME, t.ADDRESS | EMP(t) AND (∃d)(DEPT(d) AND d.DNAME='Research' AND d.DNUMBER=t.DNO)}`
  * `select e.fname, e.lname, e.address from EMP e, DEPT d where d.dname = 'Research' and d.dnumber = e.dno;`
  * $\Pi_{FNAME, LNAME, ADDRESS}(EMP \bowtie_{DNO = DNUMBER} (\sigma_{DNAME = 'Research'}(DEPT)))$
* **Transforming the Univarsal and Existential Quantifiers**
  ![](/assets/images/markdown-img-paste-20190304191218891.png)
  ![](/assets/images/markdown-img-paste-20190304191136307.png)
* **Safe Expressions**
  * 결과가 유한개 나올 수 있는 표현을 Safe하다고 함
  * { t | NOT (EMP(t)) } 는 Unsafe (Infinitely numerous)

##### Domain Relational Calculus
* 튜플 변수 (Tuple Variables) 대신 Domain variables 사용
* Domain variables는 한 Attribute의 Domain을 범위로 가짐
* eg
  * 이름이 'John B. Smith'인 사원의 생일과 주소 검색 (EMP가 10개의 Attributes 가졌을 경우)
    `{ uv | (∃q)(∃r)(∃s)(EMP(qrstuvwxyz) AND q = 'John' AND r = 'B' AND s = 'Smith')}`
  * QBE의 경우
    `{ uv | EMP('John', 'B', 'Smith', t, u, v, w, x, y, z)}`
  * qrstuvwxyz는 EMP의 Attribute에 각각 맵핑됨


## Database Design Theory

### Functional Dependecy
* R이 Relation scheme이라 하고 $V \subseteq R$이고 $W \subseteq R$ 일 경우
  * **FD (Functional Dependency)** $V \rarr W$가 R에 대해 만족함
  * r(R)의 모든 튜플쌍 t1, t2에 대해서 t1[V] = t2[V] 이면 t1[W] = t2[W] 임
  * eg
    * $student\_id \rarr student\_name$ (학생 ID가 같으면 학생 이름도 같다)
    * $studet\_id, course\_number, year) \rarr grade$ (학생 ID, 코스 번호, 년도가 같다면 점수도 같다)
* $FD\ X \rarr Y$에서 X를 Y의 **Determinant**(결정자)라 함
* $Y \subseteq X$ 일 경우 $FD\ X \rarr Y$을 **Trivial** 이라함
* $X \rarr Y$이고 $Z \rarr Y$, $Z \subset X$인 Z가 있을 때  Y가 X에 **Partially dependent** (부분 의존)하다 하고, Z가 없을 경우 **Fully dependent** (완전 의존)
  * eg) $AB \rarr C$이고 $A \rarr C$라면 C는 AB에 부분 의존
* $X \rarr Y$이고 $Y \rarr Z$일 경우 Z는 X에 **Transitively dependent**하다고 한다
* K가 R의 Super 키라면 $K \rarr R$
* FD의 집합인 F가 있을 때 다른 FD들이 만족하는지 증명할 수 있을 때 그 FD들을 F에 **Logically implied** 되었다고 함

#### Armstring's Axioms
* $FD\ X \rarr Y$에서 좌변 X는 절대 분해하면 안됨

|Rule|Discription|
|--|--|
|Reflexive rule|$Y \subset X$라면 $X \rarr Y$|
|Augmentation rule|$X \rarr Y$라면 $XW \rarr YW$
|Transitivity rule|$X \rarr Y$이고 $Y \rarr Z$라면 $X \rarr Z$
|Union rule|$X \rarr Y$이고 $X \rarr Z$이면 $X \rarr YZ$
|Decomposition rule|$X \rarr YZ$이면 $X \rarr Y$, $X \rarr Z$
|Pseudotransitivity|$X \rarr Y$이고 $YW \rarr Z$라면 $XW \rarr Z$

#### Closure
X가 Attribute들의 집합일 때, X의 Closure($X^+$)는 FD들의 집합 F에서 X에 의해 Functionally determined ($X \rarr F$)된 모든 Attribute들의 집합을 말함

{% highlight c linenos=table %}
def compute_closure(X, F) {
  result = X;
  while(result가 변했으면)
    for each FD Y -> Z in F {
      if (Y ⊆ result) result = result ∪ Z;
    }
}
{% endhighlight %}

* R = { A, B, C, G, H, I }
* F = { A → B, A → C, CG → H, CG → I, B → H }
  ![](/assets/images/markdown-img-paste-20190304195048913.png)
  * A → H는 만족하는가? A → B, B → H 이므로 Transitivity 규칙에 의해 만족
  * AG → I는 만족하는가? Closure안에 있으면 가능
    * $AG^+$
      result = AG
      1st loop:
        result = ABG (A → B)
        result = ABCG (A → C)
        result = ABCGH (CG → H)
        result = ABCGHI (CG → I)
      2nd loop:
        새로운 추가 없음 → 끝
      그러므로 AG → I 만족함

* $F^+$ : FD의 집합 F의 Closure는 F로부터 추론할 수 있는 모든 가능한 FD들의 집합이다

#### Canonical Cover (Minimal Cover)
F의 Canonical Cover Fc는, F가 Fc의 모든 Dependecy들을 Logically implied할 수 있고, Fc 또한 F의 모든 Dependecy들을 Logically implied할 수 있을 때, Dependency의 집합을 Fc라함
* FD에서 어떤 F를 삭제해도 FD의 Closure가 같을 때 F를 **Extraneous attribute**라 한다
* 모든 $FD\ \ X \rarr Y$에 대해 Fc가 X의 Extraneous attribute들을 가지지 않아야함
* 모든 $FD\ \ X \rarr Y$에 대해 Fc가 Y의 Extraneous attribute들을 가지지 않아야함
* FD의 좌변은 Fc에서 Unique

{% highlight c linenos=table %}
def compute_canonical_cover(F) {
  Fc = F;
  for each FD X -> Y in Fc {
    우변에 Attribute 하나만 남게 분해;
  }
  똑같은 FD 끼리 Merge;
  for each FD X -> Y in Fc {
    X_+ = compute_closure(X, Fc - {X -> Y});
    if (Y ⊆ X_+) {
      Fc = Fc - {X -> Y};
    }
  }
  좌변이 같은 것 Merge;
}
{% endhighlight %}


### Normal Forms

#### 1NF, 2NF, 3NF, 4NF
* Relation scheme **R**
* **Prime attribute** : Attribute가 R의 Candidate 키의 멤버일 경우, 아니면 **Nonprime**
* **Transitivity dependency** : $X \rarr Y$에서 $X \rarr Z$, $Z \rarr Y$를 만족하는 R의 호부키도, 어떤 키의 부분 집합도 아닌 Z가 있을 때
* **1NF** : R의 모든 Attribute들의 Domain이 **Atomic**할 경우
  * Domain의 요소(Element)들이 분해할 수 없어 보일 때 Domain을 Atomic이라 함
* **2NF** : R이 1NF이면서, Nonprime attribute들이 R의 모든 키에 Fully dependent할 경우
  * R이 1NF이면서, Nonprime attribute들이 어떤 키에 대해서도 Partially dependent하지 않을 경우
* **3NF** : R에서 $X \rarr A$이고 $A \not\in X$이면서 (a) X가 R의 Super 키이거나, (b) A가 R의 Prime attribute일 경우
  * R의 Nonprime attribute들이 R의 모든 키에 대해서 Fully dependent하고, Nontransitively dependent할 경우
* **BCNF** (Boyee-Codd normal form) : R에서 $X \rarr A$이고 $A \not\in X$이면 X가 R의 Super키일 경우
* 3NF, BCNF는 Insertion, Deletion anomaly와 redundancy로 부터 안전하다

#### First Normal Form (1NF)
* 1NF X

|Student||
|--|--|
|NAME|SEX|
|{peter, john, david}|male|
|{anna, marry}|female|

* 1NF O

|Student||
|--|--|
|NAME|SEX|
|peter|male|
|john|male|
|david|male|
|anna|female|
|marry|female|

#### Transitive Dependency
* `STUDENT(s_id, s_name, year, dept_id, dept_name)`
* `F = { s_id → s_name | year | dept_id | dept_name, dept_id → dept_name, dept_name → dept_name}`
* `Fc = { s_id → s_name | year | dept_id, dept_id → dept_name, dept_name → dept_name}`
* `Key = s_id`
* s_id와 s_name, year, dept_id 는 Fully dependent하고, dept_name은 Transitively dependent함
* 문제점
  * Redundancy (중복) : 같은 d_id에도 d_name이 또 붙음
  * Update Anomaly (변경 이상) : Insertion, Deletion, Modification 시 문제
    * d_name을 바꾼다고 한다면 d_id가 같은 모든 튜플을 다시 찾아내서 바꿔야함
* 3NF(BCNF)로 변환 (Nontransitively dependent하게)
  * `STUDENT(s_id, s_name, year, dept_id)`
  * `DEPARTMENT(dept_id, dept_name)`

![](/assets/images/markdown-img-paste-20190304230318655.png)

#### Partial Dependency
* `STUDENT(id, name, addr, course, year, grade)`
* `F = { id → name | addr, (id, course, year) → grade}`
* `Fc = { id → name | addr, (id, course, year) → grade}`
* `key = (id, course, year)`
* 키에 대해서 grade는 Fully dependent하고, name, addr는 Partially dependent함
* 문제점
  * Redundancy (중복) : 매 과목마다 학생의 이름과 주소를 새로 기록해야함
  * Update anomaly
    * Insertion 시 : 과목이 없으면 학생 정보를 기록할 수 없음
      * (id, course, year)가 기본키인데 course, year가 NULL이 되버림
    * Entity Integrity Constraints가 위배됨
* 2NF (Nonprime attribute들이 키에 대해 Fully dependent하게 만들어줌)
  * `STUDENT(id, name, addr)`
  * `GRADE(id, course, year, grade)`

![](/assets/images/markdown-img-paste-20190304232357476.png)

#### Decomposition
* **Lossless-join decomposition** : R1, R2가 R이 분해된 것이고, $F^+$안에 $R1 \cap R2 \rarr R1$이나 $R1 \cap R2 \rarr R2$가 하나라도 포함된다면
  * 다르게 말하면 `R = R1 JOIN R2`라면 분해 가능
  * 다르게 말하면 $R1 \cap R2$가 R1이나 R2의 키라면 분해가능
* **Dependecy-preserving decomposition** : R1, R2, ..., Rn이 R이 분해된 것일 때, $F'=F1 \cup F2 \cup ... \cup Fn$이고 $F'^+=F^+$ 일 경우

![](/assets/images/markdown-img-paste-20190304233925710.png)

{% highlight c linenos=table %}
def BCNF with Lossless-join decomposition(R) {
  result = {R};
  done = FALSE;
  F_+ 계산;
  while(!done) {
  for each Ri in result {
    if (Ri가 BCNF가 아닐 경우) {
      X → Y가 Nontrivial(Y ⊆ X)이고 X → Ri가 F_+ 안에 없고, X ∩ Y = {∅}인 X, Y;
      result = result - Ri;
      result = result ∪ (Ri - Y);
      result = result ∪ (X, Y);
    }
  }
}
{% endhighlight %}

![](/assets/images/markdown-img-paste-20190305005958510.png)

#### 3NF vs. BCNF

![](/assets/images/markdown-img-paste-20190305010430264.png)

#### Goal with Funcional Dependencies
BCNF나 안되면 3NF로 만들어야 좋음 (3NF는 무조건 만들 수 있음)
* (1NF(2NF(3NF(BCNF))))

#### Good Designs

![](/assets/images/markdown-img-paste-20190305010709228.png)

---

# DBMS (Database Management System)

## Conceptual Data Modeling Using ER Model
ER(Entity-Relationship)
### ER diagram

![](/assets/images/markdown-img-paste-20190305011007294.png)

![](/assets/images/markdown-img-paste-20190305012417379.png)

Mapping Company ER schema into a Relational Database Schema

![](/assets/images/markdown-img-paste-20190305012610348.png)

### SQL

![](/assets/images/markdown-img-paste-20190305012917832.png)

![](/assets/images/markdown-img-paste-20190305012934111.png)

### Example Tables

![](/assets/images/markdown-img-paste-20190305013037586.png)

![](/assets/images/markdown-img-paste-20190305013102817.png)

### ER-to-Relational Mapping Algorithm
아래 순서대로 진행하면됨

* **Regular Entity Types E**
  * 먼저 E의 Relation R을 만든 후 E의 모든 Simple attribute들을 포함시킨다
  * Composite attribute의 Simple component들만 추가 시킨다
  * E의 키 중 하나를 Primary 키로 설정한다. 선택된 키가 Composite라면 모두 같이 Primary 키가 된다
  * 만약 키가 여러 개라면 Secondary(Unique) 키로 설정해 놓는다 (나중에 Indexing등에 사용)
* **Weak Entity Types W**
  * Owner Entity Type O
  * W의 모든 Simple attribute들을 포함하는 Relation Rw를 만든다
  * Rw에 O의 Primary 키에 대한 Foreign 키를 추가한다 (W의 Indentifying Relation Type 맵핑)
  * W의 Primary 키는 O의 Primary 키와 W의 Key를 조합해서 만든다
  * 만약 O 또한 Weak entity type이라면 O먼저 처리한다
* **Binary 1:1 Relationship Types R**
  * 각 Relation Type R에 대해, R에 연관된 S와 T 부터 찾는다
  * 3 방법이 가능 Foreign 키, Merged relationship, Cross-reference 방법. 보통 Foreign 키 접근 사용
  **1. Foreign 키 방법** : 하나의 Relation S를 선택하고, T의 Primary 키를 S의 Foreign키로 넣는다. S는 R에 Total participation하는 Entity로 보면 된다(MANAGES의 경우 S는 DEPARTMENT). R의 모든 Simple attribute들을 S의 Attribute로 넣는다
  **2. Merged Relation 방법** : S, T 둘 다 Total participation이라면 두 Relation을 묶어버림 (항상 튜플의 갯수가 같다는 말이기 때문)
  **3. Cross-reference (relationship relation) 방법** : Relation R'을 새로 만들어서 S와 T의 Primary 키를 서로 Referencing하게 한다(M:N Relationship일 경우). 이때 R'를 Rlationship relation이라 한다. R'는 S와 T의 Primary 키를 Foreign 키로 가지고 있고, R'의 Primary 키는 둘 중 하나의 키로 설정하고 다른 하나는 Unique 키로 놔둔다
* **Binary 1:N Relationship Types R**
  * N인 쪽을 S, 1인 쪽을 T라고 하였을 때, S에 Foreign 키로 T의 Primary 키를 넣는다 (WORKS_FOR의 경우 S는 EMPLOYEE, T는 DEPARTMENT)
* **Binary M:N Relationship Types R**
  * R 마다 R을 위한 새로운 Relation S를 만든다. 참여하는 릴레이션들의 Primary 키를 S에 Foreign 키로 넣고 이 키들의 조합을 S의 Primary 키로 둔다. 그리고 R의 Simple attribute들을 S의 Attribute로 넣는다
* **Multivalued Attributes A**
  * A마다 새로운 Relation R을 만든다. R은 A에 해당하는 Attribute를 가지고, 부모의 Primary 키 K를 R의 Foreign 키로 가진다. A와 K를 조합해 R의 Primary Key로 사용한다. A가 Composite이라면 Simple component들을 추가한다
* **N-ary Relationship Types R**
  * N > 2인 R에 대해서 (이때 N을 **Relationship의 Degree**라 함) 새로운 Relation S를 만든다. S에 연결된 Entity들의 Primary 키를 R의 Foreign 키로 가진다. 그 후 R의 Simple attribute들을 S에 추가한다. S의 Primary 키는 보통 S의 모든 Foreign 키의 집합으로 구성한다. 만약 R에 연결된 Entity E가 1로 연결되어 있으면 Primary 키에서 해당 키를 제외한다

#### Relationship Types of Degree Higher than Two
Relationship Type에서 Degree가 2 보다 클 경우, 작은 단위로 나눠야 할 수도 있다. 이럴 경우 Degree를 낮추거나, Weak Entity Type으로 쪼개서 해결해야 할 수도 있다

## Conceptual Data Modeling Using UML
UML(Unified Modeling Language)은 OMG(Object Management Group)의 표준이다
* 다이어그램을 이용하여 Language의 Syntax나 Life cycle을 알 수 있게 해줌
* 많은 OOP(Object-Oriented Programming) 방법론들을 결합해서 만듬
* 예시로 Class Diagram이 있음

![](/assets/images/markdown-img-paste-20190305145245216.png)

### Class diagram
* 박스 가장 위에 클래스 이름 명시
* 인터페이스 이름 위에 `<<interface>>` 명시
* 가상 클래스는 클래스 이름을 *이탈릭체*로 명시
* Attributes : 클래스의 모든 필드 포함
* Methods : 간단한 것 (get, set)은 제외 할 수도 있음 (인터페이스는 제외하지 말 것), 상속 받은 함수 포함시키지 말 것
* Generalization
  * Inheritance between classes : A가 부모, B가 자식
    * ![](/assets/images/markdown-img-paste-20190305151838827.png)
  * Interface implementation : A가 인터페이스, B가 구현
    * ![](/assets/images/markdown-img-paste-20190305151847478.png)
* Association
  * Association : 개념상 서로 연결, 한 클래스가 다른 클래스에서 제공하는 기능 사용할 때 표시
    * ![](/assets/images/markdown-img-paste-20190305151933275.png)
  * Aggretgation : Class A가 class B 객체를 포인터로 포함 (A가 사라져도 B 안사라짐)
    * ![](/assets/images/markdown-img-paste-20190305151942410.png)
  * Composition : Class A가 class B 객체 자체를 가짐 (A가 사라지면 B도 사라짐)
    * ![](/assets/images/markdown-img-paste-20190305151951355.png)
  * Dependency : Association과 유사하지만, 한 클래스가 다른 클래스의 메소드를 잠시 사용하는 등 짧은 시간 동안 관계 유지
    * ![](/assets/images/markdown-img-paste-20190305152002883.png)
* Multiplicity : min...max
* ER에서는 위의 표와 같이 사용함

---

# Physical DB Design

## Tables in Oracle
* **Relational Tables**
  가장 일반적인 테이블 타입
  `CREATE TABLE`

* **Object Tables**
  테이블 객체를 만듬
  ```
  CREATE TYPE department_typ AS OBJECT (
    d_name VARCHAR2(100),
    d_address VARCHAR2(200)
  );
  CREATE TABLE department_obj_t OF department_typ;
  INSERT INTO department_obj_t VALUES('hr', '10 Main St, Sometown, CA');
  ```

* 아래 성격을 가진 테이블을 만들 수 있음
  * **Heap-organized table** : 각 튜플이 순서를 가지지 않고 디스크에 저장. CREATE TABLE 명령을 실행하면 Default로  heap-organized table로 만듬
  * **Index-organized table** : B+ - tree index 우선 순위를 가지고 저장소에 저장, Primary 키 순서로 저장.
  * **External table** : 읽기 전용 테이블. DB안에 Metadata가 저장되어 있지만, 파일은 실제로 DB 밖에 저장됨

* 테이블은 **영구적(Permanent)이거나 일시적(Temporary)** 함. 영구적 테이블의 정의와 데이터는 세션이 바뀌더라도 유지되지만, 임시 테이블의 정의는 세션이 바뀌어도 유지되나 데이터는 트렌섹션 이나 세션 동안 유지됨

### Heap-Organized Table
![](/assets/images/markdown-img-paste-2019030515551705.png)

### Index-Organized Table
* Table-Bases Indexes
```
CREATE TABEL locations(
  id            NUMBER(10) NOT NULL,
  description   VARCHAR2(50) NOT NULL,
  map           BLOB,
  CONSTRAINT pk_locations PRIMARY KEY (id)
)
ORGANIZATION INDEX  // Index 테이블임을 명시
TABLESPACE iot_tablespace
PCTTHRESHOLD 20  // Block 사이즈 20% 넘어가면 Partitioning
INCLUDING description OVERFLOW TABLESPACE overflow_tablespace; // Overflow 일어나면 overflow_tablespace에 넣어라
```
* Function-Based Indexes
```
CREATE INDEX emp_depit_ix ON hr.employees(department_id); // employees는 Table, department_id는 Column
CREATE INDEX emp_name_dpt_ix ON hr.employees(last_name ASC, department_id DESC); // ASC 오름차순, DESC 내림차순
CREATE INDEX emp_total_sal_idx ON employees(12 * salary * commission_pet, salary, commission_pet);
```

* Oracle은 Primary 키에 대해서는 자동으로 색인을 만들어 주지만 Foreign 키에 대해서는 자동으로 만들어주지 않음
* Index는 선택적인 구조, 테이블이나, 테이블 클러스터에서 **데이터 접근 속도 빠르게** 해줌
  * 만약 DB에서 전체 테이블 중 작은 비율을 가지는 튜플들을 자주 요청할 경우 필요
  * 색인이된 열들은 **Referential Integrity constraint**를 만족함
* **Heap-organiezd-table은 색인이 없으므로**, DB에서 값을 찾으려면 Full scan 필요
* Index 테이블을 만드려면 Table에 Primary 키를 꼭 설정한 다음, ORGANIZATION INDEX 명령어 사용하면됨
* **PCTTHRESHOLD integer** : Index-organized table 행을 위해 Index block에서 예약된 공간의 퍼센티지. Primary 키 담을 수 있을 만큼은 커야함.  1~50 사이로 설정해야하고 기본 값은 50,
* **INCLUDING column_name** : Index-organized table 행에서 index와 overflow로 나눌 열. Primary 키 열은 무조건 index에 저장됨. column_name은 마지막 Primary 키 열이거나, 아니면 Primary 키가 아닌 열로 설정. column_name 다음의 Nonprimary 키 열들은 overflow 데이터 세그먼트 안에 들어감. **만약** column_name까지의 사이즈가 PCTTHRESHOLD에서 정의한 index의 영역보다 크다면, DB가 PCTTHRESHOLD에 따라 행을 분해함
* **OVERFLOW TABLESPACE** : Overflow 데이터가 저장될 테이블 명시

![](/assets/images/markdown-img-paste-20190305160955276.png)

### Table Clusters in Oracle
Common column을 같은 장소에 넣을 수 있게 해줌. 성능 문제로 안하는게 좋음
* 만약 Table cluster를 사용한다면 하나의 Data 블럭이 여러 테이블의 row를 가짐
* Cluster 키를 가짐, 예를 들어 employee와 department에서 department_id를 공유하는데 department_id를 Cluster 키로 둘 수 있음

### Indexed Clusters in Oracle
데이터를 찾기 위한 색인을 가진 Table cluster
* **Cluster index** : Cluster ket를 이용한 B-tree index
* Cluster table에 자료가 삽입되기 전에 Cluster index 만들어야함

```
CREATE CLUSTER employees_departments_cluster (
  department_id NUMBER(4)
)
SIZE 512;
CREATE INDEX idx_emp_dept_cluster ON CLUSTER employees_departments_cluster;
```
이렇게 만든 후 Employee와 Department 테이블을 만든다
```
CREATE TABLE employees(...)
CLUSTER employees_departments_cluster(department_id);

CREATE TABLE department(...)
CLUSTER employees_departments_cluster(department_id);
```

![](/assets/images/markdown-img-paste-2019030516274028.png)

### Hash Clusters in Oracle
Indexed cluster와 같지만 Index 키가 해쉬 함수로 대체됨. Hash cluster에서는 데이터가 Index가 됨

```
CREATE CLUSTER employees_departments_cluster(
    department_id NUMBER(4)
)
SIZE 8192 HASHKEYS 100; // Hash entry 갯수
```

![](/assets/images/markdown-img-paste-20190305163004491.png)

## Tablespace, Segment, Extent, Oracle Data Block

### Logical Storage Structures
* Oracle은 모든 데이터를 **Data file**에 저장
* **Tablespace** : 하나의 테이블이 여러 data file에 저장되는 것을 허용하기 위해, data file하나 이상으로 구성되는 tablespace라는 논리적 disk 공간 개념 제공
* 시나리오
  1. DBA(Database Administrator)는 여러 Tablespace들을 생성해 둠
  2. DBA는 각 User 계정에 대해 그 계정을 생성할 때 마다 하나의 Default tablespace 할당
  3. 각 사용자는 자신의 Default tablespace에 Table 생성
  4. 하나의 Table은 오직 하나의 Tablespace안에서 공간을 할당 받음

![](/assets/images/markdown-img-paste-20190305164527489.png)

* 만약 Tablespace A에 Table B가 생성된다면 이를 Segment라 칭함 **(Segment와 Table은 1:1 대응)**. Segment 또한 여러 개의 Data file로 구성됨
* Oracle은 하나의 Segment에 디스크 공간을 할당하고 그 Segment에서 할당 받는 단위를 **Extent**라 함. 하나의 Extent는 연속된 여러 개의 **Oracle data block**들로 구성. 하나의 Oracle data block은 여러 개의 **OS data block**들로 구성
* 논리적 연속성을 위해 Extent 단위로 공간 할당, 해제
* 파일 IO의 효율성을 위해 Oracle data block 사용
* 하나의 Extent는 Data file을 늘릴 수 없음

![](/assets/images/markdown-img-paste-20190305165032745.png)

## Record, Block, Data File, and Index File
* Primary 키는 자동으로 색인 생성 (Primary index)
* Secondary index는 따로 설정해 줘야함 (보조 색인)
* Block(Page) ID : File ID + Block Number
* RID (Record Identifier) : 물리적 구분자 (Object ID, Page ID, Row Number)

![](/assets/images/markdown-img-paste-20190305170056723.png)

![](/assets/images/markdown-img-paste-20190305170901731.png)

## The Format of the Data Record

### Three Record Storage Formats
* 고정된 길이 할당 (최대 길이로, DBMS는 따로 최적화 안함)
* 구분자로 구분 (동적으로 크기 변할 때)
* 구분자로 구분하고 마지막에 Terminate 기호 삽입

![](/assets/images/markdown-img-paste-20190305171155802.png)

* 오라클에서는 (b) 사용, fixed_part에 오프셋 값이 있음 (몇 바이트 떨어져 있는지)
  * 만약 NULL이라면 길이는 0 (앞, 위 fixed_part가 같다고 보면됨, [2][3][3][1])
  * 헤더에는 NULL-bit array가 있음
  * 길이는 c[i+1] - c[i]

![](/assets/images/markdown-img-paste-20190305171407626.png)

### Types of Record Organization
(a) Unspanned (보통 사용)
(b) Spanned

![](/assets/images/markdown-img-paste-20190305171656889.png)


## Data File에 Record를 위치시키는 방법
* Primary file organization
  * 어떻게 디스크에 file records들을 넣을지, record들에 접근할지
  * **Heap file (순서 없음)** : 순서 없이, 파일의 가장 마지막에 Record 삽입
  * **Sorted file (순서를 가짐)** : 특정한 필드(**Sort key**)의 값에 따라 정렬해서 Record를 저장함
  * **Hashed file (해싱)** : 특정 필드(Hast key)에 해쉬 함수를 적용해서 위치 특정
  * **B-trees**
* Secondary organization (Auxiliary access structure)
  * 좀 더 효율적으로 파일에 접근 가능하게 해줌 (Primary 필드 말고 다른 필드 사용해서)

### Heap Files
삽입된 순서 그대로 파일에 들어감 (새로운 레코드는 파일의 가장 끝)
* Heap 또는 Pile file이라 함
* Secondary indexes를 쓰기도 함
* Insert : 그냥 끝에 넣으면 끝
* Search : 선형 검색 밖에 못함 O(N)
* Delete : Search 후 삭제, 삭제된 공간이 비어서 이럴 경우 저장 공간이 낭비됨
  * Deletion marker로 삭제되었다는 것을 표시 가능
  * 한번 Reorganization할 때 다 지움
  * Deleteion marker가 있는 곳에 Insert해도 되지만 따로 관리 필요
* 보통 Unspanned로 관리
  * 레코드의 크기가 고정되어 있으면, 연속적으로 할당되어 있을 때 접근이 쉬움

### Sorted Files
* **Ordering field**를 기준으로 값에 따라 레코드 저장 가능 (Ordered or Sequential file) 만약 Ordering field가 파일의 **Key field**라면 이를 **Ordering key**라함
* Binary search O(logN)를 이용해 빠르게 파일 접근 가능, 레코드가 한 블럭안에 있기 때문에(레코드가 블럭 마지막이 아니라면) 다른 블럭 접근 필요 없음. 물리적 Cylinder에서도 Seek time을 적게 해줌
* 하지만 Random 접근이나, 정렬되지 않은 Field에 대해서는 마찬가지로 선형 검색 필요
* 삽입/삭제 연산이 힘듬, 삽입이나 삭제가 되더라도 물리적으로 정렬되어 있어야하기 때문, 삽입/삭제 일어난 뒤의 파일들을 모두 옮겨야함
* 사용되지 않는 공간을 표시하고 거기에 삽입을 해도 되지만, 결국 모든 공간이 사용되면 똑같음
* 보통 **Temporary unordered file**(Overflow/Transaction file)을 만들고 원래 파일을 **Master 파일**이라 부름.  새로운 레코드는 Overflow 파일의 마지막에 삽입함. 주기적으로 Reorganization을 해서 Overflow 파일을 Master 파일과 병합
* Ordered files은 DB에 가끔씩만 쓰임. Primary index를 사용해 Indexed-sequential file로 만들어서 사용. Ordering 키 필드에 대한 랜덤 접근 시간을 빠르게 해줌. Ordering attribute가 키가 아니라면 Clustered file 이라함

### Hash Files
* 해싱에 기반한 파일. 특정 검색 조건에서 아주 빠른 레코드 접근을 하게 해줌
* 보통 **Hash file**이라 부름
* 검색 조건은 하나의 **Hash field**에 대한 조건과 마찬가지
* Hash field가 키라면 **Hash key**라고 함
* Hash 필드 값에 **Hash 함수**를 적용하여 파일의 주소를 알 수 있음. 대부분 경우 레코드 한 번만 보면됨

#### Internal Hashing
내부 파일들에 대해 해싱 적용. 보통 Hash table 사용
* 레코드의 배열을 사용해 해싱 구현
* 배열이 M개의 슬롯을 가진다면 해시 함수는 0 ~ M-1사이의 정수로 해시 필드의 값을 변환함
  * 기본 : h(K) = K mod M
* Collision : 해시 필드 값에 이미 다른 레코드가 있을 경우
* Collision resolution : Collision 해결
  * Open addressing : 빈 필드를 찾을 때까지 다음 필드의 값을 조사한 후 빈 필드에 삽입
  * Overflow chaining : 오버플로우 영역에 새로운 레코드를 저장하고 링크들 리스트로 연결
  * Multiple hashing : 충돌이 일어나기 전까지 해시 함수를 차례로 적용

#### External Hashing
디스크 파일들에 대해 해싱 적용
* Bucket이라면 배열 사용, Bucket에 목적지 주소 공간이 있음
* 버켓은 하나의 디스크 블럭이거나, 연결된 디스크 블럭 클러스터
* 해싱 함수를 통해 **Relative bucket number**를 알 수 있음
* 파일 헤더를 통해 Bucket number를 디스크 블럭 주소로 바꿔줌
* 디스크 블럭을 가리키기 때문에 한 블럭에 여러 개의 레코드가 들어갈 수 있어 Collision 문제에서 좀 더 자유로움. 만약 다 찬다면 Chaining 기법 사용. Overflow한 레코드에 대한 링크드 리스트 사용 (블럭이 아니라 레코드의 포인터). 블럭 주소와, Relative record position을 같이 가져야함
* 앞의 방법은 **Static 해싱**이라 버켓 M의 사이즈가 정해져 있음. Dynamic 파일들에 대해 문제점을 가짐

#### 동적 확장이 가능한 해싱 기법
Static 해싱의 문제점 해결
* **Extendible hashing**
  * **Directory**는 $2^d$의 버켓 주소를 가짐. **d는 Global depth**라 함. 해시값의 첫 d개의 비트에 해당하는 값을 통해 Directory entry를 찾음. 그리고 그 Entry가 레코드가 저장될 버켓을 정함. 디렉토리가 각각의 버켓을 가리키는 것이 아니라 여러 개의 디렉토리가 하나의 버켓을 가리킬 수도 잇음. 그리고 **d'라는 Local depth**도 각 버켓마다 가지는데, 버켓이 가진 요소들의 비트 갯수를 나타냄
  * d가 커지거나 작아지면서, 디렉토리 배열이 가질 수 있는 Entry를 조정가능. 만약 **어떤 버켓의 d'가 d와 같은 상태에서 Overflow가 일어나면 d가 두배로 커짐**. 삭제 과정에서 **모든 버켓의 d'이 d 보다 작다면 반으로 줄임**
  * Directory, Bucket 두 단계로 구성되서 간단
  * 아래의 그림에서 010, 011이 가리키는 버켓에 Overflow가 일어난다면, d'가 3으로 늘어나고 두 버켓으로 나뉘게되며, 해쉬 값의 첫 비트가 010인 레코드는 010 버켓으로, 011인 레코드는 011 버켓으로 나눈다
  * 만일 111 버켓에 Overflow가 생겼다면, d = d'이므로 d와 d'을 1씩늘리고 Directory 배열을 두배로 늘린 다음, 다른 Directory entity들도 두개로 나누가 같은 값으로 채워 넣음
  * **파일이 많아지더라도 성능이 떨어지지 않는 장점**이 있음

  ![](/assets/images/markdown-img-paste-20190305183912364.png)

* **Dynamic hashing**
  * Directory없이 이진 트리로 구성
  * Internal nodes : 좌측 자식은 bit가 0일 경우, 우측 자식은 bit가 1일 경우
  * Leaf nodes : 레코드의 버켓에 대한 포인터가 들어있음

  ![](/assets/images/markdown-img-paste-20190305185930470.png)

* **Linear hashing**
  * Directory 없이 버켓의 갯수를 늘리고 줄이는 것
  * 처음 버켓의 수는 M, n = 0
  * $h_1(K) = K\ mod\ M$
  * 각각 Overflow chaining을 함
  * 만약 Overflow가 일어나면 n번째 버켓이 두개의 버켓(n, M)으로 나눠지고, 새로운 해쉬 함수 $h_2(K) = K\ mod\ 2M$이 추가되고, n = n + 1. 만약 $h_1(K) < n$이라면 $h_2(k)$를 적용.
  * n이 증가해서 M과 같아졌다면, M을 두배로 키우고 n을 0으로 리셋
  * [youtube](https://www.youtube.com/watch?v=h37Jhr21ByQ) 참고

## Database File Indexing Techniques, B-Trees, B+ - Trees

### Types of Indexes
* Types of Indexes

||물리적 순서를 위한 Index Field|물리적 순서를 위한 것이 아닌 Index Field|
|--:|:--:|:--:|
|Index field가 Key|Primary index|Secondary index(Key)|
|Index field가 nonkey|Clustering index|Secondary index(NonKey)|

* Properties of Index Types
* Dense : 해당 키의 모든 값들을 가질 경우. 반대는 Nondense(Sparse)

|Type of Index|첫 인덱스 엔트리 갯수|Dense/Nondense|Block Anchoring|
|--|:--:|:--:|:--:|
|Primary|Data file의 Block 갯수|Nondense|O|
|Clustering|Index field 값들의 갯수|Nondense|O/X|
|Secondary (Key)|Data file의 레코드 갯수|Dense|X|
|Secondary (NonKey)|레코드 갯수이거나, Index field 값들의 갯수|Dense/Nondense|X|

* Primary index (기본 색인) : 키 열에 대해 Data file의 레코드들을 정렬하는 색인
* Clustering index (클러스터링 색인) : 키가 아닌 열어 대해 Data file의 레코드를 정렬하는 색인
* Secondary index (보조 색인) : Data file의 레코드를 정렬하는 것이 아니라 탐색 시 사용됨

* Ordered indexes : Primary index, Clustering index, Secondary index
* 블럭에서 첫 데이터를 **Anchor record 혹은 Block anchor**라고 함

* eg
  * EMPLOYEE에서
  * 레코드 수 r = 30000
  * 레코드 크기 R = 100 byte
  * 블럭 크기 B = 1024 byte
    * 블럭킹 펙터 RFB = B / R = 10 레코드/블럭
    * 파일 블럭수 b = r / RFB = 3000블럭
  * SSN필드로 인덱스 구성한다면
    * SSN크기 VSSN = 9 byte
    * 레코드 포인터 P = 6 byte
      * 인덱스 엔트리 크기 Ri = VSSN + P = 15 byte
      * 인덱스 블럭킹 펙터 RFBi = B / Ri = 68 엔트리/블럭
      * 인덱스 블록수 bi = r / RFBi = 30000 / 68 = 45블럭
    * 이진 탐색 시 : $log_2(45)$ = 6블럭
    * 선형 탐색 시 : b / 3000 = 1500블럭

### B-Tree
* Search Tree 중 하나
* 항상 Balance(균형) 유지
* 모든 Leaf 노드들이 같은 레벨에 있음
* Underflow : 각 노드는 최소 반 이상 차있어야함

### B+ - Tree
* 대부분 상용 DBMS는 B+ 트리 사용
* Tree Level은 Height - 1, Height는 실제 높이
* Internal Node
  * <(P1, K1), (P2, K2), ... , (Pq-1, Kq-1), Pq>
  * K는 데이터 P는 자식 포인터
  * Pi가 가리키는 자식은 Ki 보다 작다
* 모든 Leaf 노드는 같은 레벨에 있다
* Leaf 노드에는 Key값과 RID가 들어있다
* Leaf 노드는 이웃과 서로 Dobuly Linked List로 연결되어 있다
* Underflow : 각 노드는 최소 2/3 이상 차 있어야 함
* **Key의 삽입**
  * 항상 Leaf node에 삽입
  * 만약 Overflow가 발생하면 Split
    * 노드 N을 새로 만든다
    * j = ceil((P + 1) / 2)개의 엔트리는 그대로 두고 나머지는 N으로 옮긴다
    * j번째 값과 N에 대한 포인터를 부모로 올린다
    * 원래 노드에 Overflow가 일어난 값을 추가한다
    * 부모 노드도 Overflow가 발생하면 해당 노드도 재귀적으로 Split한다
* **Key 삭제**
  * 항상 Leaf node에서 삭제
  * 만약 Underflow가 발생하면 Redistribution(재분배) 하거나 Merge(합병) 한다
    * 형제 Leaf 노드를 찾아 현재 Leaf 노드와 엔트리를 재분배한다
    * 재분배시 두 노드 모두 반이 이상 찰 수 없다면 형재 노드와 결합하고 Leaf 노드 수를 줄인다
    * 부모 노드도 Underflow가 발생하면 재귀적으로 재분배 혹은 합병한다

* eg
  * 삽입 : <8,x>, <5,y>, <1,z>, <7,w>, < 3,v>, <12,u>, <9,f>, <6,g>

  ![](/assets/images/markdown-img-paste-20190305201639218.png)
  ![](/assets/images/markdown-img-paste-20190305201721420.png)
  ![](/assets/images/markdown-img-paste-20190305201737461.png)
  ![](/assets/images/markdown-img-paste-20190305201746716.png)

  * 삭제 : <5,y>, <12,u>, <9,f>, <8,x>

  ![](/assets/images/markdown-img-paste-20190305202630644.png)
  ![](/assets/images/markdown-img-paste-20190305202641748.png)

### 다중키 인덱스
####B+ - Tree
B+와 동일하게 처리하면됨, 키가 여러 개일 뿐

![](/assets/images/markdown-img-paste-2019030520284801.png)

### 분할 해싱

![](/assets/images/markdown-img-paste-20190305203008747.png)

### 그리드 파일
만약 EMPLOYEE테이블에서 DNO, AGE로 파일을 접근하고 싶다면, 그리드 배열을 만든 다음 파일에 저장해놓으면됨

![](/assets/images/markdown-img-paste-20190305203333290.png)

### Bitmap Indexes
한 Attribute에 대해 가능한 값들을 Bit로 인덱싱 한다
* 아래 표에서 M의 경우 Row_id 순서로 M F M F F M M F 이므로 이를 1 0 1 0 0 1 1 0 으로 바꾼 것
* 예를 들어, 성별은 F 이고, Zipcode는 30022인 사람을 알고 싶다면, 01011001과 01010010에 대해 AND 연산을 하면 01010000이 되므로 2번째와 4번째 튜플을 가져오면됨
* Oracle
```
// EMPLOYEE 테이블의 commission Attribute에 대해 만듬
create bitmap index idx_emp_commission_bit on EMPLOYEE(commission);
```
* 원래 B+ 트리의 경우 <Index key value, RowID>로 구성되지만, Bitmap index는 <Index key value, {Start RowID, End RowID, Bitmap엔트리}> 로 구성됨

![](/assets/images/markdown-img-paste-20190305203836265.png)

### Funstion-Based Indexing
* Oracle
```
CREATE INDEX upper_ix ON EMPLOYEE(UPPER(Lname));
```

* 아래 예시에서 구문이 조금 다르긴 하지만 자동으로 income_ix 색인을 사용함
```
CREATE INDEX income_ix ON EMPLOYEE(Salary + (Salary * Commission_pct));
SELECT fname, lname FROM employee WHERE((Salary * Commission_pct) + Salary) > 15000;
```

---

# SQL
* 한 줄 혹은 여러줄에 기술 가능
* 탭 사용 가능
* 대소문자 구분 안함
* ;으로 종료
* SQL Buffer에 명령어 저장됨
* SQL Buffer에 저장된 명령어는 RUN 혹은 /로 실행 가능
* PL/SQL이라는 Subprogram 사용 가능 (프로그램 같은 SQL)
  ```
  DECLARE
    x NUMBER := 100;
    BEGIN
      FOR i IN 1..10 LOOP
        IF MOD (i, 2) = 0 THEN
          INSERT INTO temp VALUES(i, x, 'i is even');
        ELSE
          INSERT INTO temp VALUES(i, x, 'i is odd');
        END IF;
        x := = X + 100;
      END LOOP;
    END;
  /
  ```
## Data Types
